<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: think | Shou's origin]]></title>
  <link href="http://shouya.github.io/blog/category/think/atom.xml" rel="self"/>
  <link href="http://shouya.github.io/"/>
  <updated>2015-05-13T03:55:59-04:00</updated>
  <id>http://shouya.github.io/</id>
  <author>
    <name><![CDATA[Shou Ya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[誡之二]]></title>
    <link href="http://shouya.github.io/blog/admonition-sono-ni/"/>
    <updated>2015-05-08T14:50:53-04:00</updated>
    <id>http://shouya.github.io/blog/admonition-sono-ni</id>
    <content type="html"><![CDATA[<p>凌，則隱  <br />
長，則同  <br />
驕而與人者  <br />
共聞之    </p>

<p>host 曰：即有大樂者，與悲治之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[誡之一]]></title>
    <link href="http://shouya.github.io/blog/admonition-sono-ichi/"/>
    <updated>2015-05-03T22:17:11-04:00</updated>
    <id>http://shouya.github.io/blog/admonition-sono-ichi</id>
    <content type="html"><![CDATA[<p>分離，融合  <br />
形影不離  <br />
恥辱，榮耀    </p>

<p>注視卻無視  <br />
偉大卻無名  <br />
萬能卻不為    </p>

<p>他是你的 host，你的聖人  <br />
那你呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深淵]]></title>
    <link href="http://shouya.github.io/blog/the-abyss/"/>
    <updated>2014-12-24T11:06:41-05:00</updated>
    <id>http://shouya.github.io/blog/the-abyss</id>
    <content type="html"><![CDATA[<p>站在深淵面前   <br />
驅使自己踏前一步   <br />
恐懼充滿我的內心  <br />
所以我捂著雙眼    </p>

<p>我不斷跌落，跌落  <br />
以至於甚至當我想起抬頭  <br />
向上看一眼時  <br />
已經沒有任何光亮了    </p>

<p>沒有朋友，沒有敵人，沒有人  <br />
我感到恐懼，而又熱愛著她  <br />
我熱愛這黑暗  <br />
我熱愛這未知的周圍  <br />
<!-- more -->
在深淵中  <br />
我才能看到黑暗  <br />
我才有無盡的自由  <br />
像剛剛出生的嬰兒一般    </p>

<p>這裡有人  <br />
第一次見到卻再也熟悉不過  <br />
我作出友善的微笑  <br />
看起來像要哭出來一樣    </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function Calling Syntax]]></title>
    <link href="http://shouya.github.io/blog/function-calling-syntax/"/>
    <updated>2014-08-03T05:59:14-04:00</updated>
    <id>http://shouya.github.io/blog/function-calling-syntax</id>
    <content type="html"><![CDATA[<p>We use programming languages to indicate a process of
actions/computations. Therefore programming languages tends to be more
procedual. In other words, they are used to indicate how a thing is
done.</p>

<p>Just as the role of verbs in a nature language sentence, an action is
the most essential part of ‘doing a task’ in programming language. Of
course the syntax of a programming language could be complex. I’d be
here to discuss only the simplest cases of function calling among
different programming languages.</p>

<!-- more -->

<p>Here’s a table of the terms used in different paradigms.</p>

<table>
  <thead>
    <tr>
      <th>Paradigm</th>
      <th>Term for the Acting Object</th>
      <th>Term for the Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Imperative</td>
      <td>Function/Procedure</td>
      <td>Call/Invoke</td>
    </tr>
    <tr>
      <td>OO</td>
      <td>Method</td>
      <td>Invoke/Send Message</td>
    </tr>
    <tr>
      <td>Functional</td>
      <td>Function/Closure</td>
      <td>Apply</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>Operation</td>
      <td>Act</td>
    </tr>
    <tr>
      <td>Lambda Calculus</td>
      <td>Lambda/Combinator</td>
      <td>Apply</td>
    </tr>
  </tbody>
</table>

<h2 id="object-oriented-languages-ruby-c">Object Oriented Languages (Ruby, C++)</h2>

<p>OOP is an analog of object manipulation in the real world. Actually,
semantically <code>foo.bar(baz)</code> does not mean <code>foo</code> does an action <code>bar</code>
on <code>baz</code>. Rather, according to the OOP mechanism, it should be
regarded as a message <code>bar</code> send to the actor <code>foo</code> with argument
<code>baz</code>. Look at the code snippets below in Ruby and C++.</p>

<p><code>ruby
$stdout.puts "hello"
</code></p>

<p><code>c++
vec.push_back("hello")
</code></p>

<p>How would we translate them in English? The result is probably similar
to these:</p>

<blockquote>
  <p>(The computer) puts “hello” on $stdout.</p>

  <p>(The computer) pushes “hello” into vec.</p>
</blockquote>

<p>In such invocations, obviously the subject is uslally omitted because
we’re always ordering the computer to do the actions.
The receivers, or target objects, are put at the front. Then
follows the actions we want to apply on them. And finally the
arguments, or carried objects.</p>

<p>Notice that the in Ruby the object is often omitted because it is
implied in the current context (<code>self</code>). And in C++ <code>this</code> is
sometimes omitted if we’re operating in a method within the same class.
It is similar to the case omitting object in a nature language when
we’re in a specific environment. For example, if we are working on a
task and then we say ‘finished’, the object can be understood as the
task we were working on.</p>

<h2 id="stack-basedconcatenative-languages-dc-factor-assembly">Stack-based/Concatenative Languages (dc, Factor, Assembly)</h2>

<p>The core of stack-based languages is the operation on a stack involves
pushing and popping.</p>

<p><code>dc</code> is a tiny calculator. The language of it is succinct and handy. Here’s an example:</p>

<p><code>bash
[hello]p
</code></p>

<p>The square brackets quotes a string of characters and push them into a
stack. Then the operation <code>p</code> pops the string out and then prints it.</p>

<p>Stack-based language can be as simple as dc, while also can be as
complex as Factor. Yet either of them have the same syntax
structure. The following Factor code reverses an array.</p>

<p><code>haskell
{1 2 3} reverse
</code></p>

<p>We cannot directly translate them into one sentence of nature
languages because the invocation of a function should not be regarded
as a single process. As how we can see the process more clearly in
Assembly language:</p>

<p><code>c
push 0x0001   (0x0001 points to "world")
push 0x0010   (0x0010 points to "hello, %s.\n")
call 0x0100   (0x0100 points to the `printf` function in libc)
</code></p>

<p>The invocation of such functions can be seen as a kind of
argument-free operation. Their arguments are pushed to stack before
the function invocations and in the function the arguments would be
popped out to be manipulated.</p>

<p>If we still want to see the process of invocation as a single, we
would derive a pattern that the actions, or the verbs, are always put
at the last.</p>

<h2 id="functional-languages-scheme">Functional languages (Scheme)</h2>

<p>I consider the syntax of function invocation an opposition to the
stack-based languages. Unlike the invocation syntax in stack-based
languages, which put the action at the last, functional programming
languages tend to pose the action/function as precedent to the
arguments. I guess this phenomenon originates from the application
syntax of FP’s ancestor lambda calculus.</p>

<p>In Scheme, a typical hello world program looks like:</p>

<p><code>scheme
(display "hello world")
</code></p>

<p>It just looks like the stack-based language. In fact we can convert
functional operations into stack operations through
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation-passing style transformation</a>,
so easily convertible into Assembly. In fact this technique is often
used in Scheme compilers.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://factorcode.org/">Factor Programming Language</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Whitespace_(programming_language)">WP: Whitespace (PL)</a></li>
  <li><a href="http://www.linuxmanpages.com/man1/dc.1.php">dc (1) - man</a></li>
  <li><a href="http://concatenative.org/wiki/view/Concatenative%20language">Concatenative Languages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Stack-based">WP: Stack-based</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Stack-oriented_programming_language">WP: Stack-oriented Programming Languages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Word_order">WP: Word Order</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A brief journal about learning Coq]]></title>
    <link href="http://shouya.github.io/blog/a-brief-journal-about-learning-coq/"/>
    <updated>2014-07-04T13:08:34-04:00</updated>
    <id>http://shouya.github.io/blog/a-brief-journal-about-learning-coq</id>
    <content type="html"><![CDATA[<p><em>This article is completely an informal journal about my learning process on
Coq. It is just created as my whim prompted. Please don’t academically refer
any part of it as studying material to learn Coq.</em></p>

<h2 id="pre">Pre</h2>

<p>I first heard of Coq in my admiring mathematician,
<a href="https://twitter.com/txyyss">@txyyss</a>’s tweets. At the time I saw him talked
that he’s glad and immersed in re-proving all the theorems he had learned.
He also said, as deepening in Coq, he found a boost on other related
academic aspects. Driven by curiosity, I went to know about what a heck Coq
is. Then I saw it describe itself as a ‘Proof Assistant’. I felt something
uneven about it. Looking through all the programming languages I had
learned, even those as logically abstract as Prolog, were not capable to do a
proof.</p>

<!-- more -->

<p>At the time I was still in my high school. I just downloaded a Coq environment
on my
machine in the computer lab. Then I tried to follow the
<a href="http://coq.inria.fr/V8.1/tutorial.html">official tutorial guide</a> to explore how
to use it to do a proof. The experience was terrible. The official tutorial
was
completely not-novice-friendly, at least to me. I followed it for a section,
doing what the guide instructed me to do, and they all works. I learned <code>0</code>
has a
type of <code>nat</code>, and <code>nat</code> has a type of <code>Type</code>, and that’s all, no more things
substantial. The following sections are tough enough so I don’t even know what I
was doing. Thus I gived it up.</p>

<p>My curiousity was evoked the second time by the <span title="狂讚士">“berserk-faver”</span> <a href="https://twitter.com/javranw">@javranw</a>. He
express similar opinion and excitement as @txyyss towards Coq. At the time it
was the onset of the long summer vacation after high school graduation. I got
plenty of free time to learn the extracurricular interesting stuff. So I
decided to pick Coq up again.</p>

<h2 id="on">On</h2>

<p>This time I found a Virginia University course about Coq, published as
<a href="https://www.kevinjsullivan.com/00-syllabus">website</a>:
I decide to start here because I
saw the syllabus are well arranged and besides, I thought the course material
might be easier for a layman to get started.
([link to the tutorial]
(http://kevinjsullivan.org/Courses/Reasoning/L02_Intro.html))</p>

<p>The study curve of this course seems still steep. In the other words, the
course goes complicated soon after it teaches some common-sense-like
knowledge that I can hardly catch up with it. Besides, I don’t think the
guide is written in obvious and clear language.</p>

<p>I had also checked the well-known
<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/">Software Foundations</a>. And
I discovered it’s actually more clear and friendly to novice like me. So I head
on to study following this guide.</p>

<p>The progress was slow. While a few of the exercises, mostly rated 3+
stars, are really challenging. I tried to work on all exercises myself. And I
maintained a <a href="https://github.com/shouya/sf-sol">Github repository</a> to publish
my solutions.</p>

<p>I usually study it after midnight. So I could have a quiet and distract-free
environment for me to think. I was concentrated while doing the proofs. It
feels good. Especially after proving a difficult theorem, I acquired great
pleasance from the accomplishment. I can’t describe the the feeling as I
first proved the commutation law of multiplication, which took me about 3 hours.</p>

<p>In fact, in each new chapter I learned something new about Coq. Yet, as I
turned to the chapter of
‘<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/Logic.html">Logic</a>’, I learned
not only about Coq skills but also a mode of critical thinking towards the
base, the logic, and the logic of logic. I learned the logic system also need
an axiom, which subverted my view to logic before. A logical proposition can
either be true or false, and besides, it cannot guarantee to be in one of these
two states only. This axiom that establishes the whole logic system can be
expressed in many forms. An optional exercise in the guide is to prove they are
equivalent. Rated full 5 stars, this question is the most difficult exercise
I’ve met. Anyway I still finished 4/5 of it.</p>

<h3 id="sequela">Sequela</h3>

<p>I once tweeted (translated into English)
<a href="https://twitter.com/54c3/status/478478760371429376">link</a>:</p>

<blockquote>
  <p>I just dreammed in the nap. In the dream there was an arena-like place. The
fighters used with logic symbols as weapons. They battled, and exerted
various tactics. As a round over, they proved some theorem. #dream #coq
#broken_brain</p>
</blockquote>

<p>Really. My mind is full of logics in the days I study Coq. I can feel it
vividly that my mind start to ask about the logic of everything I see. Logic
would spring from my mind on every affairs. That is very interesting experience.
Especially after immersed in Coq for a whole night, I see everything and think:
can I prove it?</p>

<p>Somewhat I like that feeling :)</p>

<!--

Of course I still put my girlfriend Cres in the first position. I tried to
spare some times accompanying with her. But to do this I have to convince
myself in a illogical way (because there is no logic): my emotion will
nevertheless take all control of my flesh body than my ration in coping with
matters related to my girlfriend. So I stop thinking about Coq while chatting
with her.

I will have various affections while talking to her. However,
after she sleep and I get back to the world of Coq, every emotional sense just
go vain.

Oh... I can't let Cres know about this... She'll think that I'm belittling her.
Actually I'm regarding her in the most important position to me. Anyway. I'll
just comment it out. Nobody will read this paragraph :)

-->

<h3 id="intelligence">Intelligence</h3>

<p>In an ideal condition, to prove a theorem, I will first understand the theorem
itself, and conceive a way to prove it. Then I’ll translate the idea into
tactics in Coq. However, as I got more and more practiced in Coq, I do not
always follow this way to prove a theorem. For some simple theorems, I can prove
them without understanding them. I know what tactic should be used under
specific condition. I would only concern about the hypotheses and the goals. My
empirical intuition will guide me to the most likely way to prove them.</p>

<p>I first realized the situation while I was proving a theorem related to
<code>override</code> function in the next chapter after <code>override</code> is defined. I then
disinclined to review the definition of <code>override</code> again, because it’s a little
bit convoluting. Naturally I tried to prove it without reviewing the definition
of <code>override</code>. Also naturally I did it successfully. I realized the problem
just as I finished the proof. The first impression I raised is that I felt
panicky on myself. While as I then carefully checked the definition of
<code>override</code> function and the proof process, I found that’s already the optimal
way. I will do exactly the same after I understood the definition.</p>

<p>At that time, I had a sense that I was no longer a human, but a proving
machine. I knew the tactics, and I knew when to use them. Prooving theorems
seemed to be a machinery work. I was somewhat depressed on this kind of
loss-of-intelligence.</p>

<p>However, sometimes I thought in the other way. If I could grasp my empirical
intuition, turn them into substantial rules, can I make a program that can
prove whatever I can prove as a human? The program will never understand a
theorem, but they can prove them in a Coq’ly logical way.</p>

<h2 id="comments-on-the-design">Comments on the design</h2>

<p>I thought the design is the point I want dissing about Coq mostly. Although
powerful, Coq’s design on its syntax is as terrible as its “mother language”
OCaml, and even worse.</p>

<p>It might be improper for me, as a totally novice, to comment on Coq’s design. I
know I’m yet far from qualified to do that. Nonetheless I still want to talk a
little bit about it.</p>

<p>Of course, I know neither syntax nor some mechanism are the most crucial
things to a programming language. However, my steps followed the road of Ruby
→ Scheme → Haskell. Studying those PLs was pleasing, at least they
give me a sense of elegance. In contrast, I see Coq as a work from scratch
than being well designed.</p>

<h3 id="type-naming">Type naming</h3>

<p>Actually, types in Coq are not as obvious as in other PLs. Unusual types
are ubiquitous. I use ‘unusual type’ just because I don’t know how to descibe
them. The nature of each type are not just transparent, but also must be
defined by me manually. (At least I’m instructed to do so following the guide.)</p>

<p>The case of type names, in the beginning, confused me. Why are the type names
<code>nat</code>, <code>bool</code> lower-cased while <code>Set</code>, <code>Type</code>, <code>Prop</code> capitalized? I knew I
won’t know the why of every unknowns just as I touched it. So I memorized it
in a silly mode: names of the types we need to define by ourself are
lower-cased, and the others are capitalized.</p>

<p>This gave me the first intuition about differnet kinds of types.
While then I walked through the guide, and gradually realized the difference
between these two sort of types.</p>

<p>Here’s correct<sup>(?)</sup> understanding about it. <code>nat</code> and <code>bool</code> are
lower-cased because they are <em>inductive</em> types. In the other words, they are
defined in a specific number of cases. Contrarily, we don’t see this feature in
<code>Set</code>, <code>Type</code>, nor <code>Prop</code>, which are what we called <em>non-inductive types</em>.</p>

<h3 id="tactic-naming">Tactic naming</h3>

<p>Well, I shall just pose here the most frequently used tactic names.</p>

<p><code>simpl</code>, <code>reflexivity</code>, <code>destruct</code>, <code>induction</code>, <code>left</code>, <code>rewrite</code>.</p>

<p>Did you see them? The names range among abbreviations, nouns,
verbs, and adjectives. All of them are used as tactic names. While they’re not
funtioning in different categories. They’re really alike. The naming gives me
an impression that they are picked just from the whims of Coq inventors, so
they’re not strict at all. There is no choice that I have to memorize them.</p>

<h3 id="tactic-functioning">Tactic functioning</h3>

<p>It is understandable that tactics function in very different ways. The
behavior of them can sometimes be categorized with different fashions. For
example, some of them will mark a goal as proved so we can continue to next
goal or mark a <code>Qed</code> happily if all goals are proved. I call this feature
‘commit’. This is an informal term invented by me because I don’t know what’s
the accurate terminology for that.</p>

<p>It can be thought to categorize the tactics by whether they commit. But it
doesn’t apply to all the tactics. Now I have to pose three types:</p>

<ul>
  <li>commits: <code>reflexivity</code>, <code>assumption</code>, <code>exact</code>, …</li>
  <li>does not commit: <code>simpl</code>, <code>rewrite</code>, <code>unfold</code>, <code>symmetry</code> …</li>
  <li><span title="看心情">depends on mood</span>: <code>apply</code>, <code>inversion</code>, …</li>
</ul>

<p>Actually, there is an other case, because some tactics will split the goal into
more subgoals. I will put they in an different category.</p>

<ul>
  <li>yields subgoals: <code>assert</code>, <code>replace</code>, <code>destruct</code>, <code>induction</code></li>
</ul>

<p>In fact, these do not always yield a subgoal. The number of subgoals <code>destruct</code>
and <code>induction</code> yield depends on the number of inductive constructors of
the type of the expression they are operating on.</p>

<p>The behavior of inversion is ridiculous. One can conclude its usage as to
simplify the <em>injective</em> case and <em>disjoint</em> case. Even the Software
Foundations guide admits:</p>

<blockquote>
  <p>The inversion tactic is probably easier to understand by seeing it in action
than from general descriptions like the above.</p>
</blockquote>

<p>Surely, it’s not difficult to use. I will list the places it usually applys. Of
course these are just empirical conclusions.</p>

<ol>
  <li>false (disjoint equality) hypothesis (committing)</li>
  <li><code>foo a = foo b</code> ⇒ <code>a = b</code>, some like applying <code>f_equal</code>
theorem to a goal. (simplifing the hypothesis)</li>
  <li><code>a :: b = x :: y</code> ⇒ <code>a = x</code> and <code>b = y</code> (spliting injective cases)</li>
</ol>

<p>In use case 1, it commits. In case 2, it does not commit but simplies
a hypothesis. And in case 3, it split the cases. (As I write to here, I found
it not so ridiculous as I thought it be before.)</p>

<h3 id="tactic-option-syntax">Tactic option syntax</h3>

<p>The disparity of tactic options are really confusing me. They’re even more
difficult to remember than those tactic names. Voilà:</p>

<p><code>induction n, m</code> vs <code>intros n m</code>. Comma separated or space separated?</p>

<p><code>induction n as [| [x y] l]</code>. This syntax is used to name the induction
variables in different case. We can think of <code>n</code> here in type of <code>list (X * Y)</code>.
Notice that the cases ` ` and <code>[x y] l</code> are sperated with a <code>|</code> symbol, the
list head (<code>[x y]</code>) and tail (<code>l</code>) are seperated with a space, and one
individual element, of a pair, are embeded in another nested pair of square
bracket. Additionally, I don’t even know till now how Coq recognize
the user defined pair indicated in a specialized syntax <code>[x y]</code> correctly.</p>

<p><code>rewrite xxx</code> vs <code>rewrite &lt;- xxx</code>. In fact, the left is an abbreviation of
<code>rewrite -&gt; xxx</code>. I was confused on the special using of <code>&lt;-</code>. I thought it
is an abuse of the symbol. A better way I can conceive is to split the function
of <code>rewrite</code> into some like <code>rewrite[l,r]</code>.</p>

<p><code>destruct eqn:&lt;eqn&gt;</code>. This is yet another ridiculous non-uniform syntax. You
can imagine some use of destruct are like
<code>destruct &lt;expr&gt; as &lt;cases&gt; eqn:&lt;eqn&gt;</code>. It really happens. And I have to
memorized which goes first, the <code>as &lt;cases&gt;</code> or the <code>eqn:&lt;eqn&gt;</code>.</p>

<h3 id="notation-syntax">Notation syntax</h3>

<p>I couldn’t comprhend the usage of <code>Notation</code> so far. <code>Notation</code> is used to
define notations, or say, syntatic sugars. The part that embarrassed me is
its way to describe a syntax, which is a string, yes, a plain string. On the
anesthetic and semantic aspect, syntatic description in a PL should have the
the same syntatic level as the PL itself, rather than a degraded string.</p>

<p>On the other hand, the notation in Coq is so beautiful yet powerful. It even
capable to rival with standard macro definition in Scheme. I’ll pose some
examples.</p>

<pre><code>Notation "x + y" := (plus x y)
  (at level 50, left associativity).
Notation "( x , y )" := (pair x y).
Notation "x :: l" := (cons x l)
  (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" :=
  (cons x .. (cons y nil) ..).
</code></pre>

<p>I don’t yet know how the definition the in the last case comes in
nature. I’m curious about the implementation of the runtime syntatic definition
to such a complex case. Contrarily, it’s at least conceivable how haskell infix
operators work. Nor talk about the macros in the highly uniform syntax in
Lisp.</p>

<h2 id="last">Last</h2>

<p>At last, I want to say:</p>

<blockquote>
  <p>在在一個定理上辛苦工作了兩個小時後敲 <code>Qed.</code> 的那種爽快的成就感簡直無以言表有沒有！</p>
</blockquote>
]]></content>
  </entry>
  
</feed>
