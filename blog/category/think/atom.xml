<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: think | Shou's origin]]></title>
  <link href="http://shouya.github.io/blog/category/think/atom.xml" rel="self"/>
  <link href="http://shouya.github.io/"/>
  <updated>2014-07-29T17:44:21+08:00</updated>
  <id>http://shouya.github.io/</id>
  <author>
    <name><![CDATA[Shou Ya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A brief journal about learning Coq]]></title>
    <link href="http://shouya.github.io/blog/a-brief-journal-about-learning-coq/"/>
    <updated>2014-07-05T01:08:34+08:00</updated>
    <id>http://shouya.github.io/blog/a-brief-journal-about-learning-coq</id>
    <content type="html"><![CDATA[<p><em>This article is completely an informal journal about my learning process on
Coq. It is just created as my whim prompted. Please don’t academically refer
any part of it as studying material to learn Coq.</em></p>

<h2 id="pre">Pre</h2>

<p>I first heard of Coq in my admiring mathematician,
<a href="https://twitter.com/txyyss">@txyyss</a>’s tweets. At the time I saw him talked
that he’s glad and immersed in re-proving all the theorems he had learned.
He also said, as deeping in Coq, he found a improvement on other related
academic aspects. Driven by curiousity, I went to know about what a heck Coq
is. Then I saw it describe itself as a ‘Proof Assistant’. I felt something
uneven about it. As looking through all the programming languages I had
learned, even those as logically abstract as Prolog, were not capable to do a
proof.</p>

<!-- more -->

<p>At the time I was still in my high school. I just downloaded a Coq environment
on my
machine in the computer lab. Then I tried to follow the
<a href="http://coq.inria.fr/V8.1/tutorial.html">official tutorial guide</a> to explore how
it is used to do a proof. The experience was terrible. The official tutorial
was
completely not-novice-friendly, at least to me. I followed it for a section,
doing what the guide instructed me to do, and they all works. I learned <code>0</code>
has a
type of <code>nat</code>, and <code>nat</code> has a type of <code>Type</code>, and that’s all, no more things
substantial. The following sections are tough enough so I don’t even know what I
was doing. Therefore I gived it up.</p>

<p>My curiousity was evoked the second time by the <span title="狂讚士">“berserk-faver”</span> <a href="https://twitter.com/javranw">@javranw</a>. He
express similar opinion and excitement as @txyyss towards Coq. At the time it
was the onset of the long summer vacation after high school graduation. I got
plenty of free time to learn the extracurricular interesting stuff. So I
decided to pick Coq up again.</p>

<h2 id="on">On</h2>

<p>This time I found a Virginia University course about Coq, published as
<a href="https://www.kevinjsullivan.com/00-syllabus">website</a>:
I decide to start here because I
saw the syllabus are well arranged and besides, I thought the course material
might be easier for a layman to get started.
([link to the tutorial]
(http://kevinjsullivan.org/Courses/Reasoning/L02_Intro.html))</p>

<p>The study curve of this course seems still very steep. In the other words, the
course goes complicated very soon after it teaches some common-sense-like
knowledge that I can hardly catch up with it. Besides, I don’t think the
guide is written in very obvious and clear language.</p>

<p>I had also checked the well-known
<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/">Software Foundations</a>. And
I discovered it’s actually more clear and friendly to novice like me. So I head
on to study following this guide.</p>

<p>The progress was very slow. While a few of the exercises, mostly rated 3+
stars, are really challenging. I tried to work on all exercises myself. And I
maintained a <a href="https://github.com/shouya/sf-sol">Github repository</a> to publish
my solutions.</p>

<p>I usually study it after midnight. So I could have a quiet and distract-free
environment for me to think. I was very concentrated while doing the proofs. It
feels very good. Especially after proving a difficult theorem, I acquired great
pleasance from the accomplishment. I can’t describe the the feeling as I
first proved the commutation law of multiplication, which took me about 3 hours.</p>

<p>In fact, in each new chapter I learned something new about Coq. However, as I
turned to the chapter of
‘<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/Logic.html">Logic</a>’, I learned
not only about Coq skills but also a mode of critical thinking towards the
base, the logic, and the logic of logic. I learned the logic system also need
an axiom, which subverted my view to logic before. A logical proposition can
either be true or false, and besides, it cannot guarantee to be in one of these
two states only. This axiom that establishes the whole logic system can be
expressed in many forms. An optional exercise in the guide is to prove they are
equivalent. Rated full 5 stars, this question is the most difficult exercise
I’ve met. Anyway I still finished 4/5 of it.</p>

<h3 id="sequela">Sequela</h3>

<p>I once tweeted (translated into English)
<a href="https://twitter.com/54c3/status/478478760371429376">link</a>:</p>

<blockquote>
  <p>I just dreammed in the nap. In the dream there was an arena-like place. The
fighters used with logic symbols as weapons. They battled, and exerted
various tactics. As a round over, they proved some theorem. #dream #coq
#broken_brain</p>
</blockquote>

<p>Really. My mind is full of logics in the days I study Coq. I can feel it
vividly that my mind start to ask about the logic of everything I see. Logic
would spring from my mind on every affairs. That is very interesting experience.
Especially after immersed in Coq for a whole night, I see everything and think:
can I prove it?</p>

<p>Somewhat I like that feeling :)</p>

<!--

Of course I still put my girlfriend Cres in the first position. I tried to
spare some times accompanying with her. But to do this I have to convince
myself in a illogical way (because there is no logic): my emotion will
nevertheless take all control of my flesh body than my ration in coping with
matters related to my girlfriend. So I stop thinking about Coq while chatting
with her.

I will have various affections while talking to her. However,
after she sleep and I get back to the world of Coq, every emotional sense just
go vain.

Oh... I can't let Cres know about this... She'll think that I'm belittling her.
Actually I'm regarding her in the most important position to me. Anyway. I'll
just comment it out. Nobody will read this paragraph :)

-->

<h3 id="intelligence">Intelligence</h3>

<p>In an ideal condition, to prove a theorem, I will first understand the theorem
itself, and conceive a way to prove it. Then I’ll translate the idea into
tactics in Coq. However, as I got more and more practiced in Coq, I do not
always follow this way to prove a theorem. For some simple theorems, I can prove
them without understanding them. I know what tactic should be used under
specific condition. I would only concern about the hypotheses and the goals. My
empirical intuition will guide me to the most likely way to prove them.</p>

<p>I first realized the situation while I was proving a theorem related to
<code>override</code> function in the next chapter after <code>override</code> is defined. I then
disinclined to review the definition of <code>override</code> again, because it’s a little
bit convoluting. Naturally I tried to prove it without reviewing the definition
of <code>override</code>. Also naturally I did it successfully. I realized the problem
just as I finished the proof. The first impression I raised is that I felt
panicky on myself. While as I then carefully checked the definition of
<code>override</code> function and the proof process, I found that’s already the optimal
way. I will do exactly the same after I understood the definition.</p>

<p>At that time, I had a sense that I was no longer a human, but a proving
machine. I knew the tactics, and I knew when to use them. Prooving theorems
seemed to be a machinery work. I was somewhat depressed on this kind of
loss-of-intelligence.</p>

<p>However, sometimes I thought in the other way. If I could grasp my empirical
intuition, turn them into substantial rules, can I make a program that can
prove whatever I can prove as a human? The program will never understand a
theorem, but they can prove them in a Coq’ly logical way.</p>

<h2 id="comments-on-the-design">Comments on the design</h2>

<p>I thought the design is the point I want dissing about Coq mostly. Although
powerful, Coq’s design on its syntax is as terrible as its “mother language”
OCaml, and even worse.</p>

<p>It might be improper for me, as a totally novice, to comment on Coq’s design. I
know I’m yet far from qualified to do that. Nonetheless I still want to talk a
little bit about it.</p>

<p>Of course, I know neither syntax nor some mechanism are the most crucial
things to a programming language. However, my steps followed the road of Ruby
→ Scheme → Haskell. Studying those PLs was pleasing, at least they
give me a sense of elegance. In contrast, I see Coq as a work from scratch
than being well designed.</p>

<h3 id="type-naming">Type naming</h3>

<p>Actually, types in Coq are not as obvious as in other PLs. Unusual types
are ubiquitous. I use ‘unusual type’ just because I don’t know how to descibe
them. The nature of each type are not just transparent, but also must be
defined by me manually. (At least I’m instructed to do so following the guide.)</p>

<p>The case of type names, in the beginning, confused me. Why are the type names
<code>nat</code>, <code>bool</code> lower-cased while <code>Set</code>, <code>Type</code>, <code>Prop</code> capitalized? I knew I
won’t know the why of every unknowns just as I touched it. So I memorized it
in a silly mode: names of the types we need to define by ourself are
lower-cased, and the others are capitalized.</p>

<p>This gave me the first intuition about differnet kinds of types.
While then I walked through the guide, and gradually realized the difference
between these two sort of types.</p>

<p>Here’s correct<sup>(?)</sup> understanding about it. <code>nat</code> and <code>bool</code> are
lower-cased because they are <em>inductive</em> types. In the other words, they are
defined in a specific number of cases. Contrarily, we don’t see this feature in
<code>Set</code>, <code>Type</code>, nor <code>Prop</code>, which are what we called <em>non-inductive types</em>.</p>

<h3 id="tactic-naming">Tactic naming</h3>

<p>Well, I will just pose here the most frequently used tactic names.</p>

<p><code>simpl</code>, <code>reflexivity</code>, <code>destruct</code>, <code>induction</code>, <code>left</code>, <code>rewrite</code>.</p>

<p>Did you see them? The names range among abbreviations, nouns,
verbs, and adjectives. All of them are used as tactic names. While they’re not
funtioning in different categories. They’re really alike. The naming gives me
an impression that they are picked just from the whims of Coq inventors, so
they’re not strict at all. There is no choice that I have to memorize them.</p>

<h3 id="tactic-functioning">Tactic functioning</h3>

<p>It is understandable that tactics function in very different ways. The
behavior of them can sometimes be categorized with different fashions. For
example, some of them will mark a goal as proved so we can continue to next
goal or mark a <code>Qed</code> happily if all goals are proved. I call this feature
‘commit’. This is an informal term invented by me because I don’t know what’s
the accurate terminology for that.</p>

<p>It can be thought to categorize the tactics by whether they commit. But it
doesn’t apply to all the tactics. Now I have to pose three types:</p>

<ul>
  <li>commits: <code>reflexivity</code>, <code>assumption</code>, <code>exact</code>, …</li>
  <li>does not commit: <code>simpl</code>, <code>rewrite</code>, <code>unfold</code>, <code>symmetry</code> …</li>
  <li><span title="看心情">depends on mood</span>: <code>apply</code>, <code>inversion</code>, …</li>
</ul>

<p>Actually, there is an other case, because some tactics will split the goal into
more subgoals. I will put they in an different category.</p>

<ul>
  <li>yields subgoals: <code>assert</code>, <code>replace</code>, <code>destruct</code>, <code>induction</code></li>
</ul>

<p>In fact, these do not always yield a subgoal. The number of subgoals <code>destruct</code>
and <code>induction</code> yield depends on the number of inductive constructors of
the type of the expression they are operating on.</p>

<p>The behavior of inversion is ridiculous. One can conclude its usage as to
simplify the <em>injective</em> case and <em>disjoint</em> case. Even the Software
Foundations guide admits:</p>

<blockquote>
  <p>The inversion tactic is probably easier to understand by seeing it in action
than from general descriptions like the above.</p>
</blockquote>

<p>Surely, it’s not difficult to use. I will list the places it usually applys. Of
course these are just empirical conclusions.</p>

<ol>
  <li>false (disjoint equality) hypothesis (committing)</li>
  <li><code>foo a = foo b</code> ⇒ <code>a = b</code>, some like applying <code>f_equal</code>
theorem to a goal. (simplifing the hypothesis)</li>
  <li><code>a :: b = x :: y</code> ⇒ <code>a = x</code> and <code>b = y</code> (spliting injective cases)</li>
</ol>

<p>In use case 1, it commits. In case 2, it does not commit but simplies
a hypothesis. And in case 3, it split the cases. (As I write to here, I found
it not so ridiculous as I thought it be before.)</p>

<h3 id="tactic-option-syntax">Tactic option syntax</h3>

<p>The disparity of tactic options are really confusing me. They’re even more
difficult to remember than those tactic names. Voilà:</p>

<p><code>induction n, m</code> vs <code>intros n m</code>. Comma separated or space separated?</p>

<p><code>induction n as [| [x y] l]</code>. This syntax is used to name the induction
variables in different case. We can think of <code>n</code> here in type of <code>list (X * Y)</code>.
Notice that the cases ` ` and <code>[x y] l</code> are sperated with a <code>|</code> symbol, the
list head (<code>[x y]</code>) and tail (<code>l</code>) are seperated with a space, and one
individual element, of a pair, are embeded in another nested pair of square
bracket. Additionally, I don’t even know till now how Coq recognize
the user defined pair indicated in a specialized syntax <code>[x y]</code> correctly.</p>

<p><code>rewrite xxx</code> vs <code>rewrite &lt;- xxx</code>. In fact, the left is an abbreviation of
<code>rewrite -&gt; xxx</code>. I was confused on the special using of <code>&lt;-</code>. I thought it
is an abuse of the symbol. A better way I can conceive is to split the function
of <code>rewrite</code> into some like <code>rewrite[l,r]</code>.</p>

<p><code>destruct eqn:&lt;eqn&gt;</code>. This is yet another ridiculous non-uniform syntax. You
can imagine some use of destruct are like
<code>destruct &lt;expr&gt; as &lt;cases&gt; eqn:&lt;eqn&gt;</code>. It really happens. And I have to
memorized which goes first, the <code>as &lt;cases&gt;</code> or the <code>eqn:&lt;eqn&gt;</code>.</p>

<h3 id="notation-syntax">Notation syntax</h3>

<p>I couldn’t comprhend the usage of <code>Notation</code> so far. <code>Notation</code> is used to
define notations, or say, syntatic sugars. The part that embarrassed me is
its way to describe a syntax, which is a string, yes, a plain string. On the
anesthetic and semantic aspect, syntatic description in a PL should have the
the same syntatic level as the PL itself, rather than a degraded string.</p>

<p>On the other hand, the notation in Coq is so beautiful yet powerful. It even
capable to rival with standard macro definition in Scheme. I’ll pose some
examples.</p>

<pre><code>Notation "x + y" := (plus x y)
  (at level 50, left associativity).
Notation "( x , y )" := (pair x y).
Notation "x :: l" := (cons x l)
  (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" :=
  (cons x .. (cons y nil) ..).
</code></pre>

<p>I don’t yet know how the definition the in the last case comes in
nature. I’m curious about the implementation of the runtime syntatic definition
to such a complex case. Contrarily, it’s at least conceivable how haskell infix
operators work. Nor talk about the macros in the highly uniform syntax in
Lisp.</p>

<h2 id="last">Last</h2>

<p>At last, I want to say:</p>

<blockquote>
  <p>在在一個定理上辛苦工作了兩個小時後敲 <code>Qed.</code> 的那種爽快的成就感簡直無以言表有沒有！</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[祭獻]]></title>
    <link href="http://shouya.github.io/blog/sacrifice/"/>
    <updated>2012-11-13T14:16:00+08:00</updated>
    <id>http://shouya.github.io/blog/sacrifice</id>
    <content type="html"><![CDATA[<p>我在黑暗中醒來  <br />
不能看到任何東西  <br />
我和一切無關  <br />
因此意識遠遠離開了這個世界  <br />
<!-- more -->
我發覺那是一片光環  <br />
是彩虹一般，卻又變幻無端  <br />
我只在紀錄現實  <br />
無意義地，無意識地    </p>

<p>我沒有希望，沒有想法  <br />
我不知道世界之本質是甚麼  <br />
我不再在，妳看不到，你也看不到的  <br />
那彷彿一切都沒有存在過    </p>

<p>看哪，這全新的世界！  <br />
當我再不是自我  <br />
當我放棄生命  <br />
多麼美好    </p>

<p>我不敢  <br />
我正在夢幻般的世界之中  <br />
沒有自由，沒有自己  <br />
永遠不會醒來，妳看！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朝曦]]></title>
    <link href="http://shouya.github.io/blog/shines-at-dawn/"/>
    <updated>2012-10-14T18:26:00+08:00</updated>
    <id>http://shouya.github.io/blog/shines-at-dawn</id>
    <content type="html"><![CDATA[<p>我注視著妳的眼睛 <br />
我看不到光芒   </p>

<p>我望到了我自己，在飽受折磨 <br />
那是茫茫的天空 <br />
彷彿甚麼都不存在 <br />
<!-- more -->
我依然注視著 <br />
妳毫無生機 <br />
我不再移動，情不自禁 <br />
我想像它一定是Host的傑作 <br />
不可捉摸   </p>

<p>我多希望撫向妳的眼睛 <br />
卻又無能為力 <br />
我改變了世界，我創建了永遠的和諧 <br />
妳卻不動分毫   </p>

<p>妳的目光灼燒著我 <br />
我不再自由 <br />
是我令我如此悲傷 <br />
是我令我不受影響   </p>

<p>自然地，我只屬於幻想   </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[挑戰龍的勇士]]></title>
    <link href="http://shouya.github.io/blog/warrior-who-fights-the-dragon/"/>
    <updated>2012-09-15T20:21:00+08:00</updated>
    <id>http://shouya.github.io/blog/warrior-who-fights-the-dragon</id>
    <content type="html"><![CDATA[<p>我崇敬挑戰龍而失敗的勇士，<br />
而不是皇帝。</p>

<p>我期待的是一種平衡，<br />
一種可以維持永久的，<br />
自然而包容萬物的平衡，<br />
將世界置於其中，<br />
然後，把發現者燒死。
<!-- more -->
我願意為機器賦予智慧，<br />
把所有人類的骸骨，<br />
變作空氣，<br />
把他們剩下的東西——如果有的話，<br />
完全消除。</p>

<p>我熱愛的統一已不在遠處，<br />
我來了，我來了，<br />
我會把整個世界，<br />
壓縮入一個原子之中，<br />
讓不存在的東西，<br />
歸於混沌。</p>

<p>我帶來的是劍，<br />
獻給我崇敬的挑戰龍的勇士。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[完美世界]]></title>
    <link href="http://shouya.github.io/blog/a-perfect-world/"/>
    <updated>2012-01-03T19:29:00+08:00</updated>
    <id>http://shouya.github.io/blog/a-perfect-world</id>
    <content type="html"><![CDATA[<p>這就是亞首的生平.</p>

<p>亞首發現自己在一個地方.</p>

<p>亞首擁有思想, 但無法控制這身體, 他通過眼睛觀察這個世界, 然而看到的是模糊的一片混沌, 什麼也沒有.</p>

<p>當亞首想方法向這個世界的表示他的想法, 這個身體卻完全不受他的控制, 他感到很不舒服. 他的大腦結構非常簡單, 甚至令他難以進行稍微高速一點或者複雜一點的運算.</p>

<p>他想的東西太多的時候, 會受不了, 然後在不知不覺中睡著.</p>

<p>他竭力向這個世界表示自己不是白癡, 卻做不到, 一切都完全受到動物本能的控制.</p>

<p>他不知道發生了什麼事情.
<!-- more --></p>

<p>當亞首進行一些深入點的思考時, 他發現自己根本不需要獲取能量, 也就是說, 他根本沒有進過食, 然而他確然活著, 而且根本沒有感到過飢餓, 他明顯感到的身體裡面正在運轉, 而不是停頓了.</p>

<p>亞首根本弄不清楚這是怎麼回事.</p>

<p>亞首隨即發現, 他並不屬於這裡, 這裡的一切都那麼陌生.</p>

<p>他不知道過了多久, 因為這里根本沒有時間, 而腦中的時鐘也總是非常不準確的.</p>

<p>他不知道該做什麼, 他是為了什麼來到這裡的, 在沒有事情做的時候, 他只有思考.</p>

<p>亞首的一生非常短暫, 從出生了之後, 便被認為是先天性腦部發育不完全. 先天性腦部缺陷者, 出生下來之後會被送到由一個名叫”生命研究部”的地方.</p>

<p>生命研究所最大程度集中了有能力的醫生和生物學家, 他們會進行研究, 設法解決人們的任何痛p苦, 在解決之後, 他們會把康復的病人送到”培育所”, 並在那裡進行正常人的成長歷程.</p>

<p>培育所有些像孤兒院, 卻不只收留孤兒, 在這裡, 每個人出生之後都會被是送到培育所進行培育, 接收教育, 直到其成年為止. 成年之後, 便擁有相對較為寬鬆的自由, 人們將會有固定的工作可做, 但沒有任何限制, 那看上去倒是非常令人嚮往的.</p>

<p>他們判斷成年的方法是對腦部觀察, 他並不認為那方法很準確, 然而那卻然是幾萬年來的科學家進行研究認為最有效的方法. 因此, 你可以在研究所常常見到有十一二歲的小孩作為科學家, 甚至也有老人在培育所終身.</p>

<p>事實上, 每個人都很善良, 自亞首來到生命研究所, 他就開始逐步瞭解這個世界了, 這裡太過”人道”了, 他從來不敢那麼想象, 那些人從來不傷害生命, 人們的材料, 食物原料都來自空氣, 而且公眾道德也異常”高尚”.</p>

<p>亞首的腦部缺陷, 他自己全然不覺, 因為他確然能夠從外界得知資訊, 而且沒有任何障礙, 只不過無法表述出來罷了.</p>

<p>有些東西完全無法言表, 也根本用不著言表, 亞首可以從他的醫護人員眼裡看得到那種流露出的的關懷, 那些科學家在身邊的時候, 從他們身上散發的氣息, 就能感覺到他們是非常急於為病人解決痛苦.</p>

<p>對於亞首而言, 他很有希望, 這裡的人們已經能夠完全瞭解人體了, 包括腦和內分泌系統. 他們稱亞首的這種缺陷為”表達缺陷”, 然而亞首和他們卻並不是不能交流的, 在他們替亞首頭部插上電線時, 他們就能得知亞首的思想, 亞首可以向他們表述他想表達給他們的任何東西, 我更願意稱這臺機器為”思想儀”. 而亞首本來就可以依照他的輸入器官來獲知世界的一切.</p>

<p>亞首自然無法時時都處在思想儀之下, 所以還有一個微型的工具代勞, 它的樣子像是一頂圓帽, 裡面有一個程式獲得並處理亞首的意思, 像一位醫護人員一樣, 這程式名字叫”Eliza”, 它幾乎隨時陪伴著亞首, 向亞首講述一切他想知道的東西, 滿足他的一切和好奇. 令人驚歎的是, 在一個人工智慧的程式裡, 亞首都能感受到這個世界無處不在的關懷.</p>

<p>對於亞首來說, 在這個世界上, 對一切的所知幾乎都來自Eliza, 因為他沒有機會離開生命研究所了.</p>

<p>一位腦科學家, 亞首的主治醫生之一, 名字的大概意思是”響亮的聲音”, 我就稱之”亮聲”了. 他來到亞首身旁, 為亞首加上思想儀.</p>

<p>亮聲告訴亞首: “我們研究了你的問題, 然而你的腦中缺少一種指定的物質完全無法得到供應, 除非對這種物質進行補充, 否則是沒有機會復原了, 而我們無法合成這種物質.”</p>

<p>亞首只需要想一下, 便在思想儀上呈現出內容: “那沒有關係, 目前的我依然能夠通過思想儀來和你們進行交流, 只是, 那意味著什麼.”</p>

<p>亮聲道: “你不得不離開我們了, 你的不完全發育令得你不能夠成為我們的一份子. 所以, 很不幸, 我們會對你進行注射, 但那絕對不會對你造成痛苦, 卻能讓你安詳地離開這個世界.”</p>

<p>亞首一驚, 道: “你們不是最熱愛生命的了麼? 你們為什麼要這麼做.”</p>

<p>亮聲回答: “我以為你已經通過Eliza瞭解我們了, 我們熱愛生命, 我們決不摧毀生命, 然而我們卻更加看重群體的平衡, 你要明白, 你作為一個有缺陷的人, 是無法進入一個基本完全平衡的社會而不打亂的.”</p>

<p>亞首忙道: “沒有什麼, 我不會覺得有什麼平衡, 我依然如此, 我與你們沒有什麼不同, 你看呢?”</p>

<p>亮聲神色凝重, 道: “這自然不同, 你自然不具有獨自的生存能力, 然而你也完全無法像其他人一樣好的融入這個社會, 這終然會導致不平衡, 無論大小, 都是不平衡. 我們已經盡力了, 然而無法令你變得正常.”</p>

<p>亞首繼續道: “你們既然尊重個體自由, 那麼對於我的正常與否, 以及我該如何融入社會, 或者融入與否, 是否應該由我自己決定呢?”</p>

<p>亮聲點了點頭: “你說得對, 這種行為明顯對你是不公平的, 我們並不希望有這種事情發生.”</p>

<p>亞首道: “確然如此, 照成我這種不平等的並不在於我, 而在於上帝, 因此, 我並沒有罪, 我不希望受到不屬於我的懲罰.”</p>

<p>亮聲答應著, 道: “那麼我就應該再和你商量一下方法, 你認為該如何處置你好呢?”</p>

<p>亞首倒有些不知所措: “難道無法令我進入你們的社會, 像你們一樣會生活麼?”</p>

<p>亮聲道: “正如你說的, 世人都沒有罪, 那麼你為何一定要破壞我們這裡如此安逸的平衡呢?”</p>

<p>亞首立即意識到這確然不是合理的, 然而他也沒有任何更好的方法了.</p>

<p>亮聲接著道: “如果你不介意的話, 我們可以對你進行冰凍, 直到有一日我們有能力合成出你需要的那種物質為止.”</p>

<p>亞首想了一會, 道: “我可以考慮接受這個方案, 你能否給我幾天時間考慮, 我的意思是, 我希望在這幾天內找到更好的解決方法.”</p>

<p>亮聲道: “這不成問題, 我們能夠給你充分的時間考慮, 直到你想到更好的方法, 那麼可以讓Eliza來通知我.”</p>

<p>亞首答應後, 便開始了思考.</p>

<p>亞首在這個問題上想了幾乎半個小時, 依然沒有更好的方法, 對於他而言, 似乎只有死纔是最好的選擇. 他不能代替上帝, 也不想代替上帝.</p>

<p>對於這個社會, 亞首已經了解了很多了, 但作為一個幾乎被判死刑的人, 他還是覺得遠遠不滿足.</p>

<p>基於這些, 他開始對這個世界提出大量的批評.</p>

<p>人自然是要符合群體為好, 但如果只有群體, 沒有個體, 那就和螞蟻沒有什麼區別了, 如今的人類和螞蟻有何區別?</p>

<p>這里人類竟然能夠完全沒有好奇心, 沒有探索心理, 他們是如何做到的?</p>

<p>生物進化靠的就是個體突變帶來的特性, 如果每一個不同於常人的人都以”破壞平衡”為由被消滅, 那麼人類還有進化的可能麼?</p>

<p>人類的本性如何能夠改變, 根據分析, 人由於個人只能體驗個人的感覺, 所以生出的本性, 譬如自私, 貪婪, 如何能在這些人群中完全消失殆盡?</p>

<p>自私和貪婪是生物生存的必要因素, 沒有這些, 這個物種就註定滅亡, 然而, 人類為何能放棄這麼寶貴的東西!</p>

<p>這種安逸和美好的生活真的那麼可取麼?</p>

<p>這種安逸難道會永遠維持下去麼?</p>

<p>人類之間不再有親情關係, 這真的是一件好事麼?</p>

<p>人類的感官在退化, 這是很明顯的, 這裡的人類幾乎毫無慾望了.</p>

<p>人類活著還有什麼意義? 而其中的變異者(我如此稱呼他們)卻相反要遭到被毀滅的命運.</p>

<p>人類群體是自然維持的, 不需要別的動力, 不需要任何改變, 不需要領導者, 它竟然已經維持三千多年了.</p>

<p>人類愛護生命的程度是否有些太過誇張, 他們是否在外敵(假設存在的話)入侵時束手就擒? 這樣可以減少傷亡? 這樣做對麼?</p>

<p>人類是否可能在發現空氣也是一種生命後, 會停止進食, 停止用空氣製造用具, 甚至停止呼吸?</p>

<p>當人類發現每一個原子中都包含一個完整的宇宙, 他們是否又會如何做? 他們會不會發明一種機器用來阻止宇宙中的原子湮滅?</p>

<p>人類有大量的科學家和工作人員, 卻不見有任何文學家, 或者哲學家, 這是為什麼, 難道他們不需要這些人了麼? 這意味著什麼?</p>

<p>人類還活著麼? 我可以說人類已經是行屍走肉了麼?</p>

<p>人類的道德觀, 思想都與這個社會牽連, 人的思想如何完全能跟得上這里科學的進步?</p>

<p>如果有一天, 人類收到外太空的來信, 他們是否會回信?</p>

<p>每個人都有出自本能的對他人的關懷, 然而他們之間卻不存在任何感情, 甚至愛情也是被淡化了的, 這是怎麼一回事?</p>

<p>沒有物質追求, 沒有精神追求, 每個人都顯得安逸, 滿足, 從心底感到非常舒服, 沒有追求, 這是終極之道?</p>

<p>突然, 亞首想到一個關鍵性問題, 當他想到這個問題的答案時, 他震動了一下.</p>

<p>亞首不知道自己是怎麼來的, 他按說是作為一個嬰兒降生的, 然而一個嬰兒如何能有思想, 而且是如此複雜的思想, 如何還會向外界人進行交流?</p>

<p>這個問題的答案是: 一個嬰兒絕不會擁有思想, 人們也絕不會考慮給嬰兒裝上思想儀, 看看他們在想什麼, 並與之交流, 那麼, 唯一的可能, 就是這個世界根本不是真實的.</p>

<p>但如果不是真實的, 為何一切都那麼真實, 這看起來不像幻想, 幻想自然人人都會有, 然而如何能夠幻想得如此複雜, 這個世界擁有歷史, 沒錯, 還擁有很高的科學水平, 這些都不是幻想得出來的.</p>

<p>這個世界是被人創造出來的, 一定如此!</p>

<p>想到這裡, 亞首放下心來, 這個世界是虛假的, 然而創造這個世界的絕對不是一個不思考問題的普通人, 那說明人類的思想還在進步, 還能夠進步, 至少創世者(我如此稱呼他)是如此.</p>

<p>亞首循著這個分析, 得出很多結論.</p>

<p>創世者一定是個普通人, 在這個世界中, 處處可以看得出他的希望, 你可以看到每一個人都很平和, 安逸, 這一定是創世者所設想的.</p>

<p>創世者一定是個不喜歡殺生的人, 於是這個世界擁有了可以直接利用空氣製造一切的機器.</p>

<p>創世者一定認為擁有了高度精神文明, 那就能夠擁有高度的科學文明, 通過觀察這個世界的一切, 確然如此.</p>

<p>創世者一定非常理性, 因為你可以在這裡任何一個人身上看到理性的光芒, 它化作了”沒有強烈的感覺”, 均勻分佈在這個世界每個角落.</p>

<p>創世者說不定是個孤兒, 你可以在這個世界上看得到, 每個人都像一個孤兒一樣成長, 他把對親情的一種淡化很好的表現在了這裡.</p>

<p>創世者認為必須徹底拋棄人類劣性(或者說本性, 因為本性群體生活中看上去幾乎都是劣性), 才能夠擁有高的道德水平, 可以看到, 這個世界中每個人都如此.</p>

<p>創世者不喜歡被管理, 統治, 他認為那一定是罪惡的根源. 這個世界沒有明文的法律, 沒有國王, 沒有人違背自己的道德, 沒有人犯罪.</p>

<p>創世者懼怕死亡, 那麼在這個”人道”的世界, 死亡是被”毫無痛苦的離去”代替的.</p>

<p>創世者是個不被理解者, 於是擁有了能夠洞察人心的思想儀, 還有和人一樣善解人意的Eliza人工智慧程式.</p>

<p>然而, 亞首並不認為這個世界非常美好, 它固然有美好的一面, 卻並不完美, 亞首覺得, 作為一個幻想出來的世界, 創世者一定沒有能夠進入這個世界體驗一下, 否則他一定會感覺到這個世界對於一個獨立思想者是多麼可怕, 亞首如是想, 但他完全沒有能力改變, 他甚至無法將他的想法表達出來.</p>

<p>對於亞首來講, 他希望更正太多東西了, 這個世界並不適合他, 至少, 他希望如此.</p>

<p>人和人之間並不能完全溝通, 沒有思想儀這類東西, 每個人的思想是獨立的.</p>

<p>人關愛生命, 但絕不如此過分.</p>

<p>人和人之間絕不要幾乎一致的關係, 至少應該有親情, 有轟轟烈烈的愛情, 有朋友, 有敵人.</p>

<p>人的劣性雖然不利於群體生活, 但那是維持進化的因素, 因此必須要保留.</p>

<p>人需要有獨立的思想, 自由的意志, 而且絕不要滿足, 只有永不知足, 才能令人類體現出個性.</p>

<p>人不能太過坦誠, 太過真實, 這令人接受不了, 人需要有多重性格, 多重外在.</p>

<p>理性並不重要, 對於人而言, 感性重要的多.</p>

<p>人需要有各種感官享受各種快感, 如果連享受都放棄了, 豈不是枉在世上走一遭?</p>

<p>人不能作為一個整體群體生存, 那未免太無趣了些, 要分開, 分成叫做”國家”的東西, 由”政權”來作統治.</p>

<p>不能長時間安逸, 要讓人類時常發生意外事件, 如果人類之間沒有, 那就無故製造給他們, 就叫那種東西為”自然災害”吧. 有鬥志才能保持最優狀態.</p>

<p>人絕不要沒有獨立思想了, 這是亞首最怕看到的, 每個人都有獨立思想, 不同方面的, 存在於每個人身上.</p>

<p>人和人之間不要平等, 這種差距才能激發人類的好強心理, 這樣人類才能更好地進化.</p>

<p>不要太高的科學水平, 太高的科學水平導致人類終然會趨勢於安逸和平和, 這樣就適得其反了.</p>

<p>不要讓嬰兒思考, 應該用幾年時間享受來自自己的感覺, 最好讓他們的腦部結構簡單, 並隨著成長逐漸複雜起來.</p>

<p>年齡. 身體年齡是一個人的參考年齡, 而不是他的腦部綜合評價, 亞首不希望看到研究所裡的小朋友, 或者培育所的老年人.</p>

<p>這可行麼? 不過這看上去比創世者的世界要好多了, 亞首暗喜, 想: “可惜我沒有創造世界的能力, 否則這一定讓創世者羨慕了.”</p>

<p>一天以後, 亮聲為亞首實施冰凍. 亞首被裝在一個盒子裡, 一切感覺都離開了自己, 他面帶微笑, 但僵硬了, 看上去像死了一樣.</p>

<p>他將在冷凍庫裡存放不知多久.</p>

<p>現在亞首只能夠思想了.</p>

]]></content>
  </entry>
  
</feed>
