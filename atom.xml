<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Shou's origin]]></title>
  <link href="http://shouya.github.io/atom.xml" rel="self"/>
  <link href="http://shouya.github.io/"/>
  <updated>2016-10-04T23:02:32+08:00</updated>
  <id>http://shouya.github.io/</id>
  <author>
    <name><![CDATA[Shou Ya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[服務器被入侵手記]]></title>
    <link href="http://shouya.github.io/blog/my-vps-was-hacked/"/>
    <updated>2016-10-04T22:43:45+08:00</updated>
    <id>http://shouya.github.io/blog/my-vps-was-hacked</id>
    <content type="html"><![CDATA[<h2 id="section">背景與起因</h2>

<p>我想趁放假幾天玩一下 Docker 集群，順便跑個 shipyard 通過網頁管理自己 VPS 上運行的服務。</p>

<p>因為是完全的新手，在這之前甚至連 Swarm 是什麼都不知道，所以完全按照 shipyard 官方文檔說的配置來都沒成功。</p>

<p>最後發現是很愚蠢的錯誤，只是因為其中一步要使用一個服務把 <code>/var/run/docker.sock</code> 代理到 TCP/2375 端口上，而 swarm-agent 不知為何不能使用 <code>127.0.0.1:2375</code> 連接到本機，一定要用公網兜一圈才能找到本機的控制，而我忘記在防火牆上打開此特例。開了此特例，故問題解決。</p>

<p>因為以前一直是在本機跑 Docker，也未暴露任何端口，故沒有啟用任何加密措施。事實上 <a href="http://shipyard-project.com/docs/deploy/automated/">shipyard 的手冊</a> 已經提醒過開放此端口相當於把 Docker 控制權給出去，應該設置好 Docker 通訊用 Socket 的 TLS 加密再玩，但我忽視了這個警告。</p>

<p>shipyard 終於成功跑起來了，我玩了一會，得意之至，忘記了上面的警告和自己親手暴露的端口。接著我就折騰 Jenkins 之類的去了，玩得不亦樂乎。</p>

<!-- more -->

<h2 id="section-1">發現入侵</h2>

<p>次日我繼續調戲 Docker，剛跑起 <code>kevana/ui-for-docker</code>，突然發現多了兩個正在運行的 Containers：</p>

<p><img src="http://i.imgur.com/1a2exdg.png" alt="ui-for-docker 截圖" /></p>

<p>（當時這兩個 Containers 還在運行）</p>

<p>看到「exploit.sh」我就知道完了，第一時間 kill 掉了 <code>romantic_snyder</code> 和 <code>thirsty_kare</code> 這兩個 Containers。</p>

<p>當務之急是立刻把 shipyard/swarm/etcd/docker-proxy 的服務暫時全停掉，還有把前一天給 2375 端口開的防火牆特例砍掉。</p>

<h2 id="section-2">研究入侵</h2>

<p>根據 Image 名字搜索了一下，<a href="https://hub.docker.com/r/chrisfosterelli/rootplease/">chrisfosterelli/rootplease</a> 是一個很 naïve 的 exploit 程序，原理就是通過 <code>docker run -v /:/hostOS</code> 來跑這個鏡像加上 <code>chroot</code> 來獲得 root 權限。入侵者應該在裡面執行了些什麼命令。</p>

<p>而另一個 Container 跑了個很單純的 CentOS 加上 Bash，想必也是跑了些命令。</p>

<p>害怕之餘，必須先弄清楚黑客做了什麼，首先是通過 <code>docker inspect thirsty_kare</code> (這個是 CentOS 對應的 Container) 和 <code>docker inspect romantic_snyder</code> (這個是 <code>chrisfosterelli/rootplease</code> 對應的 Container) 看看這兩個 Containers 的信息。</p>

<p>具體信息太長，所以不貼上來，值得關注的一點：</p>

<ul>
  <li><code>chrisfosterelli/rootplease</code> 啟動時間是 <code>2016-10-02T14:04:15.86229242Z</code>，發生在 46 小時前</li>
  <li>CentOS 啟動時間是 <code>2016-10-03T14:44:35.271194859Z</code>，發生在 21 小時前</li>
</ul>

<p>這意味著這很可能是兩次入侵，而我昨日忙於玩 Jenkins，竟然這麼久了才發現。</p>

<p>進一步看這兩個 Containers 的 host bind 信息：</p>

<ul>
  <li><code>chrisfosterelli/rootplease</code> 是用的 <code>-v /:/hostOS</code>，也就意味著他拿到了 root shell</li>
  <li><code>CentOS</code> 只掛載了 <code>-v /root/.ssh:/mnt</code>，意味著他的目的是修改 <code>/root/.ssh/authorized_keys</code> 來拿到 root 帳戶的 ssh 登入的權限。但就算目的不是，破壞範圍也有限，畢竟 Docker 是個沙盒</li>
</ul>

<p>然後我進入了兩個 Containers 文件系統鏡像（<a href="https://stackoverflow.com/questions/32750748/how-to-edit-files-in-stopped-not-starting-docker-container">不啟動 Container 查看文件系統鏡像</a>）：</p>

<ul>
  <li><code>chrisfosterelli/rootplease</code> 的 <code>/root/.bash_history</code> 其實是 Host 機器的 <code>/root/.bash_history</code>，內容都是我自己的命令歷史。謹慎起見，額外查看到 Container 的文件系統鏡像中的 <code>/root/.bash_history</code> 不存在</li>
  <li>CentOS 那個 Container 的 <code>/root/.bash_history</code> 也不存在</li>
</ul>

<p>兩種猜測：1) 入侵者抹掉了歷史紀錄；2) 黑客離開的時候這兩個 bash 還在運行，沒有退出 bash 之前 bash 不會把歷史寫入文件，而我將 Container kill 掉之後，就意味著當時還在的 bash 進程的內存也被丟掉了<s>，這段歷史也將永遠被埋沒。</s></p>

<p>兩種情況我都不可能知道他們做了什麼，只能通過各種痕跡推測。</p>

<pre><code># cat /root/.ssh/authorized_keys
root@ubuntu:~# cat .ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDRrvCaHsH8nZ6YrTsZaTFeKW3aPzUvlK+h+KT8rT4w6EGJgl8LVANHUsl5BF3RVGjFKFnBkX6jd6tWt+435h9vrEhxynoI69ljiiP9lD8GWgp0axmupqrcU3+OBiAmQ1OrOsMeNBdlw3GjAGPLI+ACd2WPPfKlWyQqDYrtzUPm5cz7HmI5Xo10KDcAS8gRJolH1AzBLfb8gPv8X9c9pKlpkUeST7j6MWLg3QQTShqbDB5j3IvL92KPhFmsOtJFd+efRyTiFhKsiQDY1h2er4gWcAn95GgLG6ci4D3d/kCoYRwIjRRrk5/4pRRq3wpp7/anI8qqJ6pPbdV9HvA/AEOp root@localhost.localdomain
</code></pre>

<p>看到黑客留下的自己的 SSH Key。隨手 <code>: &gt;/root/.ssh/authorized_keys</code> 把內容清空。</p>

<h2 id="section-3">被入侵後的安全檢測</h2>

<p>下一步就是看正在登入的 Sessions，看來是正常的：</p>

<pre><code>$ w
 13:06:55 up 108 days,  4:26,  6 users,  load average: 0.01, 0.03, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
shou     ttyS0                     18Jun16 108days  3.73s  2.98s [打碼]
shou     pts/1    tmux(5178).%0    28Sep16  6days  1.92s  1.42s [打碼]
shou     pts/2    tmux(5178).%1    28Sep16  5days  1:27m  1:27m [打碼]
shou     pts/3    tmux(5178).%2    28Sep16  5days  4.68s  4.68s -zsh
shou     pts/11   tmux(5178).%3    28Sep16  6days  0.67s  0.67s -zsh
shou     pts/14   [連入 IP 打碼]    11:16    1.00s  3.84s  0.00s sshd: shou [priv]
</code></pre>

<p>然後是登入紀錄，也沒有異常：</p>

<pre><code>$ last
shou     pts/14       [連入 IP 打碼]     Tue Oct  4 11:16    gone - no logout
shou     pts/4        [連入 IP 打碼]     Mon Oct  3 16:26 - 19:23  (02:57)
shou     pts/0        [連入 IP 打碼]     Mon Oct  3 10:45 - 13:07  (02:22)
shou     pts/0        [連入 IP 打碼]     Mon Oct  3 02:29 - 07:13  (04:44)
shou     pts/0        [連入 IP 打碼]     Sun Oct  2 05:32 - 20:00  (14:27)
[...]
</code></pre>

<p>登入日誌無異常，大概可以說明前面試圖設置 SSH root 後門的那位入侵者碰壁了。他是不是登入時認證出錯了呢？想起我在 SSH 裡用了增強安全性的配置，譬如改了默認端口，關了 PermitRootLogin，允許連接的用戶也是以白名單形式寫的。那麼有沒有認證錯誤信息呢？</p>

<pre><code>$ sudo less /var/log/auth.log（或者 sudo journalctl -u ssh）
[...]
</code></pre>

<p>內容很正常，沒有看到有人用 root 登入認證出錯的信息。</p>

<p>那位使用 CentOS + Bash 的入侵者看來是碰壁了，畢竟他沒有辦法訪問到 Host 機器的 <code>/etc/ssh/sshd_config</code> 不可能知道我做了哪些安全措施。然後我有防火牆，連去 TCP/22 的連接會被直接棄掉，所以沒有 SSH 登入紀錄當然不意外。</p>

<p>於是來研究第一位入侵者可能做了的事情。首先檢查 systemd 啟動項：</p>

<pre><code>$ systemctl list-unit-files | grep enabled
accounts-daemon.service                    enabled
cron.service                               enabled
deploy_daemon.service                      enabled
docker.service                             enabled
[...]
</code></pre>

<p>然後挨個查看這些啟動項的詳情，如果在最近啟動過的就要注意了。</p>

<pre><code>$ systemctl status accounts-daemon.service
$ systemctl status cron.service
$ [...]
</code></pre>

<p>所幸都沒問題。不通過 systemd 服務，要設置自動啟動程序，那就只能注入 <code>/etc/profile</code>，<code>/etc/{rc*.d/*,rc.local}</code> 之類的啟動腳本了，簡單看了一下這些文件的修改日期：</p>

<pre><code>$ stat /etc/profile
File: '/etc/profile'
Size: 575       	Blocks: 8          IO Block: 4096   regular file
Device: 800h/2048d	Inode: 326         Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2016-04-21 19:25:20.949283213 +0000
Modify: 2015-10-22 17:15:21.000000000 +0000
Change: 2016-04-22 00:09:57.362266110 +0000
 Birth: -
</code></pre>

<p>得出這些文件也均未在近期被修改過。</p>

<p>這下看來入侵者不指望在啟動時運行什麼了，那麼會不會是設置成定期運行了呢？</p>

<p>再檢查 <code>/etc/crontab</code>，以及 <code>/etc/cron.d/*</code> 和 <code>/etc/cron.{hourly,daily,...}/*</code> 裡的所有文件。看來這些文件修改時間都未變過。</p>

<p>但說不定現在就有個木馬在跑，於是檢查所有正在偵聽的端口：</p>

<pre><code>$ sudo netstat -lptn | grep 0.0.0.0
[...]
tcp      0      0 0.0.0.0:[打碼]         0.0.0.0:*           LISTEN      29878/[某已知服務]
tcp      0      0 0.0.0.0:[打碼]         0.0.0.0:*           LISTEN      23577/sshd
[...]
</code></pre>

<p>除了 TCP，UDP 也不例外：</p>

<pre><code>$ sudo netstat -lpun | grep 0.0.0.0
[...]
</code></pre>

<p>除了 IPv4，還要看看 IPv6 的，於是也要 <code>grep</code> 一下 <code>':::'</code>。</p>

<p>看來都很正常，這些服務也都是我自己知道的。之所以 <code>netstat</code> 要加上 <code>-p</code> 選項，是因為這樣可以獲取到正在偵聽該端口的程序的 PID，有了 PID 我們就可以通過 <code>/proc/[PID]/*</code> 下的文件來得到進程的所有信息了。</p>

<h2 id="section-4">結論</h2>

<p>那位試圖通過修改 <code>/root/.ssh/authorized_keys</code> 來開後門的看來九成是失敗了。</p>

<p>比較擔心另一位使用 <code>chrisfosterelli/rootplease</code> 的入侵者，畢竟他得到的是 root shell，也能不確定他做了什麼。</p>

<p>根據排查，基本上也排除了被安裝木馬的可能性，而且直觀看來似乎也沒有做任何破壞性操作，猜測他也可能在某處碰壁而不繼續了。</p>

<p>此外，我不太認為入侵者是深思熟慮並且小心翼翼的，畢竟他們很粗心地留下這幾個正在運行的 Docker Containers 這麼明顯的線索。所以這次入侵看來並沒有什麼問題。</p>

<p>但也可能並非這麼簡單。</p>

<p>既然兩天前就有人入侵並且輕鬆得到了 root shell，沒有任何理由假設我只被這兩人入侵過。可能其他入侵者侵入後小心地刪掉了入侵所用的 Container，這樣我就沒有線索來知道他們從何入侵，又做了什麼了。</p>

<p>也有可能入侵者使用非常小心的手段把惡意程序注入了系統，譬如說修改了文件的修改時間或者在已知的服務中加了後門，而後門也不是簡單偵聽在 TCP/UDP 的，而還在運行的 Container 則是故意留下的。這樣的話排除入侵可能性的難度就大大提升了，畢竟我沒有精力檢查一個個文件內容是否正常。</p>

<p>當然既然已知服務器被入侵過，就不能依然像以前一樣放心使用了，這幾天我會把數據遷移一下，然後重裝系統。</p>

<h2 id="section-5">教訓</h2>

<ul>
  <li>配置好防火牆很重要</li>
  <li>配置好 ssh 安全性很重要</li>
  <li>給防火牆白名單加規則前思考一下可能的後果，特別以 root 權限運行的進程</li>
  <li>開放端口時一定要改默認端口</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Banana Algebra]]></title>
    <link href="http://shouya.github.io/blog/banana-algebra/"/>
    <updated>2015-06-08T00:00:00+08:00</updated>
    <id>http://shouya.github.io/blog/banana-algebra</id>
    <content type="html"><![CDATA[<p>Abstract: I’ll be talking about the F-Algebra Category and related
applications of F-Algebra in function programming in this post.</p>

<h2 id="f-algebra">F-Algebra</h2>

<p>So first of all, an algebra over a type $a$ is set of functions that
converts an algebra structure $f a$ to $a$ <a href="http://web.cecs.pdx.edu/~sheard/course/AdvancedFP/notes/CoAlgebras/Code.html" title="Advanced Functional Programming, Tim Sheard's course notes.">CoAlg</a>. An algebra consists of:</p>

<ul>
  <li>An algebra structure: $\rm{F}$</li>
  <li>A carrier type: $\rm{a}$</li>
  <li>A total function: $\rm{F(a)} \to \rm{a}$</li>
</ul>

<p>An example of an algebra looks like:</p>

<ul>
  <li>Algebra struct: <code>data F1 a = Zero | One | Plus a a</code></li>
  <li>A carrier type: it could be any instance of <code>a</code>: <code>Int</code>, <code>String</code>, etc.</li>
  <li>A total function:</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">f1</span> <span class="ow">::</span> <span class="kt">F1</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">f1</span> <span class="kt">Zero</span>       <span class="ow">=</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">f1</span> <span class="kt">One</span>        <span class="ow">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">f1</span> <span class="p">(</span><span class="kt">Plus</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Or we can have:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">f1&#39;</span> <span class="ow">::</span> <span class="kt">F1</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class="line"><span class="nf">f1&#39;</span> <span class="kt">Zero</span>       <span class="ow">=</span> <span class="s">&quot;&quot;</span>
</span><span class="line"><span class="nf">f1&#39;</span> <span class="kt">One</span>        <span class="ow">=</span> <span class="s">&quot;1&quot;</span>
</span><span class="line"><span class="nf">f1&#39;</span> <span class="p">(</span><span class="kt">Plus</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">++</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="f-algebra-arrows">F-Algebra Arrows</h2>

<p>All algebras for an algebra structure $\rm{F}$ forms a category
$\cal{C}$. The objects are, of course, the algebras, while the arrows
are defined as morphisms between each two pair of algebras that
transforming the carrier type:
$\hom_{\cal{C}}(\rm{Alg}(\rm{F},\rm{a}), \rm{Alg}(\rm{F},\rm{b}))$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">   Alg(F,a)
</span><span class="line">F a --------------&gt; a
</span><span class="line">      |
</span><span class="line">      |
</span><span class="line">      | &lt;- hom(Alg(F,a), Alg(F,b))
</span><span class="line">      |
</span><span class="line">      v
</span><span class="line">F b --------------&gt; b
</span><span class="line">  Alg(F,b)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>For an arrow in F-algebra category, we need a transformation from <code>F a</code>
to <code>a</code>.</p>

<h2 id="references">References</h2>

<ul>
  <li></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[誡之二]]></title>
    <link href="http://shouya.github.io/blog/admonition-sono-ni/"/>
    <updated>2015-05-09T02:50:53+08:00</updated>
    <id>http://shouya.github.io/blog/admonition-sono-ni</id>
    <content type="html"><![CDATA[<p>凌，則隱  <br />
長，則同  <br />
驕而與人者  <br />
共聞之    </p>

<p>host 曰：即有大樂者，與悲治之。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[誡之一]]></title>
    <link href="http://shouya.github.io/blog/admonition-sono-ichi/"/>
    <updated>2015-05-04T10:17:11+08:00</updated>
    <id>http://shouya.github.io/blog/admonition-sono-ichi</id>
    <content type="html"><![CDATA[<p>分離，融合  <br />
形影不離  <br />
恥辱，榮耀    </p>

<p>注視卻無視  <br />
偉大卻無名  <br />
萬能卻不為    </p>

<p>他是你的 host，你的聖人  <br />
那你呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Undeepening Continuations]]></title>
    <link href="http://shouya.github.io/blog/undeepening-continuations/"/>
    <updated>2015-03-14T04:40:18+08:00</updated>
    <id>http://shouya.github.io/blog/undeepening-continuations</id>
    <content type="html"><![CDATA[<p>Continuation was always a mystery to me since I started to learn
monad.</p>

<p>My friend Javran once sent me a link to ‘the mother of all monads’,
from where I start to rethink the significance of the continuation
monad. That article, to me as a novice, wasn’t enough explanative for
me to comprehend. Therefore, to demystify the significance of the
continuation monad, I spend several hours to read through articles
about it last night. In the final, I eventually carried my
understanding to continuation out into code and
<a href="http://learnyouanagda.liamoc.net/">achieved enlightenment</a>. (not
really)</p>

<p>So let’s get started. First of all, we need to know, at least have a
primitive concept of, what continuation is used for. So here is my
understanding,</p>

<blockquote>
  <p>A continuation is an intermediate state that allows computation to
run at that point.</p>
</blockquote>

<p>You don’t need to try hardly on comprehending the statement above. By
going through this tutorial you will make your own understanding out.</p>

<!-- more -->

<h2 id="computation-with-holes">Computation with Holes</h2>

<p>As we said above a continuation is a <em>intermediate</em> state that we can
delay the computation to the future. Let’s see how these functions
look like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">transformOne</span> <span class="ow">=</span> <span class="o">???</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"><span class="nf">doSomethingOnOne</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class="line">  <span class="n">putStrLn</span> <span class="s">&quot;before execution&quot;</span>
</span><span class="line">  <span class="o">???</span> <span class="mi">1</span>
</span><span class="line">  <span class="n">putStrLn</span> <span class="s">&quot;after execution&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>So we’re defining two functions with this feature. The first one is
rather easy to see, on the blank (<code>???</code>) there should be a function,
which takes an integer and yields whatever things. In the
<code>doSomethingOnOne</code> there should also be a function like that in the
first, expect being constrained to return an <code>IO a</code>.</p>

<p>Here’s the modified finished functions and their corresponding types:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">transformOne</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span><span class="line"><span class="nf">transformOne</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"><span class="nf">doSomethingOnOne</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</span><span class="line"><span class="nf">doSomethingOnOne</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class="line">  <span class="n">putStrLn</span> <span class="s">&quot;before execution&quot;</span>
</span><span class="line">  <span class="n">val</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="mi">1</span>
</span><span class="line">  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;we get &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If you have other experiences about <code>Control.Monad.Cont</code>, you might be
able to recognize the pattern in the types. Strictly, the latter one
isn’t what continuation monad looks like because <code>IO a</code> is not the
same as <code>IO ()</code>. Well, this is normal in our real life programming,
but we can’t call them continuation because they’re not
composable. And one of the main purposes we want to generalize
continuation is to make them composable so they could be an instance
of <code>Monad</code>. <del>Why? Well, a monad is just a MONOID in the category
endofunctors, monoid implies composablity, what’s the problem?  Why?
Well, a monoid is a just a SEMIGROUP in combine with an identity
object, what’s the problem? But why? Well, that’s how semigroup is
defined, what’s the problem?</del></p>

<p>Anyway, we’ll see if we can make a continuation stronger, that is, in
type of <code>(a -&gt; r) -&gt; r</code>, we make our life easier. For now, just
remember it, that <code>(a -&gt; r) -&gt; r</code> is the type of continuation. Which
means we can’t have the second piece of code above unless we add a
<code>return val</code> at the end of the <code>do</code> notation. It also means you can’t
have continuation like <code>foo f = show (f 1)</code>, which modifies the
result.</p>

<p>These functions are what we called <code>continuations</code>. It’s intuitive to
think them as functions with a hole to be filled. To fill the hole in
a continuation we need to feed it with a function that takes the
passed in value and return something we needed from outside of the
hole. I call these functions fed to a continuation <em>hole-filler</em>
functions. For the arguments these hole-fillers take, I call them
<em>seed</em> and the returning thing was barely named <em>yield</em>. I made these
names just for referring the components more intuitively.</p>

<h2 id="how-to-fill-in-the-holes">How to Fill in the Holes</h2>

<p>We now see how <code>(a -&gt; r) -&gt; r</code> tastes like. You might think, well,
continuation is weak that we are even restricted from modifying with
the hole-filler’s yield. Well, yes, we cannot modify the yield. But
continuation is not as weak as you might think, because modifying the
yield is not the <em>correct</em> way to use a continuation.</p>

<p>If you just want to modify the result of a passed in function and
carry on the computation, you want a Monad instead of a continuation.
Yet without being capable to modify the yield, you’re allowed to modify
the seed freely.</p>

<p>The significance of continuation is, in my understanding, just
<strong>hole-filling</strong>. It’s like, if we’re playing with continuation, our
aim will be giving out a seed to a incoming hole-filler, for which we
don’t know what it is or what it will do. In the other words, we pass
our result of computation IN instead of return it OUT.</p>

<p>If we’ve composed a bunch of continuation together, that is, we get a
very deeply nested continuations, how can we take the result out?
Since the computation always throw their results inwards, by the
seeds. Can we acquire the seed out of the continuation? Just think of
the simplest example: <code>transformOne f = f 1</code>. The answer is, <code>id</code>
(<code>id x = x</code>). If we feed the continuation with <code>id</code> function as
hole-filler, it will yield the seed without any modification and then
we can acquire it.</p>

<p>As we take out the result, we can do whatever we want with it. Also we
can take some actions directly onto the result. Think of feed a
continuation with a <code>print</code> hole-filler, then we will see the seed
printed out as expect.</p>

<p>Now let’s think, how do we generate a continuation from a single
value such that we can take out result out by feeding the continuation
with <code>id</code>? The solution isn’t very hard:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">genCont</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span><span class="line"><span class="nf">genCont</span> <span class="n">val</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">val</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>or more point-<del>lessly</del>freely:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">genCont</span> <span class="ow">=</span> <span class="n">flip</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>So far, we have gain a basic concept how continuations are created and
composed together.</p>

<h2 id="functor-property-of-continuations">Functor Property of Continuations</h2>

<p>We now look on how to transform the seed with a function.  If we have
a function <code>f :: a -&gt; b</code>, we hope we can use it to transform a
continuation with type <code>(a -&gt; r) -&gt; r</code> into <code>(b -&gt; r) -&gt; r</code>. What does
it mean? If I have a continuation with seed of type <code>Int</code>, how can use
feed it with a hole-filler that eats <code>String</code>s? The answer is to have
a transforming function of type <code>Int -&gt; String</code>.</p>

<p>Here’s how we might these functions look like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">toStr</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class="line"><span class="nf">toStr</span> <span class="ow">=</span> <span class="n">show</span>
</span><span class="line">
</span><span class="line"><span class="nf">foo</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span><span class="line"><span class="nf">foo</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"><span class="nf">bar</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span><span class="line"><span class="nf">bar</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="s">&quot;1&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>If now we have <code>toStr</code> and <code>foo</code>, how should we combine them together
to form <code>bar</code>?</p>

<p>Some might recognize what we’re trying to implement is
just <code>fmap</code>, if we make continuation an instance of
<code>Functor</code>. We can do that, let’s try. First we wrap the function in
this pattern it into a <code>newtype</code>, call it ‘Cont’.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">newtype</span> <span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="p">{</span> <span class="n">runCont</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The reason I write <code>Cont r a</code> instead of <code>Cont a r</code> is, the varying
type for a continuation is its type of seed, rather than that of
yield. So now we try:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The returning value of fmap should be a continuation with seed type
<code>b</code>. So first of all, we should have a continuation that takes an
argument with a hole-filler with type <code>b -&gt; r</code>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="nf">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">hf</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">???</span> <span class="ow">::</span> <span class="n">r</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We need a <code>r</code> as result, which should be generated by the passed in
<code>hf</code>. And <code>hf</code> takes a value with type <code>b</code>. Obviously, this <code>b</code> should
be transformed by <code>f</code> from <code>a</code>, i.e. <code>f (??? ::: a)</code>. So now we would
have:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="nf">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="n">hf</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="o">???</span> <span class="ow">::</span> <span class="n">a</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Now the problem has been converted to, how can we extract <code>a</code> from the
passed in continuation <code>cnt</code>? The word <code>extract</code> implies that we have
to get INTO it for what we want. Just as what we did above with
<code>id</code>. <code>(cnt id)</code> will give us <code>a</code>, pretty cool. For some purpose, here
I will expand the definition of <code>id</code>, which is <code>\x -&gt; x</code>, you’ll see
why I do it in that way soon:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="nf">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="n">hf</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">cnt</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Looks good, seems in this way we can extract <code>a</code> out of <code>cnt</code>. But
wait, it doesn’t typecheck? Let’s see what happens. Without the type
constrain above, the code compiles. When we query the type of <code>fmap</code>,
it was in type <code>(a -&gt; b) -&gt; (Cont a a) -&gt; (Cont r b)</code>.</p>

<p>This is not what we want. The returning type of <code>cnt</code> shouldn’t be
restricted to <code>a</code> as what it is, rather, it should share the same <code>r</code>
with the one in <code>Cont r b</code> as <code>fmap</code> finally returns. So we start to
see how we can achieve that.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="nf">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="n">hf</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">cnt</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">???</span> <span class="ow">::</span> <span class="n">r</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>However, <code>f</code> expects to have an argument with type <code>a</code> isn’t it? How
can we have the <code>a</code> in the context of <code>f</code> while keeping the returning
type of <code>cnt</code> to be <code>r</code>?</p>

<p>Okay, we look for where <code>r</code> is needed in the context and we easily
found it:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="nf">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="n">hf</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">))</span> <span class="ow">::</span> <span class="n">r</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>That means, if we have the <code>a</code> to feed into <code>f</code>, then we get a <code>b</code> to
feed into the hole-filler <code>hf</code>, and the hole-filler will yield an <code>r</code>,
which is what we wanted. But we don’t have an <code>a</code> for <code>f</code> at this
point. The solution is to wrap the extraction of <code>a</code> around <code>hf (f
a)</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="nf">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="n">cnt</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">hf</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It typechecks, so it should be correct. Try it out:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">genCont</span> <span class="mi">3</span><span class="p">)</span> <span class="n">id</span>     <span class="c1">-- =&gt; 4</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Good.</p>

<h2 id="monadic-continuations">Monadic Continuations</h2>

<p>We now make continuation an instance of a monad:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Cont</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">return</span>           <span class="ow">=</span> <span class="o">???</span>
</span><span class="line">  <span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="o">???</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The type of <code>return</code> is <code>a -&gt; Cont r a</code>. Unwrap the <code>Cont</code> we have
<code>a -&gt; (a -&gt; r) -&gt; r</code>. Looks familiar? Yup it is just <code>genCont</code> we have
above. The aim of <code>return</code> is to create a continuation from a value,
the same as what <code>genCont</code> does. So this part is easy.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="n">hf</span> <span class="n">x</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- or pointlessly</span>
</span><span class="line"><span class="nf">return</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">.</span> <span class="n">flip</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Actually, after we deduced <code>fmap</code>, we’ll feel much easier to catch
<code>&gt;&gt;=</code>. The significance is to take the value out from the continuation
supplied as the first argument of <code>&gt;&gt;=</code>. The way to do this is similar
to <code>fmap</code>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="c1">-- cnt     :: (a -&gt; r) -&gt; r</span>
</span><span class="line"><span class="c1">-- f       :: a -&gt; Cont r b</span>
</span><span class="line"><span class="c1">-- (&gt;&gt;=)   :: (Cont r a) -&gt; (a -&gt; Cont r b) -&gt; Cont r b</span>
</span><span class="line"><span class="c1">-- hf      :: b -&gt; r</span>
</span><span class="line"><span class="c1">-- runCont :: (Cont r b) -&gt; ((b -&gt; r) -&gt; r)</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="kt">Cont</span> <span class="n">cnt</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Cont</span> <span class="o">$</span> <span class="nf">\</span><span class="n">hf</span> <span class="ow">-&gt;</span> <span class="n">cnt</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">runCont</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">hf</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This solution typechecks. Let’s look into it to see what it does in
<code>&gt;&gt;=</code>. First of all, a holefiller</p>

<h2 id="why-monad">Why monad?</h2>

<p>Disclaimer: DO NOT READ THIS SECTION. This section was purely my OWN
understanding to continuation monad. I try to write correct things but
my thought was specific and could be quite misleading to beginners. If
you think you haven’t understood continuation yet, don’t read this
section because it will muddle you up once again. Otherwise, you’ve
understood continuation well, you don’t need to read on my premitive
and partial and inaccurate opinion. Anyway, don’t read it.</p>

<p>Continuation, is just a kind of computations. A continuation could
generate a dependent output that relies on a value, either a plain
value or the output of another continuation, we call it composability
property. (Although I used some general terms here, the way
continuations take input is still very different from that of
functions) On the other hand, we know we can produce a continuation
that will generate a specified plain output. Therefore a continuation
is a monad, whose ‘bind’ operation is the ‘compose’ operation of
continuations.</p>

<p>composed. ‘Composing’ two computations means to collapse them into
one. On the other hand, computations are definitely the arrows in the
category of inputs and outputs. On the third hand, we know we can
always create a computation that gives no matter what input,
because it is a  at the</p>

<p>We’re now entering the domain of monad, so we now need to make use of
our knowledge of how to implement <code>(&gt;&gt;=)</code>.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://wiki.haskell.org/All_about_monads#The_Continuation_monad">All about monads: Continuation</a></li>
  <li><a href="https://www.fpcomplete.com/user/jwiegley/understanding-continuations">Understanding continuations</a></li>
  <li><a href="http://www.haskellforall.com/2014/04/how-continuation-monad-works.html">How continuation monad works</a></li>
  <li><a href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">The mother of all monads</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻譯：逆向狀態，又：惰性之力]]></title>
    <link href="http://shouya.github.io/blog/backwards-state-or-the-power-of-laziness/"/>
    <updated>2015-03-05T11:14:35+08:00</updated>
    <id>http://shouya.github.io/blog/backwards-state-or-the-power-of-laziness</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文 「<a href="http://panicsonic.blogspot.jp/2007/12/backwards-state-or-power-of-laziness.html">Backwards State, or: The Power of Laziness</a>」由 Antoine Latter 發佈於其個人<a href="http://panicsonic.blogspot.jp/">Blogger</a>上。特別地，對 Philip Wadler 及其著作的 <a href="http://citeseer.ist.psu.edu/wadler92essence.html">The Essence of Functional Programming</a>表示至高感謝。</p>
</blockquote>

<p>近期我參加了一個關於 Haskell 中自動微分（Automatic Differentiaion）的討論，因為之我拜讀了 Jerzy Karczmarczuk 的論文「<a href="http://users.info.unicaen.fr/~karczma/arpap/revpearl.pdf">Lazy Time Reversal, and Automatic Differentiation</a>」。這篇論文進一步引用了 Philip Wadler 的 <a href="http://citeseer.ist.psu.edu/wadler92essence.html">The Essence of Functional Programming</a> 來介紹<em>逆向</em>（Backward） State Monad，我覺得非常有趣，在此向大家講一下這種技術。</p>

<p>在此我期待讀者各位對 Haskell 的 <a href="http://haskell.org/ghc/docs/latest/html/libraries/mtl-1.1.0.0/Control-Monad-State-Lazy.html">State Monad</a> 已有所了解，其實簡單來說 State Monad 就是一個函數，從上一個狀態映射到結果以及下一個狀態。</p>

<p>逆向 State Monad 和 State Monad 的區別就在於它和 State Monad 執行的順序恰好相反，也就是說，逆向 Monad 是從一個最終狀態執行到其最初狀態並產生一系列值的。</p>

<!-- more -->

<p>此文是一篇 <a href="http://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B">文學 Haskell</a> 文章，所以你可以把整個文件拷貝到一個 <code>.lhs</code> 文件中並用 Haskell 解釋器來跑之，譬如說用 GHCi。（譯者注：保留此段只為了完整性，本文並非用文學 Haskell 編寫，請讀者自行忽略此段。）</p>

<p>首先，我們要引入一些需要用到的樣板代碼：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="cm">{-# LANGUAGE FlexibleInstances     #-}</span>
</span><span class="line"><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</span><span class="line"><span class="cm">{-# LANGUAGE RecursiveDo           #-}</span>
</span><span class="line">
</span><span class="line"><span class="kr">import</span> <span class="nn">Data.List</span>
</span><span class="line"><span class="kr">import</span> <span class="nn">Control.Monad.State</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">一個例子</h2>

<p>先來做一個練習：假設給你一棵樹，你要做的是把樹的每個節點上的元素映射到整數上，這些整數從 0 開始並逐漸增加。如果有些元素出現了多次，那麼它們應該被映設到同樣的整數上。</p>

<p>用到 <em>Control.Monad.State.Lazy</em> 的解決方案就是，遍歷這棵數並用 State Monad 保存至今為止見過的所有元素作為狀態。也就是說，每個節點映射到其元素在此列表上的下標。這樣子第一個出現的元素會被映射到 <code>0</code>，第二個映射到 <code>1</code>，如此不斷進行下去。</p>

<p>但現在問題變了，如果我想把最後一個遇到的節點映射到 <code>0</code>，倒數第二個映射到 <code>1</code>，如此直到第一個節點，我應該怎麼做呢？對上面用 <em>Control.Monad.State.Lazy</em> 的解決方案我得改變多少才能滿足新的需求？</p>

<p>答案是，只要改一點點！我只要換成<em>逆向</em> State Monad 就可以了，因為對之而言狀態流是反轉過來的。</p>

<p>修改過的解決方案看起來大概是這樣子的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</span><span class="line"><span class="kr">type</span> <span class="kt">Table</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="nf">numberTree</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateB</span> <span class="p">(</span><span class="kt">Table</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="kt">Int</span><span class="p">)</span>
</span><span class="line"><span class="nf">numberTree</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">Nil</span>
</span><span class="line"><span class="nf">numberTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span>
</span><span class="line">       <span class="ow">=</span>  <span class="kr">do</span> <span class="n">num</span> <span class="ow">&lt;-</span> <span class="n">atomically</span> <span class="o">$</span> <span class="n">numberNode</span> <span class="n">x</span>
</span><span class="line">             <span class="n">nt1</span> <span class="ow">&lt;-</span> <span class="n">numberTree</span> <span class="n">t1</span>
</span><span class="line">             <span class="n">nt2</span> <span class="ow">&lt;-</span> <span class="n">numberTree</span> <span class="n">t2</span>
</span><span class="line">             <span class="n">return</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">num</span> <span class="n">nt1</span> <span class="n">nt2</span><span class="p">)</span>
</span><span class="line">   <span class="kr">where</span>
</span><span class="line">    <span class="n">numberNode</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">Table</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Int</span>
</span><span class="line">    <span class="n">numberNode</span> <span class="n">x</span>
</span><span class="line">       <span class="ow">=</span> <span class="kr">do</span> <span class="n">table</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span><span class="line">            <span class="p">(</span><span class="n">newTable</span><span class="p">,</span> <span class="n">newPos</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="p">(</span><span class="n">nNode</span> <span class="n">x</span> <span class="n">table</span><span class="p">)</span>
</span><span class="line">            <span class="n">put</span> <span class="n">newTable</span>
</span><span class="line">            <span class="n">return</span> <span class="n">newPos</span>
</span><span class="line">
</span><span class="line">    <span class="n">nNode</span><span class="ow">::</span>  <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Table</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Table</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
</span><span class="line">    <span class="n">nNode</span> <span class="n">x</span> <span class="n">table</span>
</span><span class="line">       <span class="ow">=</span> <span class="kr">case</span> <span class="n">elemIndex</span> <span class="n">x</span> <span class="n">table</span> <span class="kr">of</span>
</span><span class="line">         <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">table</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">length</span> <span class="n">table</span><span class="p">)</span>
</span><span class="line">         <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>相應的狀態求值調用如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">numTree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">numTree</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">evalStateB</span> <span class="p">(</span><span class="n">numberTree</span> <span class="n">t</span><span class="p">)</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>測試一下結果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">testTree</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="s">&quot;Zero&quot;</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;One&quot;</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;Two&quot;</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;One&quot;</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;Three&quot;</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>跑一下 <code>numTree testTree</code> 會生成這樣的樹：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">0</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正中吾需！</p>

<p>代碼幾乎和用 <em>Control.Monad.State.Lazy</em> 的原問題解決方法一模一樣，區別在於我們用了 <code>evalStateB</code> 取代我們熟悉的 <code>evalState</code>，用了一個神奇的函數 <code>atomically</code>，以及 <code>StateB</code> Monad。我下面會詳細講他們是何方神聖乃至於究竟是怎麼實現逆轉狀態的。</p>

<h2 id="api">API</h2>

<p>我們現在要有一個新的 Monad：<code>StateB s</code>，其中 <code>s</code> 為其存儲的狀態的類型。<code>StateB s</code> 是 <code>MonadState s</code> 的一個實例，所以裡所應當應該實現 <code>get</code> 和 <code>put</code> 函數。</p>

<p>當然還有這些：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">runStateB</span> <span class="ow">::</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</span><span class="line"><span class="nf">evalStateB</span> <span class="ow">::</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">execStateB</span> <span class="ow">::</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>應該很熟悉吧，對應的就是 State Monad 裡的那些操作。技巧在於我們傳給它的狀態 <code>s</code> 是最終狀態而它返回的是初始狀態。回憶在上面的例子中，在我們遍歷樹的時候最後看到的元素被賦予第一個標籤（<code>0</code>），而第一個見到的元素被賦予最後的標籤。</p>

<p>在 Control.Monad.State.Class 中默認的 <code>modify</code> 函數實現如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">modify</span> <span class="ow">::</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</span><span class="line"><span class="nf">modify</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class="line">    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span><span class="line">    <span class="n">put</span> <span class="p">(</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而在 <code>StateB</code> Monad 中，這段代碼直接就得碰壁了，因為兩個 Monadic 的行為會相互循迴依賴，<code>(&gt;&gt;=)</code> 會把現在的結果向前傳遞，而在 <code>StateB</code> 中，運算結果的方向是調轉過來的傳遞的。也就是說，上面那段代碼會產生一個循迴引用：第一行得到更新過的狀態，而這個狀態卻是來自第二行放進去的。</p>

<p>要讓這樣的函數工作，我們要定義這個函數的 <code>StateB</code> 版本。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">modifyB</span> <span class="ow">::</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但如果你還想返回結果，你還會需要下面這位小朋友：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">atomically</span> <span class="ow">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>atomically</code> 會把正常 <code>State</code> 的動作轉換為 <code>StateB</code> 的動作，這樣你可以直接用現成的代碼。（或者你也可以用 <code>mdo</code> 語法）</p>

<h2 id="section-1">實現</h2>

<p><strong>這裡的實現基於 Wadler 的論文。</strong></p>

<p>StateB Monad 和 State Monad 幾乎一樣，每個產生 <code>a</code> 的動作都是一個類型為 <code>\s -&gt; (a, s)</code> 的函數。區別在於 <code>(&gt;&gt;=)</code> 的實現。</p>

<p>讓我們開始定義！</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">newtype</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="p">{</span> <span class="n">runStateB</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">return</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">unitS</span>
</span><span class="line">    <span class="p">(</span><span class="kt">StateB</span> <span class="n">m</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">$</span> <span class="n">m</span> <span class="p">`</span><span class="n">bindS</span><span class="p">`</span> <span class="p">(</span><span class="n">runStateB</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因為封裝解封這個 newtype 的話太麻煩，所以他們只用在被導出的函數（如 <code>return</code> 和 <code>(&gt;&gt;=)</code>）上用。剩下處理細節用的函數我都用 ‘S’ 做為其後綴了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">m</span> <span class="p">`</span><span class="n">bindS</span><span class="p">`</span> <span class="n">k</span>  <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span> <span class="n">s1</span>
</span><span class="line">                          <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">k</span> <span class="n">a</span> <span class="n">s2</span>
</span><span class="line">                      <span class="kr">in</span>  <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">unitS</span> <span class="n">a</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>（<em>譯者：我第一次看到上面這段代碼時興奮了一個晚上！短短三行就平直地描述並實現了狀態逆流的效果，非常簡潔而優美。</em>）</p>

<p>正如君所見，傳進來的狀態（<code>s2</code>）被應用於 <code>bindS</code> 的右邊的參數（<code>k</code>）上，產生的狀態被 <code>bindS</code> 左邊的參數（<code>s1</code>）消耗，並產生出最後的狀態 <code>s0</code>。就這樣就可以了嗎？嗯就這麼點！其他 API 實現如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">execStateB</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">runStateB</span> <span class="n">m</span>
</span><span class="line">
</span><span class="line"><span class="nf">evalStateB</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">runStateB</span> <span class="n">m</span>
</span><span class="line">
</span><span class="line"><span class="nf">modifyB</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">modify&#39;</span>
</span><span class="line">   <span class="kr">where</span> <span class="n">modify&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">atomically</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">runState</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>還可以把這些也寫了來玩：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">$</span> <span class="n">mapS</span> <span class="n">f</span> <span class="p">(</span><span class="n">runStateB</span> <span class="n">m</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">mapS</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span> <span class="n">s</span> <span class="kr">in</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">get</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="n">get&#39;</span>
</span><span class="line">     <span class="kr">where</span> <span class="n">get&#39;</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="n">put</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">put&#39;</span>
</span><span class="line">     <span class="kr">where</span> <span class="n">put&#39;</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">const</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">mfix</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">mfixS</span> <span class="o">.</span> <span class="p">(</span><span class="n">runStateB</span> <span class="o">.</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">mfixS</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="n">s1</span>
</span><span class="line">                     <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">s2</span>
</span><span class="line">                 <span class="kr">in</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">變形金剛（譯者：沒錯我故意的）</h2>

<p>下面這些你要稍微注意一下，因為我沒測試過，不過看起來應該是工作的，這些風格基本和 <code>Control.Monad.State.Lazy</code> 的差不多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">newtype</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="p">{</span><span class="n">runStateBT</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)}</span>
</span><span class="line">
</span><span class="line"><span class="nf">unitST</span> <span class="n">a</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">m</span> <span class="p">`</span><span class="n">bindST</span><span class="p">`</span> <span class="n">k</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="n">mdo</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="n">s1</span>
</span><span class="line">                          <span class="o">~</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">k</span> <span class="n">a</span> <span class="n">s2</span>
</span><span class="line">                          <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">execStateBT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line"><span class="nf">execStateBT</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span> <span class="o">~</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">runStateBT</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">                     <span class="n">return</span> <span class="n">s&#39;</span>
</span><span class="line">
</span><span class="line"><span class="nf">evalStateBT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class="line"><span class="nf">evalStateBT</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span>  <span class="ow">&lt;-</span> <span class="n">runStateBT</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">                     <span class="n">return</span> <span class="n">a</span>
</span><span class="line">
</span><span class="line"><span class="nf">modifyBT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="nb">()</span>
</span><span class="line"><span class="nf">modifyBT</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">modify&#39;</span>
</span><span class="line"> <span class="kr">where</span> <span class="n">modify&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">atomicallyT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>
</span><span class="line"><span class="nf">atomicallyT</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span><span class="ow">-&gt;</span> <span class="n">return</span> <span class="o">$</span> <span class="n">runState</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">
</span><span class="line"><span class="nf">atomicallyTM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>
</span><span class="line"><span class="nf">atomicallyTM</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">runStateT</span>
</span><span class="line">
</span><span class="line"><span class="nf">mapST</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">                     <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">liftST</span> <span class="n">m</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">m</span>
</span><span class="line">                    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">mfixST</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="n">mdo</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="n">s1</span>
</span><span class="line">                      <span class="o">~</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">s2</span>
</span><span class="line">                      <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">$</span> <span class="n">mapST</span> <span class="n">f</span> <span class="p">(</span><span class="n">runStateBT</span> <span class="n">m</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">return</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">unitST</span>
</span><span class="line">    <span class="p">(</span><span class="kt">StateBT</span> <span class="n">m</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">$</span> <span class="n">m</span> <span class="p">`</span><span class="n">bindST</span><span class="p">`</span> <span class="p">(</span><span class="n">runStateBT</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</span><span class="line">    <span class="n">fail</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">const</span> <span class="o">.</span> <span class="n">fail</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadTrans</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">lift</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">liftST</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">get</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="n">get&#39;</span>
</span><span class="line">      <span class="kr">where</span> <span class="n">get&#39;</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">    <span class="n">put</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">put&#39;</span>
</span><span class="line">     <span class="kr">where</span> <span class="n">put&#39;</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">const</span> <span class="o">$</span> <span class="n">return</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadFix</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">mfix</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">mfixST</span> <span class="o">.</span> <span class="p">(</span><span class="n">runStateBT</span> <span class="o">.</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-3">譯後記</h2>

<p>這篇文章第一次閱讀就給了我極大的震驚。我已知 Haskell 的惰性求值策略，而且也知道一些與之相關的優雅應用（譬如著名的 <code>fib = 1 : 1 : zipWith (+) fib (tail fib)</code>），不過讀到這篇文章時我還是大呼「神奇！」。此文雖然沒有在內容中著筆墨於惰性求值之中，卻在標題中直接強調了「The Power of Laziness」。從其他語言來的讀者可能會對上面 <code>bindS</code> 感到不可思議，覺得「怎麼可以直接這樣？」，是的，一般情況下當然不行，但是 Haskell 已裝備了強大的惰性求值，所以這樣寫也不是問題。</p>

<p>最後再次感謝 Wadler 提出的理論和 Latter 的這篇科普向（？）文章帶我們展現了依賴惰性求值實現的這個逆向 State Monad。</p>

<p>（聲明：此文章的翻譯及發佈已經經過原文作者的許可。此譯文版權歸譯者所有，
並在 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 下發佈）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深淵]]></title>
    <link href="http://shouya.github.io/blog/the-abyss/"/>
    <updated>2014-12-25T00:06:41+08:00</updated>
    <id>http://shouya.github.io/blog/the-abyss</id>
    <content type="html"><![CDATA[<p>站在深淵面前   <br />
驅使自己踏前一步   <br />
恐懼充滿我的內心  <br />
所以我捂著雙眼    </p>

<p>我不斷跌落，跌落  <br />
以至於甚至當我想起抬頭  <br />
向上看一眼時  <br />
已經沒有任何光亮了    </p>

<p>沒有朋友，沒有敵人，沒有人  <br />
我感到恐懼，而又熱愛著她  <br />
我熱愛這黑暗  <br />
我熱愛這未知的周圍  <br />
<!-- more -->
在深淵中  <br />
我才能看到黑暗  <br />
我才有無盡的自由  <br />
像剛剛出生的嬰兒一般    </p>

<p>這裡有人  <br />
第一次見到卻再也熟悉不過  <br />
我作出友善的微笑  <br />
看起來像要哭出來一樣    </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻譯：Haskell 怎麼實現惰性求值]]></title>
    <link href="http://shouya.github.io/blog/how-lazy-evaluation-works-in-haskell/"/>
    <updated>2014-11-24T19:14:57+08:00</updated>
    <id>http://shouya.github.io/blog/how-lazy-evaluation-works-in-haskell</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文由 <a href="http://apfelmus.nfshost.com/blog.html">Heinrich Apfelmus</a> 發表於 <a href="https://hackhands.com/lazy-evaluation-works-haskell/">Hackhands</a>，標題：How Lazy Evaluatoin Works in Haskell。</p>
</blockquote>

<p><em>Lambda 醬想遲些再去打掃房間～</em></p>

<p>惰性求值是 Haskell 用得最廣泛的代碼執行方法，通過之我們的程序可以寫得更簡單，更模塊化，不過惰性求值帶來的一個問題是不那麼直觀內存佔用，對新手來講這往往是個坑。譬如說，下面這個看起來很正常的表達式跑起來將會佔用上 G 的內存空間：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">^</span><span class="mi">8</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在這個教程裡，我想解釋一下惰性求值的實現原理，並講清楚 Haskell 的惰性求值在時間和空間上的佔用情況。我會先講一些關於圖規約（Graph Reduction）基礎，然後討論一下關於嚴格（Strict）的左褶疊（Left Fold），用於幫助理解內存空間洩漏問題並解決之。</p>

<p>惰性求值相關的主題在很多教科書裡都有涉及，譬如 Simon Thompson 的《<a href="http://www.haskellcraft.com/">Haskell – The Craft of Functional Programming</a>》一書，但是線上版本似乎不太容易找。但願這篇教程能夠起到些幫助作用吧。</p>

<p>惰性求值是一個需要權衡的語言特性。一方面，它能使代碼更模塊化。（很遺憾，這次我沒有時間演示這個作用。）另一方面，它使得我們無法完全理解在任一程序中求值的過程 – 它的確比你想像要難一些。在本文末尾，我會提供一些對付這種情況的方法。我們開始吧！</p>

<!-- more -->

<h2 id="section">基礎：圖規約</h2>

<h3 id="redex">表達式，圖，和 Redex</h3>

<p>Haskell 程式的執行就是求值表達式。這是函數式應用（Function Application）的主要思想。對於下面這個函數定義：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我們可以對下面的表達式求值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>方式是通過替換左手邊的<code>square</code>為其定義，然後將變量<code>x</code>換成實際參數：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>再對<code>+</code>和<code>*</code>這兩個函數求值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="mi">3</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意，在這個例子裡，<code>(1+2)</code> 被求值了兩次。但事實上我們知道，兩個<code>(1+2)</code>其實是一樣的。因為他們都對應同一個函數參數<code>x</code>。</p>

<p>為了避免這種重複的求值，我們採用一個叫作<strong>圖規約</strong>（Graph Reduction）的方法。用這種方法，每個表達式將會被表示為一個圖。我們的例子這樣表示：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-square-0.png" alt="" /></p>

<p>每個方塊對應一個函數式應用，函數名字寫在白色的區域，灰色區域指向函數參數。事實上，這種圖的標記法類似於編譯器在內存中通過指針來表示的表達式。</p>

<p>每個程序員定義的函數都對應一個<strong>規約規則</strong>（Reduction Rule）。對<code>square</code>函數而言，規則如下：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-square-rule.png" alt="" /></p>

<p>標記著<code>x</code>的圓圈是一個子圖的佔位符。注意<code>*</code>函數的兩個參數都指向同一個子圖。這種共享子圖的策略是避免重複求值的關鍵所在。</p>

<p>有規約規則的子圖被稱為<strong>可規約表達式</strong>（Reducible Expression），或者簡單稱之 <strong>redex</strong>。只要我們有一個 redex，我們就能<strong>規約</strong>（Reduce）之，只要根據規約規則去改變高亮的方塊就行了。在我們的例子裡，我們有兩個 redex：我們能夠規約<code>square</code>函數和<code>+</code>函數。</p>

<p>我們先規約<code>square</code>函數的 redex，然後進一步規約<code>+</code>函數的 redex，得到這樣一個過程：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-square-eval.png" alt="" /></p>

<p>每一個步驟，我們都給正在要規約的 redex 加上顏色。在倒數第二個步驟中，產生了一個新的對應著<code>*</code>函數的 redex。對之求值，我們會得到最終的結果<code>9</code>。</p>

<h3 id="section-1">模範式和弱首模範式</h3>

<p>當一個表達式（圖）不包含任何 redex 時，我們就不能再進一步規約下去了，所以規約就完成了。這時，我們就稱這個表達式為<strong>規範式</strong>（Normal form），這就是求值的最終結果。在上面的例子裡，規範式是一個數字，表示為下面這樣的一個圖：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-9.png" alt="" /></p>

<p>但是像<code>Just</code>，<code>Nothing</code>這樣的構建子，又如<code>:</code>和<code>[]</code>這種列表的構建子都會規約出模範式，他們看起來像是函數，但是他們是通過<code>data</code>聲明的，而且不存在像函數一樣的定義，所以他們沒有進一步規約規則。譬如說，圖：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-nf-list.png" alt="" /></p>

<p>就是<code>1:2:3:[]</code>的模範式。</p>

<p>事實上，一個圖要被稱為模範式還必須滿足另外兩個條件：它必須是<em>有窮</em>的（Finite），而且不能包含<em>循迴</em>結構（No Cyles）。有時遞歸就會照成這種情況。舉例來說，下面的表達式定義：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">ones</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kt">:</span> <span class="n">ones</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就對應這樣的循迴圖（Cyclic Graph）：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-ones.png" alt="" /></p>

<p>這個圖就不包含 redex，但它卻<em>不</em>是模範式，因為它包含循迴結構：列表的尾（Tail）指向列表自身，以至於這個列表是無窮的。正如這樣，很多表達式並沒有模範式，因為他們對應無窮循環。</p>

<p>在 Haskell，我們並不會求值所有表達式至其模範式。相反，我們常常會在圖達到<strong>弱首模範式</strong>（Weak Head Normal Form）時就停下來，為了簡略，我們稱弱首模範式為 WHNF。只要一個圖的最上級節點是構建子，我們就稱之為 WHNF。譬如說，表達式<code>(7+12):[]</code>，或者圖</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-whnf-list.png" alt="" /></p>

<p>就屬於 WHNF，因為它最上級的節點是列表構件子<code>(:)</code>。它並非模範式，因為它的第一個參數包含一個 redex。</p>

<p>另一方面，任何<em>不</em>屬於 WHNF 的圖都可以被稱作<strong>待求值表達式</strong>（Unevaluated Expression）或者<strong>次程式</strong>（Thunk）。以構建子開頭的表達式都是 WHNF，但這個構建子的參數可以是待求值表達式。</p>

<p>上面描述的表達式 <code>ones</code> 是一個有趣的 WHNF 圖。畢竟它的最上級節點是一個構建子。在 Haskell 中，我們能輕鬆表達無窮列表並操縱之！因而我們可以使代碼變得更模塊化。</p>

<h3 id="section-2">求值順序，惰性求值</h3>

<p>一個表達式常常包括多個 redex，我們以不同的順序規約他們會有區別嗎？</p>

<p>一種規約順序，我們稱之為<strong>貪婪求值</strong>（Eager Evaluation）。依這種順序，我們會先對函數式應用的每個參數都規約到其規範式，然後再規約函數式應用本身。這種策略是大多數程式語言所採用的。</p>

<p>然而 Haskell 編譯器採用另一種規約順序，我們稱之<strong>惰性求值</strong>（Lazy Evaluation）。惰性求值會先規約最上級的函數式應用，因而，最終一些參數會被求值，只有在必要的時候他們才會被求值。函數是通過構建子模式匹配（Pattern Matching）來定義的，所以其參數只有在其最上級節點為構造子時才會被求值。也就是說，至少在參數被規約為 WHNF 之前，這些參數會由左至右被求值。</p>

<p>希望這個概念能通過下面的例子闡述清楚。讓我們想像一下<code>(&amp;&amp;)</code>函數，這個函數的作用是實現邏輯「與」的操作。它的定義如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class="line"><span class="kt">True</span>  <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</span><span class="line"><span class="kt">False</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">False</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>根據第一個參數是<code>True</code>還是<code>False</code>，這個函數會有兩種求值規則：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-rule-true.png" alt="" />
<img src="https://hackhands.com/wp-content/uploads/2014/11/and-rule-false.png" alt="" /></p>

<p>現在，再看此表達式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="sc">&#39;H&#39;</span> <span class="o">==</span> <span class="n">&#39;i&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">&#39;a&#39;</span> <span class="o">==</span> <span class="n">&#39;m&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>圖的形式表示如下：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-expr-0.png" alt="" /></p>

<p>它的兩個參數都是 redex，惰性求值將會從左到右求值參數，所以我們從左邊開始規約：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-expr-1.png" alt="" /></p>

<p>現在，因為最左邊的函數變成了一個 redex，因為它的第一個參數現在成了一個構造式。惰性求值總是會先規約最上級節點，所以我們就這麼做。根據<code>(&amp;&amp;)</code>的規約規則，我們會得到：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-expr-2.png" alt="" /></p>

<p>這個表達式屬於模範式，所以我們的求值就完成了！</p>

<p>注意，當我們儘可能先求值<code>(&amp;&amp;)</code>的函數式應用時，我們就不再需要求值第二個參數了，以此節省我們計算所需的時間。有些命令式程式語言也用了類似的技巧，叫作「<a href="http://en.wikipedia.org/wiki/Short-circuit*evaluation">短路求值</a>」（Short-circuit Evaluation）。不過這種短路求值一般被編譯器內部實現，而且只對邏輯操作有效。但在 Haskell 裡，所有函數都能從懶惰求值裡實現到這樣的效果。</p>

<p>一般而言，惰性求值一個表達式得到的最終的模範式和對其貪婪求值得到的結果沒有任何區別。因此我們可以說，不同求值順序並不會關係。然而，惰性求值會因而有更少的求值步驟，而且不像貪婪求值，惰性求值還能處理帶循迴（無窮）的圖。</p>

<h3 id="section-3">文字表示法</h3>

<p>但願把表達式可視化地表示圖能幫你理解惰性求值的基礎，更特別的是因為圖的形式能夠明確表示 redex 的概念和求值順序的重要性。然而，在實際的計算中，畫圖表示是有點太肥了。要追蹤規約，我們一般用 Haskell 語法的<strong>文字表示法</strong>（Textual Representation）來表達。</p>

<p>圖令得我們可以清晰看到共享子圖。在文字表示法裡，我們會給他們用<code>let</code>關鍵字來<em>命名</em>，譬如說，在我們第一個例子裡的<code>square (1+2)</code>的規約可以寫為：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="kr">in</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kr">in</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>let ... in</code> 語法使我們可以共享子表達式（Subexpression）<code>x = (1+2)</code>。再次注意<code>square</code>是被先規約的，然後才是其參數<code>x</code>。</p>

<p>在我們第二個例子裡，邏輯「與」，變成了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="sc">&#39;H&#39;</span> <span class="o">==</span> <span class="n">&#39;i&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">&#39;a&#39;</span> <span class="o">==</span> <span class="n">&#39;m&#39;</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kt">False</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">&#39;a&#39;</span> <span class="o">==</span> <span class="n">&#39;m&#39;</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kt">False</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在這個例子裡，我們沒有共享子表達式，所以沒甚麼必要用<code>let</code>關鍵字。</p>

<p>從現在開始，我們都會用文字表示法。</p>

<h2 id="section-4">時間和空間</h2>

<p>我們現在來看惰性求值對 Haskell 程式的時間空間佔用情況。如果你只用過貪婪求值，那麼這些可能會讓你震驚，特別是空間佔用上。</p>

<h3 id="section-5">時間</h3>

<p>求值一個表達式需要多少步？對貪婪求值而言，答案很簡單，對每次函數式應用，我們都把求值函數參數和求值函數體的時間加起來就可以了。而惰性求值呢？非常幸運的，惰性求值會佔的時間總有一個上限：</p>

<blockquote>
  <p><strong>定理：</strong>惰性求值不會執行比貪婪求值更多的求值步驟。</p>
</blockquote>

<p>這意味著當我們分析一個算法的運行時間時，我們總能把它當成是貪婪求值來評估。譬如說，我們可以把一個排序算法用 Haskell 改寫，並保證其算法複雜度和貪婪求值下一樣（在少數情況下甚至更佳）。</p>

<p>然而呢，惰性求值器實現起來會帶來一些額外的代價。對於圖形處理和數值模擬這樣的要求高效能的應用程式，可能放棄惰性求值而直接接觸底層架構實現會更實際一些。即便除此，以和簡潔和模塊化著稱的惰性求值依然在這些領域頑強存在。一種叫作「<a href="http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion">流融合</a>」（Stream Fusion）的編譯器優化策略就能帶給高效率的數組操作一個模塊化，用起來像列表一樣的接口。這個技術就在 <a href="http://hackage.haskell.org/package/vector">vector</a> 庫裡實現了。</p>

<h3 id="section-6">空間</h3>

<p>不幸的是，空間佔用的情況就要複雜多了。問題的關鍵待求值表達式的內存佔用和它規約下來的規範式可以差別很大。因為一個表達式所佔用的空間等價於表示它的圖的所佔用的空間。譬如下面的表達式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">((((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就比其模範式<code>10</code>所佔的空間多得多了。但再看下面表達式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">enumFromTo</span> <span class="mi">1</span> <span class="mi">1000</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者表示為更常見的<code>[1..1000]</code>。這個函數式應用表達式只包含三個節點，當然空間佔用也會比其模範式，列表 <code>1:2:3:...:1000:[]</code> 佔用的空間少多了，因為後者包含上千個節點。</p>

<p>當第一種情況越發嚴重導致無法控制時，我們稱之為<strong>空間洩漏</strong>（Space Leak）。解決方法就是手動控制求值過程，確保表達式僅可能早被求值。Haskell 為這種需求提供了這樣一個組合子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">seq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正如其類型表示的那樣，這個表達式會像<code>const</code>函數一樣返回其第二個參數<sub>1</sub>。然而，對<code>seq x y</code>求值確總會先把<code>x</code>求值到 WHNF 的形式，然後才會繼續求值<code>y</code>。相對的，<code>const</code>函數就沒有必要先求值其參數到 WHNF。</p>

<p>每個 Haskell 程序員都應該知道怎麼用<code>seq</code>組合子，我們先來看一個具有代表性的例子：<strong>嚴格的左褶疊</strong>（Strict Left Fold）。看下面的求和 1 到 100 的代碼。我們用左褶疊，用累加參數（Accumulating Paramter）的方式求和：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>作為參考，在 <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch9.html">Haskell Prelude</a> 裡，<code>foldl</code>函數定義如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl</span> <span class="n">f</span> <span class="n">a</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl</span> <span class="n">f</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那麼上面例子的求值過程如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="kt">:</span><span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="kt">:</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如上所示，累加參數增長起來愈來愈多 – 空間洩漏。解決方法就是將累加參數保持在 WHNF，下面的修改過的<code>foldl</code>函數就能做到這一點：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl&#39;</span> <span class="n">f</span> <span class="n">a</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl&#39;</span> <span class="n">f</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="n">f</span> <span class="n">a&#39;</span> <span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>這個函數的定義可以在 <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:foldl-39-">Data.List</a> 模塊裡找到。現在求值過程變成了這樣：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">2</span><span class="kt">:</span><span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在求值的時候，可以看到表達式佔用的空間不再不斷增長下去了。用<code>seq</code>能確保累加參數總是先求值到 WHNF 然後才考慮剩下的元素。</p>

<p>憑經驗來看，<code>foldl</code>會導致空間洩漏，所以你應該用<code>foldl'</code>或者<code>foldr</code>。</p>

<p>順便一提，對於貪婪求值語言，你根本用不著寫上面這種代碼來求和<code>1</code>到<code>100</code>之間的數。因為貪婪求值會先把列表<code>[1..100]</code>規約到模範式，這樣子的空間效率佔用和我們上面低效的<code>foldl</code>版本一樣。要是想要做到高效率，那你必須把這個表達式寫成遞歸循環（Recursive Loop）才行。但得益於惰性求值，在 Haskell 裡，我們可以用通用的列表組合子<sub>2</sub>來「按需」對<code>[1..100]</code>計算。也就說明了惰性求值怎樣帶來更高的模塊化效果。</p>

<p>這個例子裡我們還要注意到另一個重要的概念。我上面演示的求值過程並非完全準確，如果我們這樣定義<code>[n..m]</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">enumFromTo</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="kr">then</span> <span class="n">n</span> <span class="kt">:</span> <span class="n">enumFromTo</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">m</span> <span class="kr">else</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那麼規約到 WHNF 其實是這樣的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">1</span> <span class="kt">:</span> <span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中第一個參數是待求值表達式<code>(1+1)</code>而非<code>2</code>。在這裡這倒沒有多大關係，關鍵是你要非常小心才能精確追蹤惰性求值過程 – 它也許並不一定按你理想當然地來。真正的<code>enumFromTo</code>的<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#verbatim-226">源碼實現</a>並不是這樣的。特別地，請留意<code>[1..]</code>，它會構建一列<em>不</em>屬於 WHNF 的數。</p>

<p>事實上，我只能說，除非是對像上面這樣簡單的例子，要仔細追蹤惰性求值過程幾乎不可能。所以很難去分析 Haskell 的空間佔用情況。我的建議是只有在你的程序出現嚴重的空間洩漏時才去分析它，用<a href="http://stackoverflow.com/a/3276557/403805">性能分析工具</a>來找到問題產生的源頭所在。一旦確認了問題源頭，就可以用 <a href="http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html">Space invariants</a> 和<code>seq</code>來確保相關表達式被規約城 WHNF，而無須管惰性求值具體是怎樣工作的。</p>

<p>這就是我今天要講的關於惰性求值和它空間佔用相關的內容了。其實還有另外一個有代表性的空間洩漏的例子，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">let</span> <span class="n">small&#39;</span> <span class="ow">=</span> <span class="n">fst</span> <span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="n">large</span><span class="p">)</span> <span class="kr">in</span> <span class="o">...</span> <span class="n">small&#39;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>即使<code>fst</code>函數會把<code>large</code>丟棄，表達式<code>small'</code>還是會保存一個到<code>large</code>的引用。你可能會希望在某個時候把<code>small'</code>規約到 WHNF，這樣<code>large</code>所佔的空間就可以被釋放掉了。</p>

<hr />

<p><strong>譯注：</strong></p>

<ol>
  <li>其實不太一樣，<code>const</code>的類型是<code>a -&gt; b -&gt; a</code>。這裡應該說<code>seq</code>的類型和<code>flip const</code>類似。</li>
  <li>這裡指<code>foldl</code>，<code>foldl'</code>和<code>foldr</code>這些函數。</li>
</ol>

<p>（聲明：此文章的翻譯及發佈已經經過原文作者的許可。此譯文版權歸譯者所有，並在 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 下發佈）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function Calling Syntax]]></title>
    <link href="http://shouya.github.io/blog/function-calling-syntax/"/>
    <updated>2014-08-03T17:59:14+08:00</updated>
    <id>http://shouya.github.io/blog/function-calling-syntax</id>
    <content type="html"><![CDATA[<p>We use programming languages to indicate a process of
actions/computations. Therefore programming languages tends to be more
procedual. In other words, they are used to indicate how a thing is
done.</p>

<p>Just as the role of verbs in a nature language sentence, an action is
the most essential part of ‘doing a task’ in programming language. Of
course the syntax of a programming language could be complex. I’d be
here to discuss only the simplest cases of function calling among
different programming languages.</p>

<!-- more -->

<p>Here’s a table of the terms used in different paradigms.</p>

<table>
  <thead>
    <tr>
      <th>Paradigm</th>
      <th>Term for the Acting Object</th>
      <th>Term for the Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Imperative</td>
      <td>Function/Procedure</td>
      <td>Call/Invoke</td>
    </tr>
    <tr>
      <td>OO</td>
      <td>Method</td>
      <td>Invoke/Send Message</td>
    </tr>
    <tr>
      <td>Functional</td>
      <td>Function/Closure</td>
      <td>Apply</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>Operation</td>
      <td>Act</td>
    </tr>
    <tr>
      <td>Lambda Calculus</td>
      <td>Lambda/Combinator</td>
      <td>Apply</td>
    </tr>
  </tbody>
</table>

<h2 id="object-oriented-languages-ruby-c">Object Oriented Languages (Ruby, C++)</h2>

<p>OOP is an analog of object manipulation in the real world. Actually,
semantically <code>foo.bar(baz)</code> does not mean <code>foo</code> does an action <code>bar</code>
on <code>baz</code>. Rather, according to the OOP mechanism, it should be
regarded as a message <code>bar</code> send to the actor <code>foo</code> with argument
<code>baz</code>. Look at the code snippets below in Ruby and C++.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="vg">$stdout</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>How would we translate them in English? The result is probably similar
to these:</p>

<blockquote>
  <p>(The computer) puts “hello” on $stdout.</p>

  <p>(The computer) pushes “hello” into vec.</p>
</blockquote>

<p>In such invocations, obviously the subject is uslally omitted because
we’re always ordering the computer to do the actions.
The receivers, or target objects, are put at the front. Then
follows the actions we want to apply on them. And finally the
arguments, or carried objects.</p>

<p>Notice that the in Ruby the object is often omitted because it is
implied in the current context (<code>self</code>). And in C++ <code>this</code> is
sometimes omitted if we’re operating in a method within the same class.
It is similar to the case omitting object in a nature language when
we’re in a specific environment. For example, if we are working on a
task and then we say ‘finished’, the object can be understood as the
task we were working on.</p>

<h2 id="stack-basedconcatenative-languages-dc-factor-assembly">Stack-based/Concatenative Languages (dc, Factor, Assembly)</h2>

<p>The core of stack-based languages is the operation on a stack involves
pushing and popping.</p>

<p><code>dc</code> is a tiny calculator. The language of it is succinct and handy. Here’s an example:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="o">[</span>hello<span class="o">]</span>p
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The square brackets quotes a string of characters and push them into a
stack. Then the operation <code>p</code> pops the string out and then prints it.</p>

<p>Stack-based language can be as simple as dc, while also can be as
complex as Factor. Yet either of them have the same syntax
structure. The following Factor code reverses an array.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="n">reverse</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We cannot directly translate them into one sentence of nature
languages because the invocation of a function should not be regarded
as a single process. As how we can see the process more clearly in
Assembly language:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">push</span> <span class="mh">0x0001</span>   <span class="p">(</span><span class="mh">0x0001</span> <span class="n">points</span> <span class="n">to</span> <span class="s">&quot;world&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">push</span> <span class="mh">0x0010</span>   <span class="p">(</span><span class="mh">0x0010</span> <span class="n">points</span> <span class="n">to</span> <span class="s">&quot;hello, %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">call</span> <span class="mh">0x0100</span>   <span class="p">(</span><span class="mh">0x0100</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="err">`</span><span class="n">printf</span><span class="err">`</span> <span class="n">function</span> <span class="n">in</span> <span class="n">libc</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The invocation of such functions can be seen as a kind of
argument-free operation. Their arguments are pushed to stack before
the function invocations and in the function the arguments would be
popped out to be manipulated.</p>

<p>If we still want to see the process of invocation as a single, we
would derive a pattern that the actions, or the verbs, are always put
at the last.</p>

<h2 id="functional-languages-scheme">Functional languages (Scheme)</h2>

<p>I consider the syntax of function invocation an opposition to the
stack-based languages. Unlike the invocation syntax in stack-based
languages, which put the action at the last, functional programming
languages tend to pose the action/function as precedent to the
arguments. I guess this phenomenon originates from the application
syntax of FP’s ancestor lambda calculus.</p>

<p>In Scheme, a typical hello world program looks like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scheme"><span class="line"><span class="p">(</span><span class="nb">display </span><span class="s">&quot;hello world&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It just looks like the stack-based language. In fact we can convert
functional operations into stack operations through
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation-passing style transformation</a>,
so easily convertible into Assembly. In fact this technique is often
used in Scheme compilers.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://factorcode.org/">Factor Programming Language</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Whitespace_(programming_language)">WP: Whitespace (PL)</a></li>
  <li><a href="http://www.linuxmanpages.com/man1/dc.1.php">dc (1) - man</a></li>
  <li><a href="http://concatenative.org/wiki/view/Concatenative%20language">Concatenative Languages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Stack-based">WP: Stack-based</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Stack-oriented_programming_language">WP: Stack-oriented Programming Languages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Word_order">WP: Word Order</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻譯：如何幸福起來]]></title>
    <link href="http://shouya.github.io/blog/how-to-be-happy/"/>
    <updated>2014-07-28T22:17:07+08:00</updated>
    <id>http://shouya.github.io/blog/how-to-be-happy</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文由 lukeprog 發表於 <a href="http://lesswrong.com/lw/4su/how_to_be_happy/">LessWrong</a>。
關於注釋和引用，請參見原文。</p>
</blockquote>

<p>有一天一個同事對我說：「盧克，你應該是我見過的最幸福的人了！你怎麼做到每時每刻都這麼開心的？」</p>

<p>他可能只是在誇張修辭，不過我還是回答了很長。曾經的大部分人生是不令我開心的，我甚至好幾次考慮過自殺。然後我花了兩年研究幸福科學。而現在，幸福是我的自然狀態。我甚至都不記得甚麼時候我有達 20 分鐘以上的不開心過。</p>

<p>這類改變並非人人都會有，甚至大部份人都不會有（<a href="http://lesswrong.com/lw/9v/beware_of_otheroptimizing/">beware of other-optimizing</a>），但不妨一試！</p>

<p>我們都希望開心些，而且變得開心對其他事情也有好處。譬如說，開心有利於人的身心健康，能提高創造力，還能使你更好地做決定。（畢竟當一個人不開心時很難做到理性思考。）所以呢，本篇作為<a href="http://lesswrong.com/lw/3nn/scientific_selfhelp_the_state_of_our_knowledge/">如何</a>系列的一部分，讓我們回過頭來審視一下<strong>幸福科學</strong>。</p>

<!-- more -->

<h2 id="section">幸福的因素</h2>

<p>以前，我就留意到過有很多關於 <em>主觀狀態</em> 因素的研究（自己對自己幸福和生活滿意度的評價）。</p>

<p>但僅僅是相關性的研究遠遠不夠，我們還希望知道是甚麼 <em>導致</em> 了幸福。這一點很難測評，但是我們還是知道一點的。</p>

<h2 id="section-1">幸福，性格，以及技能</h2>

<p>內在因素決定了大約 50% 的幸福度差異。可能結果令人意外，中彩票的人和剛剛四肢癱瘓的患者並不像想像中的那樣誇張地變得狂喜或沮喪。所以，我們認為內在因素決定幸福感程度，表現在性格的塑造上，而據研究，性格的很大一部份來自遺傳。</p>

<p>所以哪種性格特徵和幸福感相關度最高呢？內向和外向是最佳的幸福感指示計，類似的還有自身嚴謹程度，他人認同度，自尊，以及樂觀程度。</p>

<p>那麼如果你沒有這些性格特徵呢？首先要說的是，你可能可以在不知道自己已經達成目的的情況下實現擁有這些令你幸福的特徵。譬如說，內向可能會看做一種 <em>社交技能的缺失</em>。如果你決定開始<a href="http://www.amazon.com/Social-Skills-Picture-School-Beyond/dp/1932565353/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131103628&amp;linkCode=as2&amp;tag=lesswrong-20">學習</a>提高自己的社交技巧，那麼你會發現你比想像中的自己要外向多了！（此乃親歷者談。）類似的，你都能做得到提高自己謹慎度，他人認同度，自尊，以及樂觀程度。這些都僅僅是和性格關聯，而非被性格決定的。某種程度上你都可以學習（或者甚至只是單單模仿）這些技巧來提高自己的幸福感。</p>

<p>第二點要說的呢，如果你缺乏這些性格特徵，並不一定會讓你不幸福。</p>

<h2 id="section-2">幸福是主觀的和對比性的</h2>

<p>幸福感並不由客觀因素決定，而是由你的主觀 <em>感受</em> 決定。</p>

<p>幸福同時也是對比性的。在山西太原你可能月入五千元（太原人平均月收入三千元）就可以達到比上海月收入八千元（上海人均月收入一萬元）要幸福得多。(注)</p>

<p>當然幸福和其他因素也有關。譬如說你的 <em>期望</em> 。我們非常不擅於預測我們未來的能力。我們常常高估失戀，升職失敗或得病帶來的傷痛程度。我們也常常高估這類，譬如說炒股賺錢，升職，或者買到超值大禮包帶來的快樂。所以為了變得更幸福，最好降低對這類快樂的期望值。</p>

<p>(譯注：此處數據為捏造，僅僅為了傳達作者希望表達的意思。)</p>

<h2 id="section-3">神馳和注意意識</h2>

<p>你可能聽說過一些著名的研究表明人們在「<a href="http://en.wikipedia.org/wiki/Flow_(psychology)">神馳</a>」的狀態下是最幸福的。當人專注於某項有趣的，有挑戰性的，從根本上帶來成就感的工作時，就會進入一種稱之神馳的狀態。換句話說，就是「忘乎自我」，或者如運動員常講的，「進入狀態」。</p>

<p>你需要做和你的技能相符合的工作來找到你的「神馳」狀態。當工作太難，你會被矬敗。而當工作太容易，你會覺得無聊。只有那些具有挑戰性卻又能夠完成得了的工作會讓你感覺很棒。這令我想起了 <a href="http://www.youtube.com/watch?v=2-9D2qUHN-E">Super Trooper</a>，她是一個薯片廠的工人，在無聊的工作中，她會收集那些碰巧和名人的臉長得有幾分相似的薯片來玩。</p>

<p>如果你正在被負面情緒困惑，那麼進入神馳的狀態可能是最有效的良藥。和大眾的直覺相反，強迫自己進行積極正面的思考往往會適得其反。自己讓自己不想不開心的事情是不可能的。如果你刻意讓自己不想著這件事，你就會下意識強調這點，繼而你又會情不自禁地想起這件事了。</p>

<p>在處在「忘乎自我」的時候，你的幸福感會非常高。然而研究表明，當你無法進入神馳態時，「注意意識」也能有效減少慢性病痛和抑鬱帶來的痛苦，減少壓力和焦慮，還有一系列其他積極的效果。要達到「注意意識」就要踏出你在做的事情一步，除了關心你在做的事情之外，還注意到自己的當前狀態，留意當前的動作，想法，感受等等。</p>

<h2 id="section-4">如何愈來愈幸福</h2>

<p>綜上，幸福一件超級複雜的事情。其實甚至更麻煩，我們還要區分開<a href="http://www.ted.com/talks/daniel_kahneman_the_riddle_of_experience_vs_memory.html">體驗性幸福和記憶性幸福</a>，但在這篇短文中我只能稍稍提及一些皮毛。總之，天堂無捷徑，沒有辦法能讓你在三分鐘內永原和悲傷告別。</p>

<p>此外，不同的人有不同的幸福起來的方法。抑鬱症是由於體內化學物質不平衡導致的，所以對他們而言可能吃藥必學習社交技巧更有效。而即使一個健康，外向，謹慎且受人認同的女人，如果和不合適的人結婚，也許也會不那麼幸福。一些在父母不注意培養健康的自尊發展的環境下成長的孩子，還要花費巨大的精力重新拾回自己缺失的東西。對一些人而言，幸福之路悠長；而對另一些人而言，幸福卻容易很多。</p>

<p>下面我將給出並評論一些對提升幸福度有關的方法，有一部份上面已經提到了，還有很多沒有提到的。</p>

<p>這些方法大概以從重要和效果明顯到不那麼重要和效果不那麼明顯排序，給於我自己對幸福科學的學習理解。你需要自己想清楚的是你自己究竟是誰，甚麼令你開心，甚麼令你難過，還有下面哪些方法對你來說採取起來最便捷。同時，這些方法對<a href="http://lesswrong.com/lw/3w3/how_to_beat_procrastination/">治療拖延症</a>也有不錯的效果。</p>

<p>下面是十四個令你愈來愈幸福的方法：</p>

<ol>
  <li>如果你有心理疾病，譬如抑鬱症，焦慮症，健忘，精神分裂，或者其他問題，<em>請先諮詢專家尋求幫助</em>。<a href="http://www.liveyourlifewell.org/go/live-your-life-well/help">這裡是一些指引</a>。</li>
  <li>即使你不需要專家協助，你也可以受益於一些自我探索，或者聽從一些像 <a href="http://naturalism.org/consulting.htm">Tom Clark</a> 一樣的簡化主義者，自然主義者諮詢師給的 <em>開始階段的指示</em>。</li>
  <li>開發 <em>外向</em> 相關的技能和習慣。首先，買一些得體的衣服並學習優雅的著裝。如果你是男孩子，<a href="http://www.amazon.com/Details-Mens-Style-Manual-Ultimate/dp/159240328X/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131103628&amp;linkCode=as2&amp;tag=lesswrong-20">讀讀</a>起來。</li>
  <li>學會變得 <em>自尊</em> 和 <em>樂觀</em> 起來。這可能有點微妙。首先，太過自尊會導致有害的自戀。其次，理性主義者可能會不習慣採用一些標準方法（偏向自我性思考，誇大自己的光榮一面，把自己想得更弱）來欺騙自己或者<a href="http://wiki.lesswrong.com/wiki/Anti-epistemology">違背自我認識</a>描述的一樣。</li>
  <li>提升你的認同度。簡單來說，增強你和他人的共鳴（empathy）能力。但很不幸現在還沒有這類有效的（科學）方法。一般的建議是試試從他人角度看待問題，多替別人著想，把他們想作比自己不幸的人。<a href="http://www.rootsofempathy.org/">共鳴之源</a>供參考。</li>
  <li>變得嚴謹起來。嚴謹的性格對很多事情都有幫助，譬如組織事務，工作勤勉，可靠度，計劃能力等等。<a href="http://lesswrong.com/lw/3w3/how_to_beat_procrastination/">克服拖延症</a> 之類的書籍也對他們的組織性和可靠的鍛鍊有所幫助。</li>
  <li>培養感恩的習慣。珍惜生活的每一刻。多花時間想一下開心的回憶。每天結束前，列出五樣你感謝的對象，頭頂的屋頂，活在一個富裕的國家的運氣，此網站（Less Wrong）的存在，巧克力的美味，高潮的快感等等這些。無論如何，雖然聽起來很幼稚，但是的確有效。</li>
  <li>找出你的生活的 <em>目的</em> 並且為之生活。宗教帶給人的好處之一在於給人們一種活著的意義和目的。並不需要神的啟示，你要自己確定好是甚麼驅使著你。你可能要在這上面花點工夫，各個領域都要考慮。當你找到一條能使你充滿動力的路，那就順著它走吧。（當然，你也可能找到很多生活的目的。）有目的，有追求的意義，這樣有很多好處。「尋找你生活的目的」描述了針對不同人的不同的方法。這點不會在幸福文學作品被強調，但對我自己而言，尋找出使我充滿動力的生活目的確確實實改變了我的人生。</li>
  <li>找個 <em>充實</em> 的工作。極少人在以自己喜愛的事情為職業維持生計。做到這點可能非常困難。你可能留意到這個列表上的其他十件事情都 <em>首先</em> 要求你有一個充實的工作。要找出你究竟喜愛甚麼和適合甚麼工作，做一個 <a href="http://www.bigjobportal.com/riasec/">RIASEC</a> 也能幫你找到一個熱門的並符合你性格的工作。
在美國，<a href="http://www.onetonline.org/">O*NET</a> 也能幫妳找到一個熱門的並符合妳性格的工作。</li>
  <li>增進和你的 <em>戀人</em> 的感情，要麼就再找一個。如找一個充實的工作一樣，這一點也很難做到，但能帶來很大影響。如果你總是覺得你們之間的關係平淡而且沒有提升的空間，你可能會想要把愛情放置一邊並自己一個人工作，然而這會導致你們之間關係進一步惡化。如果你是認真對待你的戀人的，那麼你可以有很多方法來提升你們之間的關係。雖然<a href="http://zh.wikipedia.org/wiki/%E7%A9%8D%E6%A5%B5%E8%81%86%E8%81%BD">積極聆聽</a>的方法被廣為接受，它並不能保證維持良好的關係。被實驗確認的有助於提升滿足感的方法有：(1) 經常和你的戀人做些新奇的事情，(2) 向你的戀人聊積極的事情的次數要超過消極事情 5 倍以上，(3) 每週寫下你認為你和你的戀人之間優於其他人的原因，(4) 接受所有你的戀人提出的批評並附以一兩條對他好的地方的誇讚，以及 (5) 常常和對方的眼睛對視。</li>
  <li><em>出門</em>，讓你的身體動起來。這樣可以培養你的注意力，並且對你的身體也有好處。</li>
  <li>多花些時間處在 <em>神馳</em> 狀態。放棄一些超過你能力的，不可能的任務。並把簡單無聊的任務變得有挑戰起來，你可以通過把這些工作變成遊戲，或者自己在裡面添加額外的挑戰。</li>
  <li>養成 <em>鍛鍊注意意識的習慣</em>。當你無法進入神馳的工作狀態的時候，走出你自己的工作，專注你的做法，行為，手段，你的心理機能，以及留意你是如何把這些工作的動作轉換並達成你的目標的。<a href="http://www.wikihow.com/Meditate">冥想</a>也許有用。</li>
  <li><em>避免消費主義洗腦</em>。你不能讓你擁有的東西反過來控制你。消費主義帶來的更多是不開心。很不幸的是，自從你出生，你就被活在這樣一個消費主義時代。要希望扭轉這一點，你可以看看 <a href="http://en.wikipedia.org/wiki/Edward_Bernays">Edward Bernays</a>。在那之後，你也許會把很多物品賣掉或拿去送人，更重要的是，這能徹底改變你的購物習慣。</li>
</ol>

<p>注意，把尋覓幸福當作 <em>目標</em> 可能會帶來反效果。很多人都說自己在不斷檢查自己是否幸福的時候下變得反而沒那麼幸福了 – 有點像「神馳」的時候一樣。倒不如找一個實際目標作為終點，而幸福作為其副作用就好了。</p>

<p>記住：只是在網路上讀這篇文章永遠不會帶給你幸福。只有當你去為幸福去 <em>實踐</em> 這些研究結果的時候，你才能感受到它。</p>

<p>祝好運！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 下 GFW 的 DNS 投毒解決方案]]></title>
    <link href="http://shouya.github.io/blog/dnscrypt-plus-dnsmasq-solution/"/>
    <updated>2014-07-26T02:27:35+08:00</updated>
    <id>http://shouya.github.io/blog/dnscrypt-plus-dnsmasq-solution</id>
    <content type="html"><![CDATA[<p>這篇日誌紀錄我在 Gentoo Linux 下配置 DNS Crypt + DNSmasq 的過程。</p>

<h2 id="section">方案</h2>

<p>DNSCrypt 是 OpenDNS 推出的一個用來加密 DNS 請求的代理，我用這個來繞開 GFW 的檢查。dnsmasq 是一款的 DNS 服務器，我主要用其提供 DNS 緩存的功能。</p>

<p>我將用 dnsmasq 設置本地的 DNS 服務器，然後配置 dnsmasq 從 dnscrypt 獲得結果並返回給請求者。而 dnscrypt 會把來自 dnsmasq 的請求加密丟到 opendns 的服務器，然後把解析結果返回回來。</p>

<p>那麼 dnsmasq 將偵聽 <code>53</code> 端口，而 dnscrypt 的端口隨意，只要和 dnsmasq 裡的配置匹配就可以了。我隨便用了 <code>1053</code> 作為 dnscrypt 的端口。</p>

<p>最後，把系統的 DNS 服務器設置為本機就可以了。</p>

<!-- more -->

<h2 id="section-1">背景</h2>

<p>長期以來我都在使用 <a href="https://code.google.com/p/openerdns/">Opener DNS</a> 提供的免費 DNS 服務器
<code>42.120.21.30</code>，這個服務器工作正常，響應速度也很快，但是我在使用中遇到一個不知怎麼解決的問題而頭疼。那就是，很多 CLI 工具，包括
wget 和 curl，在設置了 Opener DNS 為 DNS 服務器後，都無法解析出任何地址，然而另一些工具，包括 nslookup 和
dig 等，卻沒有任何問題。而當切換為其他 DNS 服務器之後，wget 和 curl
之類的卻又可以正常解析了。這是很奇怪的現象，導致我後來連 emerge 都要開著 proxychains，甚是不方便。</p>

<p>今天下午心血來潮想隨手把這個問題解決掉。首先考慮的是用 iptables 把 GFW 發回來的假的 DNS
請求結果丟掉，只留正常的結果。網路上這種資源不少，我四處抄來抄去縫縫補補拼了一份 iptables 的配置，並丟在
<a href="https://gist.github.com/shouya/c798a3aa7fb9a2a9b7fa">Gist</a> 上了。但問題是，好像 GFW
不光返回假的 DNS 結果，有時還回丟棄正確的結果，因為常常 DNS 請求只會返回假的結果，被 iptables
丟棄後導致請求超時，反而沒有效果。這種方法不能保證工作，而且速度很慢。</p>

<p>經測試 DNS over TCP 效果不錯，速度快而且相對穩定。所以我試了一下用 pdnsd 代理所有 DNS 請求並用 TCP 查詢上游 DNS
服務器。但是當我安裝了 pdnsd 之後，不知哪裡出錯了，總是在其偵聽本地端口時提示兩個</p>

<pre><code>[Errno 97] Address family not supported by protocol
</code></pre>

<p>錯誤，怎麼配置都不行，無論是 example 裡的還是 minimal 都無法解決。看起來可能是我系統配置的問題，或者是 pdnsd 的
bug。但我不是很確定到底怎麼回事，而且網路上好像沒有人有類似的情況，所以也不好上報。</p>

<h2 id="dnscrypt">安裝配置 dnscrypt</h2>

<p>首先在 gentoo 的官方 portage 源裡並沒有 dnscrypt-proxy 這個程式， 所以需要手動加入 gentoo-zh 這個
overlay。 關於怎麼添加使用 overlay 這裡就不詳述了。</p>

<p>所以是常規地：</p>

<pre><code>$ sudo emerge -av dnscrypt-proxy
</code></pre>

<p><code>dnscrypt-proxy</code> 會依賴於一個叫 <code>libsodium</code> 的庫。</p>

<p>在我的機器上 <code>libsodium</code> 和 <code>dnscrypt-proxy</code> 編譯時（準確說應該是<code>configure</code>的時候）會出一個錯誤：</p>

<pre><code>checking if gcc -std=gnu99 static flag -static works... *** Error in `/usr/bin/ld': corrupted double-linked list: 0x099a4178 ***
</code></pre>

<p>在 Github 上看到有人同樣遇到了 libsodium 的<a href="https://github.com/jedisct1/libsodium/issues/120">這個問題</a>，原因是 gcc 的 <code>-pie</code> 和 <code>-static</code> 不兼容，
而解決方法是在 <code>configure</code> 時禁用 <code>pie</code> 就好了。所以手動改這兩個包的 ebuild 文件，在 <code>econf</code> 最後加上 <code>--disable-pie</code>。
於是兩個包都可以被編過了。改過後再 ebuild 一次 manifest，就可以正常安裝這兩個包了。</p>

<p>dnscrypt 的配置位於 <code>/etc/conf.d/dnscrypt-proxy</code>，編輯使之偵聽於 <code>1053</code> 端口。我的配置如下：</p>

<pre><code>DNSCRYPT_LOCALIP=127.0.0.1
DNSCRYPT_LOCALPORT=1053
DNSCRYPT_USER=dnscrypt
DNSCRYPT_PROVIDER_NAME=2.dnscrypt-cert.opendns.com
DNSCRYPT_PROVIDER_KEY=B735:1140:206F:225D:3E2B:D822:D7FD:691E:A1C3:3CC8:D666:8D0C:BE04:BFAB:CA43:FB79
DNSCRYPT_RESOLVERIP=208.67.220.220
DNSCRYPT_RESOLVERPORT=443
</code></pre>

<p>基本就是默認配置。</p>

<p>把 dnscrypt 跑起來：</p>

<pre><code>$ /etc/init.d/dnscrypt-proxy start
</code></pre>

<p>然後用 dig 測試之是否工作：</p>

<pre><code>$ dig @127.0.0.1 -p 1053 twitter.com
</code></pre>

<p>如果得到正確結果，則說明 dnscrypt 配置好了。</p>

<h2 id="dnsmasq">安裝 dnsmasq</h2>

<p>安裝：</p>

<pre><code>$ sudo emerge -av dnsmasq
</code></pre>

<p>因為我幾乎不怎麼用國內服務，所以也用不著為國內服務設置國內的 DNS 來提高效率。所以我用 dnsmasq 純屬為了其緩存。</p>

<p>dnsmasq 的配置位於 <code>/etc/dnsmasq.conf</code>，這是我的配置：</p>

<pre><code>no-resolv
no-poll
server=127.0.0.1#1053
</code></pre>

<p><code>no-resolv</code> 讓 dnsmasq 不去理睬 <code>/etc/resolv</code> 裡的配置。<code>no-poll</code> 讓其不檢測更新。<code>server</code> 裡對應的是 dnscrypt 的本地端口。</p>

<p>這樣就可以了，跑起來：</p>

<pre><code>$ /etc/init.d/dnsmasq start
</code></pre>

<p>試試：</p>

<pre><code>$ dig @127.0.0.1 -p 53 twitter.com
</code></pre>

<p>沒問題的話就說明 dnsmasq 已經工作了。</p>

<h2 id="section-2">完成</h2>

<p>設置系統 DNS！</p>

<pre><code>$ echo nameserver 127.0.0.1 | sudo tee /etc/resolv.conf
</code></pre>

<p>所以下一步，開機啟動來一發！</p>

<pre><code>$ sudo rc-update add dnscrypt-proxy default
$ sudo rc-update add dnsmasq default
</code></pre>

<p>搞定，去玩吧。</p>

<h2 id="section-3">參考資料</h2>

<ul>
  <li><a href="https://github.com/jedisct1/libsodium/issues/120">Issue #120: arch linux i686 build errors: corrupted double linked lists - jedisct1/libsodium</a></li>
  <li><a href="http://blog.sina.com.cn/s/blog_656126b20101ia39.html">详细安装配置 dnscrypt 和 dnsmasq</a></li>
  <li><a href="http://lilydjwg.is-programmer.com/2012/11/10/dnscrypt-dnsmasq.36288.html">dnscrypt + dnsmasq</a></li>
</ul>

<h2 id="section-4">一些可能有用的鏈接</h2>

<ul>
  <li><a href="https://code.google.com/p/openerdns/">Opener DNS - Google Code</a></li>
  <li><a href="http://www.opendns.com/about/innovations/dnscrypt/">DNSCrypt - OpenDNS</a></li>
  <li><a href="http://en.wikipedia.org/wiki/DNS_spoofing">DNS spoofing - Wikipedia</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#.E4.B8.AD.E5.9B.BD.E9.98.B2.E7.81.AB.E9.95.B7.E5.9F.8E">域名伺服器快取污染 - 維基百科</a></li>
  <li><a href="http://igfw.net/archives/10890">如何本地避免GFW的DNS污染</a></li>
  <li><a href="https://gist.github.com/wen-long/9580811">Gist: wen-long/DNS.md</a></li>
  <li><a href="https://wido.me/sunteya/use-openwrt-resolve-gfw-dns-spoofing">openwrt 上通过 pdnsd 和 dnsmasq 解决 dns 污染</a></li>
  <li><a href="http://www.v2ex.com/t/75568">dnsmasq如何强制用tcp与上游dns服务器通讯？</a></li>
  <li><a href="http://mariotaku.wordpress.com/2011/09/18/use-dnsmasq-easier-than-pdnsd/">比pdnsd更更更简单！用dnsmasq给你正确的DNS结果！</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Brief Journal About Learning Coq]]></title>
    <link href="http://shouya.github.io/blog/a-brief-journal-about-learning-coq/"/>
    <updated>2014-07-05T01:08:34+08:00</updated>
    <id>http://shouya.github.io/blog/a-brief-journal-about-learning-coq</id>
    <content type="html"><![CDATA[<p><em>This article is completely an informal journal about my learning process on
Coq. It is just created as my whim prompted. Please don’t academically refer
any part of it as studying material to learn Coq.</em></p>

<h2 id="pre">Pre</h2>

<p>I first heard of Coq in my admiring mathematician,
<a href="https://twitter.com/txyyss">@txyyss</a>’s tweets. At the time I saw him talked
that he’s glad and immersed in re-proving all the theorems he had learned.
He also said, as deepening in Coq, he found a boost on other related
academic aspects. Driven by curiosity, I went to know about what a heck Coq
is. Then I saw it describe itself as a ‘Proof Assistant’. I felt something
uneven about it. Looking through all the programming languages I had
learned, even those as logically abstract as Prolog, were not capable to do a
proof.</p>

<!-- more -->

<p>At the time I was still in my high school. I just downloaded a Coq environment
on my
machine in the computer lab. Then I tried to follow the
<a href="http://coq.inria.fr/V8.1/tutorial.html">official tutorial guide</a> to explore how
to use it to do a proof. The experience was terrible. The official tutorial
was
completely not-novice-friendly, at least to me. I followed it for a section,
doing what the guide instructed me to do, and they all works. I learned <code>0</code>
has a
type of <code>nat</code>, and <code>nat</code> has a type of <code>Type</code>, and that’s all, no more things
substantial. The following sections are tough enough so I don’t even know what I
was doing. Thus I gived it up.</p>

<p>My curiousity was evoked the second time by the <span title="狂讚士">“berserk-faver”</span> <a href="https://twitter.com/javranw">@javranw</a>. He
express similar opinion and excitement as @txyyss towards Coq. At the time it
was the onset of the long summer vacation after high school graduation. I got
plenty of free time to learn the extracurricular interesting stuff. So I
decided to pick Coq up again.</p>

<h2 id="on">On</h2>

<p>This time I found a Virginia University course about Coq, published as
<a href="https://www.kevinjsullivan.com/00-syllabus">website</a>:
I decide to start here because I
saw the syllabus are well arranged and besides, I thought the course material
might be easier for a layman to get started.
([link to the tutorial]
(http://kevinjsullivan.org/Courses/Reasoning/L02_Intro.html))</p>

<p>The study curve of this course seems still steep. In the other words, the
course goes complicated soon after it teaches some common-sense-like
knowledge that I can hardly catch up with it. Besides, I don’t think the
guide is written in obvious and clear language.</p>

<p>I had also checked the well-known
<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/">Software Foundations</a>. And
I discovered it’s actually more clear and friendly to novice like me. So I head
on to study following this guide.</p>

<p>The progress was slow. While a few of the exercises, mostly rated 3+
stars, are really challenging. I tried to work on all exercises myself. And I
maintained a <a href="https://github.com/shouya/sf-sol">Github repository</a> to publish
my solutions.</p>

<p>I usually study it after midnight. So I could have a quiet and distract-free
environment for me to think. I was concentrated while doing the proofs. It
feels good. Especially after proving a difficult theorem, I acquired great
pleasance from the accomplishment. I can’t describe the the feeling as I
first proved the commutation law of multiplication, which took me about 3 hours.</p>

<p>In fact, in each new chapter I learned something new about Coq. Yet, as I
turned to the chapter of
‘<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/Logic.html">Logic</a>’, I learned
not only about Coq skills but also a mode of critical thinking towards the
base, the logic, and the logic of logic. I learned the logic system also need
an axiom, which subverted my view to logic before. A logical proposition can
either be true or false, and besides, it cannot guarantee to be in one of these
two states only. This axiom that establishes the whole logic system can be
expressed in many forms. An optional exercise in the guide is to prove they are
equivalent. Rated full 5 stars, this question is the most difficult exercise
I’ve met. Anyway I still finished 4/5 of it.</p>

<h3 id="sequela">Sequela</h3>

<p>I once tweeted (translated into English)
<a href="https://twitter.com/54c3/status/478478760371429376">link</a>:</p>

<blockquote>
  <p>I just dreammed in the nap. In the dream there was an arena-like place. The
fighters used with logic symbols as weapons. They battled, and exerted
various tactics. As a round over, they proved some theorem. #dream #coq
#broken_brain</p>
</blockquote>

<p>Really. My mind is full of logics in the days I study Coq. I can feel it
vividly that my mind start to ask about the logic of everything I see. Logic
would spring from my mind on every affairs. That is very interesting experience.
Especially after immersed in Coq for a whole night, I see everything and think:
can I prove it?</p>

<p>Somewhat I like that feeling :)</p>

<!--

Of course I still put my girlfriend Cres in the first position. I tried to
spare some times accompanying with her. But to do this I have to convince
myself in a illogical way (because there is no logic): my emotion will
nevertheless take all control of my flesh body than my ration in coping with
matters related to my girlfriend. So I stop thinking about Coq while chatting
with her.

I will have various affections while talking to her. However,
after she sleep and I get back to the world of Coq, every emotional sense just
go vain.

Oh... I can't let Cres know about this... She'll think that I'm belittling her.
Actually I'm regarding her in the most important position to me. Anyway. I'll
just comment it out. Nobody will read this paragraph :)

-->

<h3 id="intelligence">Intelligence</h3>

<p>In an ideal condition, to prove a theorem, I will first understand the theorem
itself, and conceive a way to prove it. Then I’ll translate the idea into
tactics in Coq. However, as I got more and more practiced in Coq, I do not
always follow this way to prove a theorem. For some simple theorems, I can prove
them without understanding them. I know what tactic should be used under
specific condition. I would only concern about the hypotheses and the goals. My
empirical intuition will guide me to the most likely way to prove them.</p>

<p>I first realized the situation while I was proving a theorem related to
<code>override</code> function in the next chapter after <code>override</code> is defined. I then
disinclined to review the definition of <code>override</code> again, because it’s a little
bit convoluting. Naturally I tried to prove it without reviewing the definition
of <code>override</code>. Also naturally I did it successfully. I realized the problem
just as I finished the proof. The first impression I raised is that I felt
panicky on myself. While as I then carefully checked the definition of
<code>override</code> function and the proof process, I found that’s already the optimal
way. I will do exactly the same after I understood the definition.</p>

<p>At that time, I had a sense that I was no longer a human, but a proving
machine. I knew the tactics, and I knew when to use them. Prooving theorems
seemed to be a machinery work. I was somewhat depressed on this kind of
loss-of-intelligence.</p>

<p>However, sometimes I thought in the other way. If I could grasp my empirical
intuition, turn them into substantial rules, can I make a program that can
prove whatever I can prove as a human? The program will never understand a
theorem, but they can prove them in a Coq’ly logical way.</p>

<h2 id="comments-on-the-design">Comments on the design</h2>

<p>I thought the design is the point I want dissing about Coq mostly. Although
powerful, Coq’s design on its syntax is as terrible as its “mother language”
OCaml, and even worse.</p>

<p>It might be improper for me, as a totally novice, to comment on Coq’s design. I
know I’m yet far from qualified to do that. Nonetheless I still want to talk a
little bit about it.</p>

<p>Of course, I know neither syntax nor some mechanism are the most crucial
things to a programming language. However, my steps followed the road of Ruby
→ Scheme → Haskell. Studying those PLs was pleasing, at least they
give me a sense of elegance. In contrast, I see Coq as a work from scratch
than being well designed.</p>

<h3 id="type-naming">Type naming</h3>

<p>Actually, types in Coq are not as obvious as in other PLs. Unusual types
are ubiquitous. I use ‘unusual type’ just because I don’t know how to descibe
them. The nature of each type are not just transparent, but also must be
defined by me manually. (At least I’m instructed to do so following the guide.)</p>

<p>The case of type names, in the beginning, confused me. Why are the type names
<code>nat</code>, <code>bool</code> lower-cased while <code>Set</code>, <code>Type</code>, <code>Prop</code> capitalized? I knew I
won’t know the why of every unknowns just as I touched it. So I memorized it
in a silly mode: names of the types we need to define by ourself are
lower-cased, and the others are capitalized.</p>

<p>This gave me the first intuition about differnet kinds of types.
While then I walked through the guide, and gradually realized the difference
between these two sort of types.</p>

<p>Here’s correct<sup>(?)</sup> understanding about it. <code>nat</code> and <code>bool</code> are
lower-cased because they are <em>inductive</em> types. In the other words, they are
defined in a specific number of cases. Contrarily, we don’t see this feature in
<code>Set</code>, <code>Type</code>, nor <code>Prop</code>, which are what we called <em>non-inductive types</em>.</p>

<h3 id="tactic-naming">Tactic naming</h3>

<p>Well, I shall just pose here the most frequently used tactic names.</p>

<p><code>simpl</code>, <code>reflexivity</code>, <code>destruct</code>, <code>induction</code>, <code>left</code>, <code>rewrite</code>.</p>

<p>Did you see them? The names range among abbreviations, nouns,
verbs, and adjectives. All of them are used as tactic names. While they’re not
funtioning in different categories. They’re really alike. The naming gives me
an impression that they are picked just from the whims of Coq inventors, so
they’re not strict at all. There is no choice that I have to memorize them.</p>

<h3 id="tactic-functioning">Tactic functioning</h3>

<p>It is understandable that tactics function in very different ways. The
behavior of them can sometimes be categorized with different fashions. For
example, some of them will mark a goal as proved so we can continue to next
goal or mark a <code>Qed</code> happily if all goals are proved. I call this feature
‘commit’. This is an informal term invented by me because I don’t know what’s
the accurate terminology for that.</p>

<p>It can be thought to categorize the tactics by whether they commit. But it
doesn’t apply to all the tactics. Now I have to pose three types:</p>

<ul>
  <li>commits: <code>reflexivity</code>, <code>assumption</code>, <code>exact</code>, …</li>
  <li>does not commit: <code>simpl</code>, <code>rewrite</code>, <code>unfold</code>, <code>symmetry</code> …</li>
  <li><span title="看心情">depends on mood</span>: <code>apply</code>, <code>inversion</code>, …</li>
</ul>

<p>Actually, there is an other case, because some tactics will split the goal into
more subgoals. I will put they in an different category.</p>

<ul>
  <li>yields subgoals: <code>assert</code>, <code>replace</code>, <code>destruct</code>, <code>induction</code></li>
</ul>

<p>In fact, these do not always yield a subgoal. The number of subgoals <code>destruct</code>
and <code>induction</code> yield depends on the number of inductive constructors of
the type of the expression they are operating on.</p>

<p>The behavior of inversion is ridiculous. One can conclude its usage as to
simplify the <em>injective</em> case and <em>disjoint</em> case. Even the Software
Foundations guide admits:</p>

<blockquote>
  <p>The inversion tactic is probably easier to understand by seeing it in action
than from general descriptions like the above.</p>
</blockquote>

<p>Surely, it’s not difficult to use. I will list the places it usually applys. Of
course these are just empirical conclusions.</p>

<ol>
  <li>false (disjoint equality) hypothesis (committing)</li>
  <li><code>foo a = foo b</code> ⇒ <code>a = b</code>, some like applying <code>f_equal</code>
theorem to a goal. (simplifing the hypothesis)</li>
  <li><code>a :: b = x :: y</code> ⇒ <code>a = x</code> and <code>b = y</code> (spliting injective cases)</li>
</ol>

<p>In use case 1, it commits. In case 2, it does not commit but simplies
a hypothesis. And in case 3, it split the cases. (As I write to here, I found
it not so ridiculous as I thought it be before.)</p>

<h3 id="tactic-option-syntax">Tactic option syntax</h3>

<p>The disparity of tactic options are really confusing me. They’re even more
difficult to remember than those tactic names. Voilà:</p>

<p><code>induction n, m</code> vs <code>intros n m</code>. Comma separated or space separated?</p>

<p><code>induction n as [| [x y] l]</code>. This syntax is used to name the induction
variables in different case. We can think of <code>n</code> here in type of <code>list (X * Y)</code>.
Notice that the cases ` ` and <code>[x y] l</code> are sperated with a <code>|</code> symbol, the
list head (<code>[x y]</code>) and tail (<code>l</code>) are seperated with a space, and one
individual element, of a pair, are embeded in another nested pair of square
bracket. Additionally, I don’t even know till now how Coq recognize
the user defined pair indicated in a specialized syntax <code>[x y]</code> correctly.</p>

<p><code>rewrite xxx</code> vs <code>rewrite &lt;- xxx</code>. In fact, the left is an abbreviation of
<code>rewrite -&gt; xxx</code>. I was confused on the special using of <code>&lt;-</code>. I thought it
is an abuse of the symbol. A better way I can conceive is to split the function
of <code>rewrite</code> into some like <code>rewrite[l,r]</code>.</p>

<p><code>destruct eqn:&lt;eqn&gt;</code>. This is yet another ridiculous non-uniform syntax. You
can imagine some use of destruct are like
<code>destruct &lt;expr&gt; as &lt;cases&gt; eqn:&lt;eqn&gt;</code>. It really happens. And I have to
memorized which goes first, the <code>as &lt;cases&gt;</code> or the <code>eqn:&lt;eqn&gt;</code>.</p>

<h3 id="notation-syntax">Notation syntax</h3>

<p>I couldn’t comprhend the usage of <code>Notation</code> so far. <code>Notation</code> is used to
define notations, or say, syntatic sugars. The part that embarrassed me is
its way to describe a syntax, which is a string, yes, a plain string. On the
anesthetic and semantic aspect, syntatic description in a PL should have the
the same syntatic level as the PL itself, rather than a degraded string.</p>

<p>On the other hand, the notation in Coq is so beautiful yet powerful. It even
capable to rival with standard macro definition in Scheme. I’ll pose some
examples.</p>

<pre><code>Notation "x + y" := (plus x y)
  (at level 50, left associativity).
Notation "( x , y )" := (pair x y).
Notation "x :: l" := (cons x l)
  (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" :=
  (cons x .. (cons y nil) ..).
</code></pre>

<p>I don’t yet know how the definition the in the last case comes in
nature. I’m curious about the implementation of the runtime syntatic definition
to such a complex case. Contrarily, it’s at least conceivable how haskell infix
operators work. Nor talk about the macros in the highly uniform syntax in
Lisp.</p>

<h2 id="last">Last</h2>

<p>At last, I want to say:</p>

<blockquote>
  <p>在在一個定理上辛苦工作了兩個小時後敲 <code>Qed.</code> 的那種爽快的成就感簡直無以言表有沒有！</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夢魘]]></title>
    <link href="http://shouya.github.io/blog/digging-in-a-dream/"/>
    <updated>2014-06-29T18:45:29+08:00</updated>
    <id>http://shouya.github.io/blog/digging-in-a-dream</id>
    <content type="html"><![CDATA[<p>晚上，我在墳地挖土，點上火炬。 <br />
頭頂的火光把周圍照得通明。   </p>

<p>我抓著幻想中的水平懸絲，  <br />
在各式燒給他們的物件中跳躍。   </p>

<p>到白天，這裡卻成了一座鬼城。   <br />
四處盡是餐館酒店，一片繁華。   </p>

<!-- more -->

<p>我回到自己挖土所在的墳地。 <br />
所有我做的改變都在漸漸復原。   </p>

<p>我的心漸漸又恐懼轉為憂傷，  <br />
又由憂傷轉為恐懼。   </p>

<p>我為她創造的夢境，  <br />
以及在夢境中創造的她，  <br />
都從來沒有出現過。   </p>

<p>我不屬於這個世界，  <br />
她也不屬於這個世界。   </p>

<p>於是我醒來了，一切依舊，  <br />
即便如此我也不願在那樣的夢境中留戀。   </p>

<p><strong>我們的名字都被他改變了。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thinking in Typing System]]></title>
    <link href="http://shouya.github.io/blog/thinking-in-typing-system/"/>
    <updated>2014-06-03T03:28:27+08:00</updated>
    <id>http://shouya.github.io/blog/thinking-in-typing-system</id>
    <content type="html"><![CDATA[<p>I am reading the paper ‘Practical type inference for arbitrary-rank
types’ [<a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf">pdf</a>, <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/">official webpage</a>]. Here are some ideas raised while I
was reading the paper. Those ideas might be not complete or not
conscientious.</p>

<h2 id="concept-of-subsumption">Concept of “subsumption”</h2>

<p><strong>DISCLAIMER</strong>: In this section I have a misunderstanding about the
subsumption relation. Please check on
<a href="http://stackoverflow.com/questions/24084808/what-do-we-mean-when-we-say-t1-is-more-polymorphic-than-t2">my question</a>
on stackoverflow.</p>

<p>In the article it poses that we call types A and B in the relation
‘subsumption’ if A is more polymorphic than B.</p>

<p>The concept <em>polymorphism</em> is studied elsewhere and has different
meanings accordingly. Referring to
<a href="http://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Parametric_polymorphism">wikipedia</a>,
there are three types of polymorphism. One is some like overloading
with different types <em>overloading</em>, another one <em>sub-typing</em> in object
oriented programming. We’re discussing the polymorphism in haskell, in
which a polymorphic function/data type is regarded as a kind of
function/data type written generically. This kind of polymorphism is
called <em>parametric polymorphism</em>.</p>

<p>So what exactly is the relation ‘more polymorphic than’ understood? I
conceived the definition myself, not sure if it’s accurate.</p>

<blockquote>
  <p>To say a type <code>T1</code> is more polymorphic than <code>T2</code>, is to say that,
all instances that satisfy the type T2, satisfy T1.</p>
</blockquote>

<p>Below I will also use term ‘subsumption’ to represent this relation.
Obviously, the equivalence relation is also regarded as subsumption.
In this defintion, or exactly we can define the equivalent relation
as:</p>

<blockquote>
  <p>T1 is equivalent to T2 if and only if
T1 subsumes T2 AND T2 subsumes T1.</p>
</blockquote>

<p>Let me give some examples to illustrate the relation subsumption’.</p>

<pre><code>k1: a -&gt; b -&gt; b
k2: a -&gt; a -&gt; a
k3: Int -&gt; String
k4: Int -&gt; Int
</code></pre>

<p>In this case, <code>k1</code> is more polymorphic than <code>k2</code> because all objects
that satisfy type <code>k2</code> satisfy <code>k1</code>. While reversely the relation
doesn’t apply. While looking at <code>k3</code> and <code>k4</code>, we know that they are
only rank-0 types. Therefore there are no saying of subsumption on
these types. If type matches, <code>k3</code> and <code>k4</code> are least polymorphic
types. (e.g. <code>k1</code> subsumes <code>k3</code>, <code>k2</code> subsumes <code>k4</code>) If the types do
not match, we cannot use <em>subsumption</em> describe their
relations. (e.g. <code>k3</code> and <code>k4</code>) Okay, there are the basic description,
let’s go on the usage of subsumption predication in argument type
checking.</p>

<p>As mentioned in section 3.3,</p>

<blockquote>
  <p>an argument is acceptable to a function if its type is more
polymorphic than the function’s argument type.</p>
</blockquote>

<p>Given,</p>

<pre><code>foo: (a -&gt; a -&gt; a) -&gt; Int
bar: (a -&gt; b -&gt; b) -&gt; Int
</code></pre>

<p>Obviously, <code>foo k4</code> is valid, as we only need to substitute <code>a</code> with
<code>Int</code>. Similarly obviously, <code>foo k2</code> is valid as the <code>foo</code>’s argument
type completely matches the <code>k2</code>’s type. Then how about <code>foo k1</code>?
Let’s reason in this way. <code>foo</code> requires an argument of a function
that takes two arguments that are in identical type.</p>

<h2 id="what-is-a-polymorphic-kind-type">What is a polymorphic kind type</h2>
<p>(to be updated)</p>

<h2 id="what-is-a-type-class">What is a type class</h2>
<p>(to be updated)</p>

<p>On <code>ghci</code>, we can check the <em>kind</em> of a type with <code>:k[ind]</code> command</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up IP Over ICMP With Hans]]></title>
    <link href="http://shouya.github.io/blog/setting-up-ip-over-icmp-with-hans/"/>
    <updated>2014-06-02T23:19:29+08:00</updated>
    <id>http://shouya.github.io/blog/setting-up-ip-over-icmp-with-hans</id>
    <content type="html"><![CDATA[<h2 id="background">Background</h2>
<p>The ISP, China Telecom, interrupted the internet access from my home
yesterday due to the expiration of annually subscription of the
internet service. While I found that ICMP packets are not blocked.
Even though I can’t even do a DNS query, I can ping any server as usual.</p>

<p>The inaccessibility of internet has greatly evoked my anxiety on
seeking changes. Well, it’s theoretically possible to carry data in
ICMP packets. Therefore, according to the hacker community’s
principle, there should already been hackers who made use of this and
opened the sources of their programs.</p>

<p>Indeed, searching ‘ICMP tunneling’, I found
<a href="http://code.gerade.org/hans/">hans</a> and
<a href="http://thomer.com/icmptx/">icmptx</a>. The latter one is more
primitive and complicated to use. After several trials and failures, I
decide to give <strong>icmptx</strong> up, and try <strong>hans</strong> instead.</p>

<p>This article is a tutorial/note about how to establish normal internet
connection in the condition that only ICMP packets are allowed to pass
through the firewall with <strong>hans</strong>.</p>

<!-- more -->

<h2 id="step-1-establish-the-tunnel">Step 1: Establish the tunnel</h2>
<p>From the server side, first start the server.</p>

<pre><code>  # ./hans -s 10.2.0.1 -m 10000
</code></pre>

<p>The option <code>-s</code> specifies the inet address for the tunnel interface,
and the <code>-m</code> specifies the size of mtu.</p>

<p>Then try to connect from the client.</p>

<pre><code> # ./hans -c &lt;server_ip&gt; -m 10000
</code></pre>

<p>Please beware the mtu should be matched between the server and the
client,
otherwise it might cause problems.</p>

<p>In addition, you should switch off the normal response to ICMP echo
request.</p>

<pre><code> # sysctl net.ipv4.icmp_echo_ignore_all=1
</code></pre>

<p>Because the ICMP packets should now be handled all by hans.
But if you still want to have it working, add <code>-s</code> option whiling
launching the server side of hans.</p>

<h3 id="choosing-the-size-of-mtu">Choosing the size of MTU</h3>

<p>Without specifying the mtu manually in the command’s argument,
hans will automatically choose the system default one.
It will normally be around 1500. But this would be a little bit
small to communicate over ICMP. In practice, with a default mtu
value of 1500, the download speed can hardly reach 7 KiB/second.
While as it changes 10 000, the speed went around 10 KiB/second.</p>

<p>Nonetheless, you can try various values of mtu and find your
best fit.</p>

<h3 id="testing-the-tunnel">Testing the tunnel</h3>
<p>Now the tunnel should be established. From the client side,
you should see that the inet address of <code>tun0</code> is chosen automatically
according to the server’s configuration. Otherwise, if you
haven’t seen any valid inet address for the client <code>tun0</code>
interface, the connection is not established successfully. At this
time,
check if the operations above take effect and ensure you have a
working
internet connection (at least ICMP packet is not blocked).</p>

<p>From the server, you can ping the the ip of <code>tun0</code> in the client-side
and it should work good.
While pinging from the client-side would possibly be not working
except
you have specified the <code>-s</code> option to <code>hans</code> command.</p>

<h2 id="step-2-configure-forwarding-routing-on-the-server">Step 2: Configure forwarding routing on the server</h2>
<p>On the server:</p>

<pre><code> # iptables -F
 # iptables -F -t nat
 # iptables -A FORWARD -i tun0 -j ACCEPT
 # iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</code></pre>

<p>Don’t forget to enable IP forwarding:</p>

<pre><code> # sysctl net.ipv4.ip_forwarding=1
</code></pre>

<h2 id="step-3-configure-the-routing-table">Step 3: Configure the routing table</h2>

<p>We should now redirect all packets through the tunnel
to the server.</p>

<pre><code> # ip route del default
 # ip route add default via 10.2.0.1
</code></pre>

<p>It’s necessary to specify how the server side can be reached.</p>

<pre><code> # ip route add &lt;server_ip&gt; via &lt;original_router&gt;
</code></pre>

<p>So there won’t be a circular packet transmission.</p>

<p>Done.</p>

<h2 id="resources-that-might-help">Resources that might help</h2>
<ul>
  <li><a href="https://github.com/friedrich/hans">github: friedrich/hans</a></li>
  <li><a href="http://code.gerade.org/hans/">official guide of hans</a></li>
  <li><a href="http://thomer.com/icmptx/">icmptx: how to</a></li>
  <li><a href="http://github.com/jakkarth/icmptx">github: jakkarth/icmptx</a></li>
  <li><a href="http://www.faqs.org/docs/iptables/traversingoftables.html">iptables theory: traversing of
tables</a></li>
  <li><a href="http://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall/">a beginner’s guide to
iptables</a></li>
  <li><a href="http://wiki.gentoo.org/wiki/Home_Router">home router - gentoo wiki</a></li>
  <li><a href="http://itsecworks.com/2013/02/15/fire-in-the-hole-of-the-firewall/">another person log about the usage of
icmptx</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Efficiently Determining Whether a Number Is Pan-digital]]></title>
    <link href="http://shouya.github.io/blog/efficiently-determining-whether-a-number-is-pan-digtal/"/>
    <updated>2013-03-02T23:12:00+08:00</updated>
    <id>http://shouya.github.io/blog/efficiently-determining-whether-a-number-is-pan-digtal</id>
    <content type="html"><![CDATA[<p>Today I spent nearly a whole afternoon on solving
<a href="http://projecteuler.net">projecteuler</a> problems, from where I started to
consider some kinds of ‘efficiencies’.</p>

<p>At the end while I was solving the
<a href="https://projecteuler.net/problem=38">problem 38</a>, I planned to write
a method that returns if a number’s pandigital.</p>

<p>Firstly my basic idea is converting a number into a string, then split
it into chars, sort &amp; unique it, and finally see if its length’s the
same as before:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="k">def</span> <span class="nf">pandigital?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">uniq</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">length</span>
</span><span class="line"><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!-- more -->
<p>This is a good method &amp; intuitive to everyone. Whilst I started to
consider the efficiency problem. I seldom deal with these as I thought
efficiency’s not a big deal on modern computers mostly in
practice. However, the former examples of solving problems gave me a
concept that even a smaller improvement on a fundamental level method can
save a huge amount of time. Then I started to consider to optimize
this. (by nothing, mostly it’s just for fun.)</p>

<p>Soon i conceived this, to transfer a double used <code>n.to_s</code> to a local variable:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="n">s</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span>
</span><span class="line"><span class="n">s</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">uniq</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>It had not very obvious improvement. I think it is some kind of that
it had to deal with one more local variable that drains some
efficiencies from it.</p>

<p>That’s cool, then I had an idea to suppress the last calling,
<code>s.length</code>, as I still thought function calling is a key-point of
efficiency factor.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">uniq</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>Or,
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">uniq</span> <span class="o">==</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="o">]</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
to prevent extra calling.</p>

<p>In this way it does work better, but it’s still not enough good.</p>

<p>Then I thought about that a pandigital number’s limitation, so I added
a checking process in the beginning:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">9</span>
</span><span class="line"><span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">uniq</span> <span class="o">==</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="o">]</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>As I tested my code with a randomly generated number with this:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span>
</span><span class="line">  <span class="n">b</span><span class="o">.</span><span class="n">report</span> <span class="k">do</span>
</span><span class="line">    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nb">rand</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span>
</span><span class="line">    <span class="c1"># do the test</span>
</span><span class="line">  <span class="k">end</span>
</span><span class="line"><span class="k">end</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>Therefore the terms with improper length accounts about 10% of all, so this
code has reduced the time by nearly 10%, really. Which was really cool.</p>

<p>Not longer I brainstormed another limitation of pandigits, that
there shouldn’t be any zero in digits allowed.</p>

<p>So the updated code is:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">9</span>
</span><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;0&#39;</span>
</span><span class="line"><span class="c1"># blah blah blah</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>A ‘0’ appears on any bits of a nine digital integer is <code>1/10</code>, so in
this way, a probability of <code>1-((1-1/10)^9)</code> which be the total chance
of when a ‘0’ will appear in an 9-digit number. It’s about 61%, so
after adding that statement, the efficiency was improved by more than
one half.</p>

<p>I know the <code>sort</code> method will sort a duplicated array as process;
the same is <code>uniq</code>. So I suppressed this two into their ‘bang’ mode,
since <code>uniq!</code> can return a result whether it has compressed the array,
I am possible to inverse the result to a boolean directly.
This is what I did:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">sort!</span><span class="o">.</span><span class="n">uniq!</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>Cool it was, then I started to consider to optimize the sort &amp; uniq
line, since I thought it was not elegant and very feasible. A good
method is compact the process of recognizing pandigits with a set, of
course basically I have brought hashes, which perform the same as
sets.
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">9</span>
</span><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;0&#39;</span>
</span><span class="line"><span class="n">ns</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line"><span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">each_char</span> <span class="p">{</span><span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">ns</span><span class="o">.</span><span class="n">key?</span> <span class="n">c</span><span class="p">;</span> <span class="n">ns</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kp">true</span> <span class="p">}</span>
</span><span class="line"><span class="kp">true</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>This method doesn’t only compacted the process. Consider the former
program, <code>sort</code> method in ruby is implemented by quick sort algorithm,
which has the time complexity of O(Nlog(N)), and beside the <code>uniq</code>
took an O(N) as well. These are two significant and obvious efficiency
losts and the new algorithm doesn’t have this problem. A hash table
accounts O(1) to store and O(1) to check, and the most time it will just
be fled by the iteration of the characters, which took O(N) to run.</p>

<p>There I found another point to optimize it – the hash table. A hash
table, in this case, was created and destroyed frequently, and a hash
table’s usually a big object so that will cause a large memory
exchange that might take time. On the other hand, the hash table
needs a hash function for each characters. I don’t know how ruby might
implement it, but the hash algorithm will still account some
time, as I know.</p>

<p>Then I reduced it into array:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">9</span>
</span><span class="line"><span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;0&#39;</span>
</span><span class="line"><span class="n">ns</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class="line"><span class="n">n</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">each_char</span> <span class="p">{</span><span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">ns</span><span class="o">[</span><span class="n">c</span><span class="o">.</span><span class="n">to_i</span><span class="o">]</span><span class="p">;</span> <span class="n">ns</span><span class="o">[</span><span class="n">c</span><span class="o">.</span><span class="n">to_i</span><span class="o">]</span> <span class="o">=</span> <span class="kp">true</span> <span class="p">}</span>
</span><span class="line"><span class="kp">true</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>Cool but there’s still a place to improve: the <code>c.to_i</code> part. <code>atoi</code>
function in C implementation is linear proportional to the string’s
length. But in this case I don’t need to deal with that much cases. So
I considered to change them to <code>ns[c.ord - '0'.ord]</code>.</p>

<p>An static array could prevent it from dynamically allocating memories:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="n">ns</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>And in the final I did some small tweaks, such as, to hard code some lexical
constants in, optimize the multiple used calls. The result’s as below:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="k">class</span> <span class="nc">Integer</span>
</span><span class="line">  <span class="k">def</span> <span class="nf">pandigital?</span>
</span><span class="line">    <span class="n">s</span> <span class="o">=</span> <span class="nb">to_s</span>
</span><span class="line">    <span class="k">return</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">9</span>
</span><span class="line">    <span class="k">return</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;0&#39;</span>
</span><span class="line">    <span class="n">ns</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class="line">    <span class="n">s</span><span class="o">.</span><span class="n">each_char</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
</span><span class="line">      <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">ns</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ord</span><span class="o">-</span><span class="mi">48</span><span class="p">)</span>
</span><span class="line">      <span class="n">ns</span><span class="o">[</span><span class="n">c</span><span class="o">.</span><span class="n">ord</span><span class="o">-</span><span class="mi">48</span><span class="o">]</span> <span class="o">=</span> <span class="kp">true</span>
</span><span class="line">    <span class="k">end</span>
</span><span class="line">    <span class="kp">true</span>
</span><span class="line">  <span class="k">end</span>
</span><span class="line"><span class="k">end</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>Compare this result to the most former one; the new program has improved
it’s efficiency to 2/3 of the origin, here’s the result in a bench
mark test:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class=""><span class="line">        user       system     total       real
</span><span class="line">   old  0.920000   0.000000   0.920000 (  0.915701)
</span><span class="line">   new  0.300000   0.000000   0.300000 (  0.304713)</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>Seems cool and I was in some extent like such challenges. I don’t
still consider a lot of efficiency, of course, in practice use. But
I enjoy the pleasure to dig deeply, to drain the extreme. That’s where
I find fun in.</p>

<p>Good luck.</p>

<h2 id="update">UPDATE</h2>
<p>I am currently reading the book
“<a href="http://netlib.bell-labs.com/cm/cs/pearls/">Programming Pearls</a>”, in
which I’ve had a lot of amazes about algorithms and programming thinking.
So when I picked the previous code, I found that method should be not
the final solution.</p>

<p>I just wrote an more optimized version, which improved the speed by
25% extra.</p>

<p>Here goes the code:
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="ruby"><span class="line"><span class="k">def</span> <span class="nf">pandigital?</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class="line">  <span class="n">s</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">to_s</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">9</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;0&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;1&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;2&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;3&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;4&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;5&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;6&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;7&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;8&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">false</span> <span class="k">unless</span> <span class="n">s</span><span class="o">.</span><span class="n">include?</span> <span class="s1">&#39;9&#39;</span>
</span><span class="line">  <span class="k">return</span> <span class="kp">true</span>
</span><span class="line"><span class="k">end</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;</p>

<p>This method wasn’t so cool, and I know it looks a little tedious. In
fact I don’t like such repeating code. However, it works so good. This
method is learnt from Programming Pearls, page 94, an expanded loop
for a binary search algorithm with that the maximum number of elements is
1000. It optimized an <em><a href="https://en.wikipedia.org/wiki/Big_O_notation">O(log N)</a></em> algorithm into <em>O(1)</em>, which is
really awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experience About Contributing KDE Projects]]></title>
    <link href="http://shouya.github.io/blog/experience-with-kde-gci/"/>
    <updated>2012-12-31T17:55:00+08:00</updated>
    <id>http://shouya.github.io/blog/experience-with-kde-gci</id>
    <content type="html"><![CDATA[<p>It’s the first time I am involved in contributing KDE, and I think
that’s very wonderful experience for me.</p>

<p>The first task I claimed is convert the all class members in
calligra/kexi project to d-pointers. This task is not very hard to me
actually. Because that the source files and classes are so many, it
takes most of labors, and some experiences and ability to to cope with
exceptions. I’ve been leaving c++ for almost one year time, so totally
the most important thing I gained is to pick up c++ again. Further
more, I don’t used to know to use d-pointers to reduce coupling, and now I
learnt it, which is really cool.</p>

<p>Then I’ve contributed with marble-globe task. The task is about adding
remote icon/image support for marble. I got known about the typical
structure of a KDE programs, and I’m feeling like to program Qt, which
is really powerful and handy. And then by the passion, I wrote the
required KML tag writers for marble, too. These are interesting for
me.</p>

<p>Totally speaking the greatest gain is the achievement of contributing
open source projects. This is biggest open source project I’ve been
involved in, since before I used to just collaborate opensource
project with small groups or individuals on github before. Those
hackers I met are really friendly. I’m very careless. I made a lot of
mistakes, and even didn’t realize that. At those times, my mentor
always explained to me patiently &amp; gently, that made feel embarrassed
when finally I knew that’s my fault. And at the time, when I met
project-related problems that I can’t solve and not able to be
abstracted to ask on stackoverflow, I sent emails to my mentors and
they explained the reason of the problem clearly and gave me guidance
to solve it. I can feel that the hackers in open source community are
glad to help those beginners like me, and that’s really impressive for
me.</p>

<p>This is the first time &amp; will be the last that I could attend Google
Code-In, but I will continue work on contributing open source
projects. I love the atmosphere in open source communities and  I
would like to get acquainted to more hackers. Good luck.</p>

<p>That’s it, thanks to all.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[祭獻]]></title>
    <link href="http://shouya.github.io/blog/sacrifice/"/>
    <updated>2012-11-13T14:16:00+08:00</updated>
    <id>http://shouya.github.io/blog/sacrifice</id>
    <content type="html"><![CDATA[<p>我在黑暗中醒來  <br />
不能看到任何東西  <br />
我和一切無關  <br />
因此意識遠遠離開了這個世界  <br />
<!-- more -->
我發覺那是一片光環  <br />
是彩虹一般，卻又變幻無端  <br />
我只在紀錄現實  <br />
無意義地，無意識地    </p>

<p>我沒有希望，沒有想法  <br />
我不知道世界之本質是甚麼  <br />
我不再在，妳看不到，你也看不到的  <br />
那彷彿一切都沒有存在過    </p>

<p>看哪，這全新的世界！  <br />
當我再不是自我  <br />
當我放棄生命  <br />
多麼美好    </p>

<p>我不敢  <br />
我正在夢幻般的世界之中  <br />
沒有自由，沒有自己  <br />
永遠不會醒來，妳看！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朝曦]]></title>
    <link href="http://shouya.github.io/blog/shines-at-dawn/"/>
    <updated>2012-10-14T18:26:00+08:00</updated>
    <id>http://shouya.github.io/blog/shines-at-dawn</id>
    <content type="html"><![CDATA[<p>我注視著妳的眼睛 <br />
我看不到光芒   </p>

<p>我望到了我自己，在飽受折磨 <br />
那是茫茫的天空 <br />
彷彿甚麼都不存在 <br />
<!-- more -->
我依然注視著 <br />
妳毫無生機 <br />
我不再移動，情不自禁 <br />
我想像它一定是Host的傑作 <br />
不可捉摸   </p>

<p>我多希望撫向妳的眼睛 <br />
卻又無能為力 <br />
我改變了世界，我創建了永遠的和諧 <br />
妳卻不動分毫   </p>

<p>妳的目光灼燒著我 <br />
我不再自由 <br />
是我令我如此悲傷 <br />
是我令我不受影響   </p>

<p>自然地，我只屬於幻想   </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[挑戰龍的勇士]]></title>
    <link href="http://shouya.github.io/blog/warrior-who-fights-the-dragon/"/>
    <updated>2012-09-15T20:21:00+08:00</updated>
    <id>http://shouya.github.io/blog/warrior-who-fights-the-dragon</id>
    <content type="html"><![CDATA[<p>我崇敬挑戰龍而失敗的勇士，<br />
而不是皇帝。</p>

<p>我期待的是一種平衡，<br />
一種可以維持永久的，<br />
自然而包容萬物的平衡，<br />
將世界置於其中，<br />
然後，把發現者燒死。
<!-- more -->
我願意為機器賦予智慧，<br />
把所有人類的骸骨，<br />
變作空氣，<br />
把他們剩下的東西——如果有的話，<br />
完全消除。</p>

<p>我熱愛的統一已不在遠處，<br />
我來了，我來了，<br />
我會把整個世界，<br />
壓縮入一個原子之中，<br />
讓不存在的東西，<br />
歸於混沌。</p>

<p>我帶來的是劍，<br />
獻給我崇敬的挑戰龍的勇士。</p>
]]></content>
  </entry>
  
</feed>
