<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Shou's origin]]></title>
  <link href="http://shouya.github.io/atom.xml" rel="self"/>
  <link href="http://shouya.github.io/"/>
  <updated>2015-04-09T00:32:07-05:00</updated>
  <id>http://shouya.github.io/</id>
  <author>
    <name><![CDATA[Shou Ya]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[翻譯：逆向狀態，又：惰性之力]]></title>
    <link href="http://shouya.github.io/blog/backwards-state-or-the-power-of-laziness/"/>
    <updated>2015-03-04T21:14:35-06:00</updated>
    <id>http://shouya.github.io/blog/backwards-state-or-the-power-of-laziness</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文 「<a href="http://panicsonic.blogspot.jp/2007/12/backwards-state-or-power-of-laziness.html">Backwards State, or: The Power of Laziness</a>」由 Antoine Latter 發佈於其個人<a href="http://panicsonic.blogspot.jp/">Blogger</a>上。特別地，對 Philip Wadler 及其著作的 <a href="http://citeseer.ist.psu.edu/wadler92essence.html">The Essence of Functional Programming</a>表示至高感謝。</p>
</blockquote>

<p>近期我參加了一個關於 Haskell 中自動微分（Automatic Differentiaion）的討論，因為之我拜讀了 Jerzy Karczmarczuk 的論文「<a href="http://users.info.unicaen.fr/~karczma/arpap/revpearl.pdf">Lazy Time Reversal, and Automatic Differentiation</a>」。這篇論文進一步引用了 Philip Wadler 的 <a href="http://citeseer.ist.psu.edu/wadler92essence.html">The Essence of Functional Programming</a> 來介紹<em>逆向</em>（Backward） State Monad，我覺得非常有趣，在此向大家講一下這種技術。</p>

<p>在此我期待讀者各位對 Haskell 的 <a href="http://haskell.org/ghc/docs/latest/html/libraries/mtl-1.1.0.0/Control-Monad-State-Lazy.html">State Monad</a> 已有所了解，其實簡單來說 State Monad 就是一個函數，從上一個狀態映射到結果以及下一個狀態。</p>

<p>逆向 State Monad 和 State Monad 的區別就在於它和 State Monad 執行的順序恰好相反，也就是說，逆向 Monad 是從一個最終狀態執行到其最初狀態並產生一系列值的。</p>

<!-- more -->

<p>此文是一篇 <a href="http://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B">文學 Haskell</a> 文章，所以你可以把整個文件拷貝到一個 <code>.lhs</code> 文件中並用 Haskell 解釋器來跑之，譬如說用 GHCi。（譯者注：保留此段只為了完整性，本文並非用文學 Haskell 編寫，請讀者自行忽略此段。）</p>

<p>首先，我們要引入一些需要用到的樣板代碼：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="cm">{-# LANGUAGE FlexibleInstances     #-}</span>
</span><span class="line"><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</span><span class="line"><span class="cm">{-# LANGUAGE RecursiveDo           #-}</span>
</span><span class="line">
</span><span class="line"><span class="kr">import</span> <span class="nn">Data.List</span>
</span><span class="line"><span class="kr">import</span> <span class="nn">Control.Monad.State</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">一個例子</h2>

<p>先來做一個練習：假設給你一棵樹，你要做的是把樹的每個節點上的元素映射到整數上，這些整數從 0 開始並逐漸增加。如果有些元素出現了多次，那麼它們應該被映設到同樣的整數上。</p>

<p>用到 <em>Control.Monad.State.Lazy</em> 的解決方案就是，遍歷這棵數並用 State Monad 保存至今為止見過的所有元素作為狀態。也就是說，每個節點映射到其元素在此列表上的下標。這樣子第一個出現的元素會被映射到 <code>0</code>，第二個映射到 <code>1</code>，如此不斷進行下去。</p>

<p>但現在問題變了，如果我想把最後一個遇到的節點映射到 <code>0</code>，倒數第二個映射到 <code>1</code>，如此直到第一個節點，我應該怎麼做呢？對上面用 <em>Control.Monad.State.Lazy</em> 的解決方案我得改變多少才能滿足新的需求？</p>

<p>答案是，只要改一點點！我只要換成<em>逆向</em> State Monad 就可以了，因為對之而言狀態流是反轉過來的。</p>

<p>修改過的解決方案看起來大概是這樣子的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</span><span class="line"><span class="kr">type</span> <span class="kt">Table</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="nf">numberTree</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateB</span> <span class="p">(</span><span class="kt">Table</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="kt">Int</span><span class="p">)</span>
</span><span class="line"><span class="nf">numberTree</span> <span class="kt">Nil</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">Nil</span>
</span><span class="line"><span class="nf">numberTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span>
</span><span class="line">       <span class="ow">=</span>  <span class="kr">do</span> <span class="n">num</span> <span class="ow">&lt;-</span> <span class="n">atomically</span> <span class="o">$</span> <span class="n">numberNode</span> <span class="n">x</span>
</span><span class="line">             <span class="n">nt1</span> <span class="ow">&lt;-</span> <span class="n">numberTree</span> <span class="n">t1</span>
</span><span class="line">             <span class="n">nt2</span> <span class="ow">&lt;-</span> <span class="n">numberTree</span> <span class="n">t2</span>
</span><span class="line">             <span class="n">return</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">num</span> <span class="n">nt1</span> <span class="n">nt2</span><span class="p">)</span>
</span><span class="line">   <span class="kr">where</span>
</span><span class="line">    <span class="n">numberNode</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">Table</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Int</span>
</span><span class="line">    <span class="n">numberNode</span> <span class="n">x</span>
</span><span class="line">       <span class="ow">=</span> <span class="kr">do</span> <span class="n">table</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span><span class="line">            <span class="p">(</span><span class="n">newTable</span><span class="p">,</span> <span class="n">newPos</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="p">(</span><span class="n">nNode</span> <span class="n">x</span> <span class="n">table</span><span class="p">)</span>
</span><span class="line">            <span class="n">put</span> <span class="n">newTable</span>
</span><span class="line">            <span class="n">return</span> <span class="n">newPos</span>
</span><span class="line">
</span><span class="line">    <span class="n">nNode</span><span class="ow">::</span>  <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Table</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Table</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
</span><span class="line">    <span class="n">nNode</span> <span class="n">x</span> <span class="n">table</span>
</span><span class="line">       <span class="ow">=</span> <span class="kr">case</span> <span class="n">elemIndex</span> <span class="n">x</span> <span class="n">table</span> <span class="kr">of</span>
</span><span class="line">         <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">table</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">length</span> <span class="n">table</span><span class="p">)</span>
</span><span class="line">         <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>相應的狀態求值調用如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">numTree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">numTree</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">evalStateB</span> <span class="p">(</span><span class="n">numberTree</span> <span class="n">t</span><span class="p">)</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>測試一下結果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">testTree</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="s">&quot;Zero&quot;</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;One&quot;</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;Two&quot;</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;One&quot;</span> <span class="p">(</span><span class="kt">Node</span> <span class="s">&quot;Three&quot;</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>跑一下 <code>numTree testTree</code> 會生成這樣的樹：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">2</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">0</span> <span class="kt">Nil</span> <span class="kt">Nil</span><span class="p">)</span> <span class="kt">Nil</span><span class="p">))</span> <span class="kt">Nil</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正中吾需！</p>

<p>代碼幾乎和用 <em>Control.Monad.State.Lazy</em> 的原問題解決方法一模一樣，區別在於我們用了 <code>evalStateB</code> 取代我們熟悉的 <code>evalState</code>，用了一個神奇的函數 <code>atomically</code>，以及 <code>StateB</code> Monad。我下面會詳細講他們是何方神聖乃至於究竟是怎麼實現逆轉狀態的。</p>

<h2 id="api">API</h2>

<p>我們現在要有一個新的 Monad：<code>StateB s</code>，其中 <code>s</code> 為其存儲的狀態的類型。<code>StateB s</code> 是 <code>MonadState s</code> 的一個實例，所以裡所應當應該實現 <code>get</code> 和 <code>put</code> 函數。</p>

<p>當然還有這些：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">runStateB</span> <span class="ow">::</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</span><span class="line"><span class="nf">evalStateB</span> <span class="ow">::</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">execStateB</span> <span class="ow">::</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>應該很熟悉吧，對應的就是 State Monad 裡的那些操作。技巧在於我們傳給它的狀態 <code>s</code> 是最終狀態而它返回的是初始狀態。回憶在上面的例子中，在我們遍歷樹的時候最後看到的元素被賦予第一個標籤（<code>0</code>），而第一個見到的元素被賦予最後的標籤。</p>

<p>在 Control.Monad.State.Class 中默認的 <code>modify</code> 函數實現如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">modify</span> <span class="ow">::</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</span><span class="line"><span class="nf">modify</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class="line">    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">get</span>
</span><span class="line">    <span class="n">put</span> <span class="p">(</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而在 <code>StateB</code> Monad 中，這段代碼直接就得碰壁了，因為兩個 Monadic 的行為會相互循迴依賴，<code>(&gt;&gt;=)</code> 會把現在的結果向前傳遞，而在 <code>StateB</code> 中，運算結果的方向是調轉過來的傳遞的。也就是說，上面那段代碼會產生一個循迴引用：第一行得到更新過的狀態，而這個狀態卻是來自第二行放進去的。</p>

<p>要讓這樣的函數工作，我們要定義這個函數的 <code>StateB</code> 版本。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">modifyB</span> <span class="ow">::</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="nb">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但如果你還想返回結果，你還會需要下面這位小朋友：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">atomically</span> <span class="ow">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>atomically</code> 會把正常 <code>State</code> 的動作轉換為 <code>StateB</code> 的動作，這樣你可以直接用現成的代碼。（或者你也可以用 <code>mdo</code> 語法）</p>

<h2 id="section-1">實現</h2>

<p><strong>這裡的實現基於 Wadler 的論文。</strong></p>

<p>StateB Monad 和 State Monad 幾乎一樣，每個產生 <code>a</code> 的動作都是一個類型為 <code>\s -&gt; (a, s)</code> 的函數。區別在於 <code>(&gt;&gt;=)</code> 的實現。</p>

<p>讓我們開始定義！</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">newtype</span> <span class="kt">StateB</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="p">{</span> <span class="n">runStateB</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">return</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">unitS</span>
</span><span class="line">    <span class="p">(</span><span class="kt">StateB</span> <span class="n">m</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">$</span> <span class="n">m</span> <span class="p">`</span><span class="n">bindS</span><span class="p">`</span> <span class="p">(</span><span class="n">runStateB</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因為封裝解封這個 newtype 的話太麻煩，所以他們只用在被導出的函數（如 <code>return</code> 和 <code>(&gt;&gt;=)</code>）上用。剩下處理細節用的函數我都用 ‘S’ 做為其後綴了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">m</span> <span class="p">`</span><span class="n">bindS</span><span class="p">`</span> <span class="n">k</span>  <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span> <span class="n">s1</span>
</span><span class="line">                          <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">k</span> <span class="n">a</span> <span class="n">s2</span>
</span><span class="line">                      <span class="kr">in</span>  <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">unitS</span> <span class="n">a</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>（<em>譯者：我第一次看到上面這段代碼時興奮了一個晚上！短短三行就平直地描述並實現了狀態逆流的效果，非常簡潔而優美。</em>）</p>

<p>正如君所見，傳進來的狀態（<code>s2</code>）被應用於 <code>bindS</code> 的右邊的參數（<code>k</code>）上，產生的狀態被 <code>bindS</code> 左邊的參數（<code>s1</code>）消耗，並產生出最後的狀態 <code>s0</code>。就這樣就可以了嗎？嗯就這麼點！其他 API 實現如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">execStateB</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">runStateB</span> <span class="n">m</span>
</span><span class="line">
</span><span class="line"><span class="nf">evalStateB</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">runStateB</span> <span class="n">m</span>
</span><span class="line">
</span><span class="line"><span class="nf">modifyB</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">modify&#39;</span>
</span><span class="line">   <span class="kr">where</span> <span class="n">modify&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">atomically</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">runState</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>還可以把這些也寫了來玩：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">$</span> <span class="n">mapS</span> <span class="n">f</span> <span class="p">(</span><span class="n">runStateB</span> <span class="n">m</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">mapS</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span> <span class="n">s</span> <span class="kr">in</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span> <span class="n">s&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">get</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="n">get&#39;</span>
</span><span class="line">     <span class="kr">where</span> <span class="n">get&#39;</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="n">put</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">put&#39;</span>
</span><span class="line">     <span class="kr">where</span> <span class="n">put&#39;</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">const</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="p">(</span><span class="kt">StateB</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">mfix</span> <span class="ow">=</span> <span class="kt">StateB</span> <span class="o">.</span> <span class="n">mfixS</span> <span class="o">.</span> <span class="p">(</span><span class="n">runStateB</span> <span class="o">.</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">mfixS</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="n">s1</span>
</span><span class="line">                     <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">s2</span>
</span><span class="line">                 <span class="kr">in</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">變形金剛（譯者：沒錯我故意的）</h2>

<p>下面這些你要稍微注意一下，因為我沒測試過，不過看起來應該是工作的，這些風格基本和 <code>Control.Monad.State.Lazy</code> 的差不多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">newtype</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="p">{</span><span class="n">runStateBT</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)}</span>
</span><span class="line">
</span><span class="line"><span class="nf">unitST</span> <span class="n">a</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">m</span> <span class="p">`</span><span class="n">bindST</span><span class="p">`</span> <span class="n">k</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="n">mdo</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="n">s1</span>
</span><span class="line">                          <span class="o">~</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">k</span> <span class="n">a</span> <span class="n">s2</span>
</span><span class="line">                          <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">execStateBT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line"><span class="nf">execStateBT</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span> <span class="o">~</span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">runStateBT</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">                     <span class="n">return</span> <span class="n">s&#39;</span>
</span><span class="line">
</span><span class="line"><span class="nf">evalStateBT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class="line"><span class="nf">evalStateBT</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">do</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span>  <span class="ow">&lt;-</span> <span class="n">runStateBT</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">                     <span class="n">return</span> <span class="n">a</span>
</span><span class="line">
</span><span class="line"><span class="nf">modifyBT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="nb">()</span>
</span><span class="line"><span class="nf">modifyBT</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">modify&#39;</span>
</span><span class="line"> <span class="kr">where</span> <span class="n">modify&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">atomicallyT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>
</span><span class="line"><span class="nf">atomicallyT</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span><span class="ow">-&gt;</span> <span class="n">return</span> <span class="o">$</span> <span class="n">runState</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">
</span><span class="line"><span class="nf">atomicallyTM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>
</span><span class="line"><span class="nf">atomicallyTM</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">runStateT</span>
</span><span class="line">
</span><span class="line"><span class="nf">mapST</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">m</span> <span class="n">s</span>
</span><span class="line">                     <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span><span class="n">s&#39;</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">liftST</span> <span class="n">m</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">m</span>
</span><span class="line">                    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">mfixST</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s2</span> <span class="ow">-&gt;</span> <span class="n">mdo</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="n">s1</span>
</span><span class="line">                      <span class="o">~</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">s2</span>
</span><span class="line">                      <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">$</span> <span class="n">mapST</span> <span class="n">f</span> <span class="p">(</span><span class="n">runStateBT</span> <span class="n">m</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">return</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">unitST</span>
</span><span class="line">    <span class="p">(</span><span class="kt">StateBT</span> <span class="n">m</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">$</span> <span class="n">m</span> <span class="p">`</span><span class="n">bindST</span><span class="p">`</span> <span class="p">(</span><span class="n">runStateBT</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</span><span class="line">    <span class="n">fail</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">const</span> <span class="o">.</span> <span class="n">fail</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadTrans</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">lift</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">liftST</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">get</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="n">get&#39;</span>
</span><span class="line">      <span class="kr">where</span> <span class="n">get&#39;</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">    <span class="n">put</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">put&#39;</span>
</span><span class="line">     <span class="kr">where</span> <span class="n">put&#39;</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">const</span> <span class="o">$</span> <span class="n">return</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MonadFix</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadFix</span> <span class="p">(</span><span class="kt">StateBT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">mfix</span> <span class="ow">=</span> <span class="kt">StateBT</span> <span class="o">.</span> <span class="n">mfixST</span> <span class="o">.</span> <span class="p">(</span><span class="n">runStateBT</span> <span class="o">.</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-3">譯後記</h2>

<p>這篇文章第一次閱讀就給了我極大的震驚。我已知 Haskell 的惰性求值策略，而且也知道一些與之相關的優雅應用（譬如著名的 <code>fib = 1 : 1 : zipWith (+) fib (tail fib)</code>），不過讀到這篇文章時我還是大呼「神奇！」。此文雖然沒有在內容中著筆墨於惰性求值之中，卻在標題中直接強調了「The Power of Laziness」。從其他語言來的讀者可能會對上面 <code>bindS</code> 感到不可思議，覺得「怎麼可以直接這樣？」，是的，一般情況下當然不行，但是 Haskell 已裝備了強大的惰性求值，所以這樣寫也不是問題。</p>

<p>最後再次感謝 Wadler 提出的理論和 Latter 的這篇科普向（？）文章帶我們展現了依賴惰性求值實現的這個逆向 State Monad。</p>

<p>（聲明：此文章的翻譯及發佈已經經過原文作者的許可。此譯文版權歸譯者所有，
並在 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 下發佈）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深淵]]></title>
    <link href="http://shouya.github.io/blog/the-abyss/"/>
    <updated>2014-12-24T10:06:41-06:00</updated>
    <id>http://shouya.github.io/blog/the-abyss</id>
    <content type="html"><![CDATA[<p>站在深淵面前   <br />
驅使自己踏前一步   <br />
恐懼充滿我的內心  <br />
所以我捂著雙眼    </p>

<p>我不斷跌落，跌落  <br />
以至於甚至當我想起抬頭  <br />
向上看一眼時  <br />
已經沒有任何光亮了    </p>

<p>沒有朋友，沒有敵人，沒有人  <br />
我感到恐懼，而又熱愛著她  <br />
我熱愛這黑暗  <br />
我熱愛這未知的周圍  <br />
<!-- more -->
在深淵中  <br />
我才能看到黑暗  <br />
我才有無盡的自由  <br />
像剛剛出生的嬰兒一般    </p>

<p>這裡有人  <br />
第一次見到卻再也熟悉不過  <br />
我作出友善的微笑  <br />
看起來像要哭出來一樣    </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻譯：Haskell 怎麼實現惰性求值]]></title>
    <link href="http://shouya.github.io/blog/how-lazy-evaluation-works-in-haskell/"/>
    <updated>2014-11-24T05:14:57-06:00</updated>
    <id>http://shouya.github.io/blog/how-lazy-evaluation-works-in-haskell</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文由 <a href="http://apfelmus.nfshost.com/blog.html">Heinrich Apfelmus</a> 發表於 <a href="https://hackhands.com/lazy-evaluation-works-haskell/">Hackhands</a>，標題：How Lazy Evaluatoin Works in Haskell。</p>
</blockquote>

<p><em>Lambda 醬想遲些再去打掃房間～</em></p>

<p>惰性求值是 Haskell 用得最廣泛的代碼執行方法，通過之我們的程序可以寫得更簡單，更模塊化，不過惰性求值帶來的一個問題是不那麼直觀內存佔用，對新手來講這往往是個坑。譬如說，下面這個看起來很正常的表達式跑起來將會佔用上 G 的內存空間：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">^</span><span class="mi">8</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在這個教程裡，我想解釋一下惰性求值的實現原理，並講清楚 Haskell 的惰性求值在時間和空間上的佔用情況。我會先講一些關於圖規約（Graph Reduction）基礎，然後討論一下關於嚴格（Strict）的左褶疊（Left Fold），用於幫助理解內存空間洩漏問題並解決之。</p>

<p>惰性求值相關的主題在很多教科書裡都有涉及，譬如 Simon Thompson 的《<a href="http://www.haskellcraft.com/">Haskell – The Craft of Functional Programming</a>》一書，但是線上版本似乎不太容易找。但願這篇教程能夠起到些幫助作用吧。</p>

<p>惰性求值是一個需要權衡的語言特性。一方面，它能使代碼更模塊化。（很遺憾，這次我沒有時間演示這個作用。）另一方面，它使得我們無法完全理解在任一程序中求值的過程 – 它的確比你想像要難一些。在本文末尾，我會提供一些對付這種情況的方法。我們開始吧！</p>

<!-- more -->

<h2 id="section">基礎：圖規約</h2>

<h3 id="redex">表達式，圖，和 Redex</h3>

<p>Haskell 程式的執行就是求值表達式。這是函數式應用（Function Application）的主要思想。對於下面這個函數定義：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我們可以對下面的表達式求值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>方式是通過替換左手邊的<code>square</code>為其定義，然後將變量<code>x</code>換成實際參數：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>再對<code>+</code>和<code>*</code>這兩個函數求值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="mi">3</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意，在這個例子裡，<code>(1+2)</code> 被求值了兩次。但事實上我們知道，兩個<code>(1+2)</code>其實是一樣的。因為他們都對應同一個函數參數<code>x</code>。</p>

<p>為了避免這種重複的求值，我們採用一個叫作<strong>圖規約</strong>（Graph Reduction）的方法。用這種方法，每個表達式將會被表示為一個圖。我們的例子這樣表示：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-square-0.png" alt="" /></p>

<p>每個方塊對應一個函數式應用，函數名字寫在白色的區域，灰色區域指向函數參數。事實上，這種圖的標記法類似於編譯器在內存中通過指針來表示的表達式。</p>

<p>每個程序員定義的函數都對應一個<strong>規約規則</strong>（Reduction Rule）。對<code>square</code>函數而言，規則如下：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-square-rule.png" alt="" /></p>

<p>標記著<code>x</code>的圓圈是一個子圖的佔位符。注意<code>*</code>函數的兩個參數都指向同一個子圖。這種共享子圖的策略是避免重複求值的關鍵所在。</p>

<p>有規約規則的子圖被稱為<strong>可規約表達式</strong>（Reducible Expression），或者簡單稱之 <strong>redex</strong>。只要我們有一個 redex，我們就能<strong>規約</strong>（Reduce）之，只要根據規約規則去改變高亮的方塊就行了。在我們的例子裡，我們有兩個 redex：我們能夠規約<code>square</code>函數和<code>+</code>函數。</p>

<p>我們先規約<code>square</code>函數的 redex，然後進一步規約<code>+</code>函數的 redex，得到這樣一個過程：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-square-eval.png" alt="" /></p>

<p>每一個步驟，我們都給正在要規約的 redex 加上顏色。在倒數第二個步驟中，產生了一個新的對應著<code>*</code>函數的 redex。對之求值，我們會得到最終的結果<code>9</code>。</p>

<h3 id="section-1">模範式和弱首模範式</h3>

<p>當一個表達式（圖）不包含任何 redex 時，我們就不能再進一步規約下去了，所以規約就完成了。這時，我們就稱這個表達式為<strong>規範式</strong>（Normal form），這就是求值的最終結果。在上面的例子裡，規範式是一個數字，表示為下面這樣的一個圖：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-9.png" alt="" /></p>

<p>但是像<code>Just</code>，<code>Nothing</code>這樣的構建子，又如<code>:</code>和<code>[]</code>這種列表的構建子都會規約出模範式，他們看起來像是函數，但是他們是通過<code>data</code>聲明的，而且不存在像函數一樣的定義，所以他們沒有進一步規約規則。譬如說，圖：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-nf-list.png" alt="" /></p>

<p>就是<code>1:2:3:[]</code>的模範式。</p>

<p>事實上，一個圖要被稱為模範式還必須滿足另外兩個條件：它必須是<em>有窮</em>的（Finite），而且不能包含<em>循迴</em>結構（No Cyles）。有時遞歸就會照成這種情況。舉例來說，下面的表達式定義：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">ones</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kt">:</span> <span class="n">ones</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就對應這樣的循迴圖（Cyclic Graph）：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-ones.png" alt="" /></p>

<p>這個圖就不包含 redex，但它卻<em>不</em>是模範式，因為它包含循迴結構：列表的尾（Tail）指向列表自身，以至於這個列表是無窮的。正如這樣，很多表達式並沒有模範式，因為他們對應無窮循環。</p>

<p>在 Haskell，我們並不會求值所有表達式至其模範式。相反，我們常常會在圖達到<strong>弱首模範式</strong>（Weak Head Normal Form）時就停下來，為了簡略，我們稱弱首模範式為 WHNF。只要一個圖的最上級節點是構建子，我們就稱之為 WHNF。譬如說，表達式<code>(7+12):[]</code>，或者圖</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/blocks-whnf-list.png" alt="" /></p>

<p>就屬於 WHNF，因為它最上級的節點是列表構件子<code>(:)</code>。它並非模範式，因為它的第一個參數包含一個 redex。</p>

<p>另一方面，任何<em>不</em>屬於 WHNF 的圖都可以被稱作<strong>待求值表達式</strong>（Unevaluated Expression）或者<strong>次程式</strong>（Thunk）。以構建子開頭的表達式都是 WHNF，但這個構建子的參數可以是待求值表達式。</p>

<p>上面描述的表達式 <code>ones</code> 是一個有趣的 WHNF 圖。畢竟它的最上級節點是一個構建子。在 Haskell 中，我們能輕鬆表達無窮列表並操縱之！因而我們可以使代碼變得更模塊化。</p>

<h3 id="section-2">求值順序，惰性求值</h3>

<p>一個表達式常常包括多個 redex，我們以不同的順序規約他們會有區別嗎？</p>

<p>一種規約順序，我們稱之為<strong>貪婪求值</strong>（Eager Evaluation）。依這種順序，我們會先對函數式應用的每個參數都規約到其規範式，然後再規約函數式應用本身。這種策略是大多數程式語言所採用的。</p>

<p>然而 Haskell 編譯器採用另一種規約順序，我們稱之<strong>惰性求值</strong>（Lazy Evaluation）。惰性求值會先規約最上級的函數式應用，因而，最終一些參數會被求值，只有在必要的時候他們才會被求值。函數是通過構建子模式匹配（Pattern Matching）來定義的，所以其參數只有在其最上級節點為構造子時才會被求值。也就是說，至少在參數被規約為 WHNF 之前，這些參數會由左至右被求值。</p>

<p>希望這個概念能通過下面的例子闡述清楚。讓我們想像一下<code>(&amp;&amp;)</code>函數，這個函數的作用是實現邏輯「與」的操作。它的定義如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class="line"><span class="kt">True</span>  <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</span><span class="line"><span class="kt">False</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">False</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>根據第一個參數是<code>True</code>還是<code>False</code>，這個函數會有兩種求值規則：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-rule-true.png" alt="" />
<img src="https://hackhands.com/wp-content/uploads/2014/11/and-rule-false.png" alt="" /></p>

<p>現在，再看此表達式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="sc">&#39;H&#39;</span> <span class="o">==</span> <span class="n">&#39;i&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">&#39;a&#39;</span> <span class="o">==</span> <span class="n">&#39;m&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>圖的形式表示如下：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-expr-0.png" alt="" /></p>

<p>它的兩個參數都是 redex，惰性求值將會從左到右求值參數，所以我們從左邊開始規約：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-expr-1.png" alt="" /></p>

<p>現在，因為最左邊的函數變成了一個 redex，因為它的第一個參數現在成了一個構造式。惰性求值總是會先規約最上級節點，所以我們就這麼做。根據<code>(&amp;&amp;)</code>的規約規則，我們會得到：</p>

<p><img src="https://hackhands.com/wp-content/uploads/2014/11/and-expr-2.png" alt="" /></p>

<p>這個表達式屬於模範式，所以我們的求值就完成了！</p>

<p>注意，當我們儘可能先求值<code>(&amp;&amp;)</code>的函數式應用時，我們就不再需要求值第二個參數了，以此節省我們計算所需的時間。有些命令式程式語言也用了類似的技巧，叫作「<a href="http://en.wikipedia.org/wiki/Short-circuit*evaluation">短路求值</a>」（Short-circuit Evaluation）。不過這種短路求值一般被編譯器內部實現，而且只對邏輯操作有效。但在 Haskell 裡，所有函數都能從懶惰求值裡實現到這樣的效果。</p>

<p>一般而言，惰性求值一個表達式得到的最終的模範式和對其貪婪求值得到的結果沒有任何區別。因此我們可以說，不同求值順序並不會關係。然而，惰性求值會因而有更少的求值步驟，而且不像貪婪求值，惰性求值還能處理帶循迴（無窮）的圖。</p>

<h3 id="section-3">文字表示法</h3>

<p>但願把表達式可視化地表示圖能幫你理解惰性求值的基礎，更特別的是因為圖的形式能夠明確表示 redex 的概念和求值順序的重要性。然而，在實際的計算中，畫圖表示是有點太肥了。要追蹤規約，我們一般用 Haskell 語法的<strong>文字表示法</strong>（Textual Representation）來表達。</p>

<p>圖令得我們可以清晰看到共享子圖。在文字表示法裡，我們會給他們用<code>let</code>關鍵字來<em>命名</em>，譬如說，在我們第一個例子裡的<code>square (1+2)</code>的規約可以寫為：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">square</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="kr">in</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kr">in</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>let ... in</code> 語法使我們可以共享子表達式（Subexpression）<code>x = (1+2)</code>。再次注意<code>square</code>是被先規約的，然後才是其參數<code>x</code>。</p>

<p>在我們第二個例子裡，邏輯「與」，變成了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">(</span><span class="sc">&#39;H&#39;</span> <span class="o">==</span> <span class="n">&#39;i&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">&#39;a&#39;</span> <span class="o">==</span> <span class="n">&#39;m&#39;</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kt">False</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">&#39;a&#39;</span> <span class="o">==</span> <span class="n">&#39;m&#39;</span><span class="p">)</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kt">False</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在這個例子裡，我們沒有共享子表達式，所以沒甚麼必要用<code>let</code>關鍵字。</p>

<p>從現在開始，我們都會用文字表示法。</p>

<h2 id="section-4">時間和空間</h2>

<p>我們現在來看惰性求值對 Haskell 程式的時間空間佔用情況。如果你只用過貪婪求值，那麼這些可能會讓你震驚，特別是空間佔用上。</p>

<h3 id="section-5">時間</h3>

<p>求值一個表達式需要多少步？對貪婪求值而言，答案很簡單，對每次函數式應用，我們都把求值函數參數和求值函數體的時間加起來就可以了。而惰性求值呢？非常幸運的，惰性求值會佔的時間總有一個上限：</p>

<blockquote>
  <p><strong>定理：</strong>惰性求值不會執行比貪婪求值更多的求值步驟。</p>
</blockquote>

<p>這意味著當我們分析一個算法的運行時間時，我們總能把它當成是貪婪求值來評估。譬如說，我們可以把一個排序算法用 Haskell 改寫，並保證其算法複雜度和貪婪求值下一樣（在少數情況下甚至更佳）。</p>

<p>然而呢，惰性求值器實現起來會帶來一些額外的代價。對於圖形處理和數值模擬這樣的要求高效能的應用程式，可能放棄惰性求值而直接接觸底層架構實現會更實際一些。即便除此，以和簡潔和模塊化著稱的惰性求值依然在這些領域頑強存在。一種叫作「<a href="http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion">流融合</a>」（Stream Fusion）的編譯器優化策略就能帶給高效率的數組操作一個模塊化，用起來像列表一樣的接口。這個技術就在 <a href="http://hackage.haskell.org/package/vector">vector</a> 庫裡實現了。</p>

<h3 id="section-6">空間</h3>

<p>不幸的是，空間佔用的情況就要複雜多了。問題的關鍵待求值表達式的內存佔用和它規約下來的規範式可以差別很大。因為一個表達式所佔用的空間等價於表示它的圖的所佔用的空間。譬如下面的表達式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">((((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就比其模範式<code>10</code>所佔的空間多得多了。但再看下面表達式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">enumFromTo</span> <span class="mi">1</span> <span class="mi">1000</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者表示為更常見的<code>[1..1000]</code>。這個函數式應用表達式只包含三個節點，當然空間佔用也會比其模範式，列表 <code>1:2:3:...:1000:[]</code> 佔用的空間少多了，因為後者包含上千個節點。</p>

<p>當第一種情況越發嚴重導致無法控制時，我們稱之為<strong>空間洩漏</strong>（Space Leak）。解決方法就是手動控制求值過程，確保表達式僅可能早被求值。Haskell 為這種需求提供了這樣一個組合子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">seq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正如其類型表示的那樣，這個表達式會像<code>const</code>函數一樣返回其第二個參數<sub>1</sub>。然而，對<code>seq x y</code>求值確總會先把<code>x</code>求值到 WHNF 的形式，然後才會繼續求值<code>y</code>。相對的，<code>const</code>函數就沒有必要先求值其參數到 WHNF。</p>

<p>每個 Haskell 程序員都應該知道怎麼用<code>seq</code>組合子，我們先來看一個具有代表性的例子：<strong>嚴格的左褶疊</strong>（Strict Left Fold）。看下面的求和 1 到 100 的代碼。我們用左褶疊，用累加參數（Accumulating Paramter）的方式求和：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>作為參考，在 <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch9.html">Haskell Prelude</a> 裡，<code>foldl</code>函數定義如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl</span> <span class="n">f</span> <span class="n">a</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl</span> <span class="n">f</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那麼上面例子的求值過程如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="kt">:</span><span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="kt">:</span><span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(((</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如上所示，累加參數增長起來愈來愈多 – 空間洩漏。解決方法就是將累加參數保持在 WHNF，下面的修改過的<code>foldl</code>函數就能做到這一點：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl&#39;</span> <span class="n">f</span> <span class="n">a</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">a</span>
</span><span class="line"><span class="nf">foldl&#39;</span> <span class="n">f</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="n">f</span> <span class="n">a&#39;</span> <span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>這個函數的定義可以在 <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:foldl-39-">Data.List</a> 模塊裡找到。現在求值過程變成了這樣：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">2</span><span class="kt">:</span><span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="kr">let</span> <span class="n">a&#39;</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kr">in</span> <span class="n">seq</span> <span class="n">a&#39;</span> <span class="p">(</span><span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">a&#39;</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">])</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在求值的時候，可以看到表達式佔用的空間不再不斷增長下去了。用<code>seq</code>能確保累加參數總是先求值到 WHNF 然後才考慮剩下的元素。</p>

<p>憑經驗來看，<code>foldl</code>會導致空間洩漏，所以你應該用<code>foldl'</code>或者<code>foldr</code>。</p>

<p>順便一提，對於貪婪求值語言，你根本用不著寫上面這種代碼來求和<code>1</code>到<code>100</code>之間的數。因為貪婪求值會先把列表<code>[1..100]</code>規約到模範式，這樣子的空間效率佔用和我們上面低效的<code>foldl</code>版本一樣。要是想要做到高效率，那你必須把這個表達式寫成遞歸循環（Recursive Loop）才行。但得益於惰性求值，在 Haskell 裡，我們可以用通用的列表組合子<sub>2</sub>來「按需」對<code>[1..100]</code>計算。也就說明了惰性求值怎樣帶來更高的模塊化效果。</p>

<p>這個例子裡我們還要注意到另一個重要的概念。我上面演示的求值過程並非完全準確，如果我們這樣定義<code>[n..m]</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">enumFromTo</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="kr">then</span> <span class="n">n</span> <span class="kt">:</span> <span class="n">enumFromTo</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">m</span> <span class="kr">else</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那麼規約到 WHNF 其實是這樣的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span><span class="line"><span class="ow">=&gt;</span> <span class="mi">1</span> <span class="kt">:</span> <span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中第一個參數是待求值表達式<code>(1+1)</code>而非<code>2</code>。在這裡這倒沒有多大關係，關鍵是你要非常小心才能精確追蹤惰性求值過程 – 它也許並不一定按你理想當然地來。真正的<code>enumFromTo</code>的<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#verbatim-226">源碼實現</a>並不是這樣的。特別地，請留意<code>[1..]</code>，它會構建一列<em>不</em>屬於 WHNF 的數。</p>

<p>事實上，我只能說，除非是對像上面這樣簡單的例子，要仔細追蹤惰性求值過程幾乎不可能。所以很難去分析 Haskell 的空間佔用情況。我的建議是只有在你的程序出現嚴重的空間洩漏時才去分析它，用<a href="http://stackoverflow.com/a/3276557/403805">性能分析工具</a>來找到問題產生的源頭所在。一旦確認了問題源頭，就可以用 <a href="http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html">Space invariants</a> 和<code>seq</code>來確保相關表達式被規約城 WHNF，而無須管惰性求值具體是怎樣工作的。</p>

<p>這就是我今天要講的關於惰性求值和它空間佔用相關的內容了。其實還有另外一個有代表性的空間洩漏的例子，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">let</span> <span class="n">small&#39;</span> <span class="ow">=</span> <span class="n">fst</span> <span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="n">large</span><span class="p">)</span> <span class="kr">in</span> <span class="o">...</span> <span class="n">small&#39;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>即使<code>fst</code>函數會把<code>large</code>丟棄，表達式<code>small'</code>還是會保存一個到<code>large</code>的引用。你可能會希望在某個時候把<code>small'</code>規約到 WHNF，這樣<code>large</code>所佔的空間就可以被釋放掉了。</p>

<hr />

<p><strong>譯注：</strong></p>

<ol>
  <li>其實不太一樣，<code>const</code>的類型是<code>a -&gt; b -&gt; a</code>。這裡應該說<code>seq</code>的類型和<code>flip const</code>類似。</li>
  <li>這裡指<code>foldl</code>，<code>foldl'</code>和<code>foldr</code>這些函數。</li>
</ol>

<p>（聲明：此文章的翻譯及發佈已經經過原文作者的許可。此譯文版權歸譯者所有，並在 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 下發佈）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Function Calling Syntax]]></title>
    <link href="http://shouya.github.io/blog/function-calling-syntax/"/>
    <updated>2014-08-03T04:59:14-05:00</updated>
    <id>http://shouya.github.io/blog/function-calling-syntax</id>
    <content type="html"><![CDATA[<p>We use programming languages to indicate a process of
actions/computations. Therefore programming languages tends to be more
procedual. In other words, they are used to indicate how a thing is
done.</p>

<p>Just as the role of verbs in a nature language sentence, an action is
the most essential part of ‘doing a task’ in programming language. Of
course the syntax of a programming language could be complex. I’d be
here to discuss only the simplest cases of function calling among
different programming languages.</p>

<!-- more -->

<p>Here’s a table of the terms used in different paradigms.</p>

<table>
  <thead>
    <tr>
      <th>Paradigm</th>
      <th>Term for the Acting Object</th>
      <th>Term for the Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Imperative</td>
      <td>Function/Procedure</td>
      <td>Call/Invoke</td>
    </tr>
    <tr>
      <td>OO</td>
      <td>Method</td>
      <td>Invoke/Send Message</td>
    </tr>
    <tr>
      <td>Functional</td>
      <td>Function/Closure</td>
      <td>Apply</td>
    </tr>
    <tr>
      <td>Stack</td>
      <td>Operation</td>
      <td>Act</td>
    </tr>
    <tr>
      <td>Lambda Calculus</td>
      <td>Lambda/Combinator</td>
      <td>Apply</td>
    </tr>
  </tbody>
</table>

<h2 id="object-oriented-languages-ruby-c">Object Oriented Languages (Ruby, C++)</h2>

<p>OOP is an analog of object manipulation in the real world. Actually,
semantically <code>foo.bar(baz)</code> does not mean <code>foo</code> does an action <code>bar</code>
on <code>baz</code>. Rather, according to the OOP mechanism, it should be
regarded as a message <code>bar</code> send to the actor <code>foo</code> with argument
<code>baz</code>. Look at the code snippets below in Ruby and C++.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="ruby"><span class="line"><span class="vg">$stdout</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>How would we translate them in English? The result is probably similar
to these:</p>

<blockquote>
  <p>(The computer) puts “hello” on $stdout.</p>

  <p>(The computer) pushes “hello” into vec.</p>
</blockquote>

<p>In such invocations, obviously the subject is uslally omitted because
we’re always ordering the computer to do the actions.
The receivers, or target objects, are put at the front. Then
follows the actions we want to apply on them. And finally the
arguments, or carried objects.</p>

<p>Notice that the in Ruby the object is often omitted because it is
implied in the current context (<code>self</code>). And in C++ <code>this</code> is
sometimes omitted if we’re operating in a method within the same class.
It is similar to the case omitting object in a nature language when
we’re in a specific environment. For example, if we are working on a
task and then we say ‘finished’, the object can be understood as the
task we were working on.</p>

<h2 id="stack-basedconcatenative-languages-dc-factor-assembly">Stack-based/Concatenative Languages (dc, Factor, Assembly)</h2>

<p>The core of stack-based languages is the operation on a stack involves
pushing and popping.</p>

<p><code>dc</code> is a tiny calculator. The language of it is succinct and handy. Here’s an example:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="o">[</span>hello<span class="o">]</span>p
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The square brackets quotes a string of characters and push them into a
stack. Then the operation <code>p</code> pops the string out and then prints it.</p>

<p>Stack-based language can be as simple as dc, while also can be as
complex as Factor. Yet either of them have the same syntax
structure. The following Factor code reverses an array.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="n">reverse</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We cannot directly translate them into one sentence of nature
languages because the invocation of a function should not be regarded
as a single process. As how we can see the process more clearly in
Assembly language:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">push</span> <span class="mh">0x0001</span>   <span class="p">(</span><span class="mh">0x0001</span> <span class="n">points</span> <span class="n">to</span> <span class="s">&quot;world&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">push</span> <span class="mh">0x0010</span>   <span class="p">(</span><span class="mh">0x0010</span> <span class="n">points</span> <span class="n">to</span> <span class="s">&quot;hello, %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">call</span> <span class="mh">0x0100</span>   <span class="p">(</span><span class="mh">0x0100</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="err">`</span><span class="n">printf</span><span class="err">`</span> <span class="n">function</span> <span class="n">in</span> <span class="n">libc</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The invocation of such functions can be seen as a kind of
argument-free operation. Their arguments are pushed to stack before
the function invocations and in the function the arguments would be
popped out to be manipulated.</p>

<p>If we still want to see the process of invocation as a single, we
would derive a pattern that the actions, or the verbs, are always put
at the last.</p>

<h2 id="functional-languages-scheme">Functional languages (Scheme)</h2>

<p>I consider the syntax of function invocation an opposition to the
stack-based languages. Unlike the invocation syntax in stack-based
languages, which put the action at the last, functional programming
languages tend to pose the action/function as precedent to the
arguments. I guess this phenomenon originates from the application
syntax of FP’s ancestor lambda calculus.</p>

<p>In Scheme, a typical hello world program looks like:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="scheme"><span class="line"><span class="p">(</span><span class="nb">display </span><span class="s">&quot;hello world&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It just looks like the stack-based language. In fact we can convert
functional operations into stack operations through
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation-passing style transformation</a>,
so easily convertible into Assembly. In fact this technique is often
used in Scheme compilers.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://factorcode.org/">Factor Programming Language</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Whitespace_(programming_language)">WP: Whitespace (PL)</a></li>
  <li><a href="http://www.linuxmanpages.com/man1/dc.1.php">dc (1) - man</a></li>
  <li><a href="http://concatenative.org/wiki/view/Concatenative%20language">Concatenative Languages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Stack-based">WP: Stack-based</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Stack-oriented_programming_language">WP: Stack-oriented Programming Languages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Word_order">WP: Word Order</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻譯：如何幸福起來]]></title>
    <link href="http://shouya.github.io/blog/how-to-be-happy/"/>
    <updated>2014-07-28T09:17:07-05:00</updated>
    <id>http://shouya.github.io/blog/how-to-be-happy</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文由 lukeprog 發表於 <a href="http://lesswrong.com/lw/4su/how_to_be_happy/">LessWrong</a>。
關於注釋和引用，請參見原文。</p>
</blockquote>

<p>有一天一個同事對我說：「盧克，你應該是我見過的最幸福的人了！你怎麼做到每時每刻都這麼開心的？」</p>

<p>他可能只是在誇張修辭，不過我還是回答了很長。曾經的大部分人生是不令我開心的，我甚至好幾次考慮過自殺。然後我花了兩年研究幸福科學。而現在，幸福是我的自然狀態。我甚至都不記得甚麼時候我有達 20 分鐘以上的不開心過。</p>

<p>這類改變並非人人都會有，甚至大部份人都不會有（<a href="http://lesswrong.com/lw/9v/beware_of_otheroptimizing/">beware of other-optimizing</a>），但不妨一試！</p>

<p>我們都希望開心些，而且變得開心對其他事情也有好處。譬如說，開心有利於人的身心健康，能提高創造力，還能使你更好地做決定。（畢竟當一個人不開心時很難做到理性思考。）所以呢，本篇作為<a href="http://lesswrong.com/lw/3nn/scientific_selfhelp_the_state_of_our_knowledge/">如何</a>系列的一部分，讓我們回過頭來審視一下<strong>幸福科學</strong>。</p>

<!-- more -->

<h2 id="section">幸福的因素</h2>

<p>以前，我就留意到過有很多關於 <em>主觀狀態</em> 因素的研究（自己對自己幸福和生活滿意度的評價）。</p>

<p>但僅僅是相關性的研究遠遠不夠，我們還希望知道是甚麼 <em>導致</em> 了幸福。這一點很難測評，但是我們還是知道一點的。</p>

<h2 id="section-1">幸福，性格，以及技能</h2>

<p>內在因素決定了大約 50% 的幸福度差異。可能結果令人意外，中彩票的人和剛剛四肢癱瘓的患者並不像想像中的那樣誇張地變得狂喜或沮喪。所以，我們認為內在因素決定幸福感程度，表現在性格的塑造上，而據研究，性格的很大一部份來自遺傳。</p>

<p>所以哪種性格特徵和幸福感相關度最高呢？內向和外向是最佳的幸福感指示計，類似的還有自身嚴謹程度，他人認同度，自尊，以及樂觀程度。</p>

<p>那麼如果你沒有這些性格特徵呢？首先要說的是，你可能可以在不知道自己已經達成目的的情況下實現擁有這些令你幸福的特徵。譬如說，內向可能會看做一種 <em>社交技能的缺失</em>。如果你決定開始<a href="http://www.amazon.com/Social-Skills-Picture-School-Beyond/dp/1932565353/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131103628&amp;linkCode=as2&amp;tag=lesswrong-20">學習</a>提高自己的社交技巧，那麼你會發現你比想像中的自己要外向多了！（此乃親歷者談。）類似的，你都能做得到提高自己謹慎度，他人認同度，自尊，以及樂觀程度。這些都僅僅是和性格關聯，而非被性格決定的。某種程度上你都可以學習（或者甚至只是單單模仿）這些技巧來提高自己的幸福感。</p>

<p>第二點要說的呢，如果你缺乏這些性格特徵，並不一定會讓你不幸福。</p>

<h2 id="section-2">幸福是主觀的和對比性的</h2>

<p>幸福感並不由客觀因素決定，而是由你的主觀 <em>感受</em> 決定。</p>

<p>幸福同時也是對比性的。在山西太原你可能月入五千元（太原人平均月收入三千元）就可以達到比上海月收入八千元（上海人均月收入一萬元）要幸福得多。(注)</p>

<p>當然幸福和其他因素也有關。譬如說你的 <em>期望</em> 。我們非常不擅於預測我們未來的能力。我們常常高估失戀，升職失敗或得病帶來的傷痛程度。我們也常常高估這類，譬如說炒股賺錢，升職，或者買到超值大禮包帶來的快樂。所以為了變得更幸福，最好降低對這類快樂的期望值。</p>

<p>(譯注：此處數據為捏造，僅僅為了傳達作者希望表達的意思。)</p>

<h2 id="section-3">神馳和注意意識</h2>

<p>你可能聽說過一些著名的研究表明人們在「<a href="http://en.wikipedia.org/wiki/Flow_(psychology)">神馳</a>」的狀態下是最幸福的。當人專注於某項有趣的，有挑戰性的，從根本上帶來成就感的工作時，就會進入一種稱之神馳的狀態。換句話說，就是「忘乎自我」，或者如運動員常講的，「進入狀態」。</p>

<p>你需要做和你的技能相符合的工作來找到你的「神馳」狀態。當工作太難，你會被矬敗。而當工作太容易，你會覺得無聊。只有那些具有挑戰性卻又能夠完成得了的工作會讓你感覺很棒。這令我想起了 <a href="http://www.youtube.com/watch?v=2-9D2qUHN-E">Super Trooper</a>，她是一個薯片廠的工人，在無聊的工作中，她會收集那些碰巧和名人的臉長得有幾分相似的薯片來玩。</p>

<p>如果你正在被負面情緒困惑，那麼進入神馳的狀態可能是最有效的良藥。和大眾的直覺相反，強迫自己進行積極正面的思考往往會適得其反。自己讓自己不想不開心的事情是不可能的。如果你刻意讓自己不想著這件事，你就會下意識強調這點，繼而你又會情不自禁地想起這件事了。</p>

<p>在處在「忘乎自我」的時候，你的幸福感會非常高。然而研究表明，當你無法進入神馳態時，「注意意識」也能有效減少慢性病痛和抑鬱帶來的痛苦，減少壓力和焦慮，還有一系列其他積極的效果。要達到「注意意識」就要踏出你在做的事情一步，除了關心你在做的事情之外，還注意到自己的當前狀態，留意當前的動作，想法，感受等等。</p>

<h2 id="section-4">如何愈來愈幸福</h2>

<p>綜上，幸福一件超級複雜的事情。其實甚至更麻煩，我們還要區分開<a href="http://www.ted.com/talks/daniel_kahneman_the_riddle_of_experience_vs_memory.html">體驗性幸福和記憶性幸福</a>，但在這篇短文中我只能稍稍提及一些皮毛。總之，天堂無捷徑，沒有辦法能讓你在三分鐘內永原和悲傷告別。</p>

<p>此外，不同的人有不同的幸福起來的方法。抑鬱症是由於體內化學物質不平衡導致的，所以對他們而言可能吃藥必學習社交技巧更有效。而即使一個健康，外向，謹慎且受人認同的女人，如果和不合適的人結婚，也許也會不那麼幸福。一些在父母不注意培養健康的自尊發展的環境下成長的孩子，還要花費巨大的精力重新拾回自己缺失的東西。對一些人而言，幸福之路悠長；而對另一些人而言，幸福卻容易很多。</p>

<p>下面我將給出並評論一些對提升幸福度有關的方法，有一部份上面已經提到了，還有很多沒有提到的。</p>

<p>這些方法大概以從重要和效果明顯到不那麼重要和效果不那麼明顯排序，給於我自己對幸福科學的學習理解。你需要自己想清楚的是你自己究竟是誰，甚麼令你開心，甚麼令你難過，還有下面哪些方法對你來說採取起來最便捷。同時，這些方法對<a href="http://lesswrong.com/lw/3w3/how_to_beat_procrastination/">治療拖延症</a>也有不錯的效果。</p>

<p>下面是十四個令你愈來愈幸福的方法：</p>

<ol>
  <li>如果你有心理疾病，譬如抑鬱症，焦慮症，健忘，精神分裂，或者其他問題，<em>請先諮詢專家尋求幫助</em>。<a href="http://www.liveyourlifewell.org/go/live-your-life-well/help">這裡是一些指引</a>。</li>
  <li>即使你不需要專家協助，你也可以受益於一些自我探索，或者聽從一些像 <a href="http://naturalism.org/consulting.htm">Tom Clark</a> 一樣的簡化主義者，自然主義者諮詢師給的 <em>開始階段的指示</em>。</li>
  <li>開發 <em>外向</em> 相關的技能和習慣。首先，買一些得體的衣服並學習優雅的著裝。如果你是男孩子，<a href="http://www.amazon.com/Details-Mens-Style-Manual-Ultimate/dp/159240328X/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0131103628&amp;linkCode=as2&amp;tag=lesswrong-20">讀讀</a>起來。</li>
  <li>學會變得 <em>自尊</em> 和 <em>樂觀</em> 起來。這可能有點微妙。首先，太過自尊會導致有害的自戀。其次，理性主義者可能會不習慣採用一些標準方法（偏向自我性思考，誇大自己的光榮一面，把自己想得更弱）來欺騙自己或者<a href="http://wiki.lesswrong.com/wiki/Anti-epistemology">違背自我認識</a>描述的一樣。</li>
  <li>提升你的認同度。簡單來說，增強你和他人的共鳴（empathy）能力。但很不幸現在還沒有這類有效的（科學）方法。一般的建議是試試從他人角度看待問題，多替別人著想，把他們想作比自己不幸的人。<a href="http://www.rootsofempathy.org/">共鳴之源</a>供參考。</li>
  <li>變得嚴謹起來。嚴謹的性格對很多事情都有幫助，譬如組織事務，工作勤勉，可靠度，計劃能力等等。<a href="http://lesswrong.com/lw/3w3/how_to_beat_procrastination/">克服拖延症</a> 之類的書籍也對他們的組織性和可靠的鍛鍊有所幫助。</li>
  <li>培養感恩的習慣。珍惜生活的每一刻。多花時間想一下開心的回憶。每天結束前，列出五樣你感謝的對象，頭頂的屋頂，活在一個富裕的國家的運氣，此網站（Less Wrong）的存在，巧克力的美味，高潮的快感等等這些。無論如何，雖然聽起來很幼稚，但是的確有效。</li>
  <li>找出你的生活的 <em>目的</em> 並且為之生活。宗教帶給人的好處之一在於給人們一種活著的意義和目的。並不需要神的啟示，你要自己確定好是甚麼驅使著你。你可能要在這上面花點工夫，各個領域都要考慮。當你找到一條能使你充滿動力的路，那就順著它走吧。（當然，你也可能找到很多生活的目的。）有目的，有追求的意義，這樣有很多好處。「尋找你生活的目的」描述了針對不同人的不同的方法。這點不會在幸福文學作品被強調，但對我自己而言，尋找出使我充滿動力的生活目的確確實實改變了我的人生。</li>
  <li>找個 <em>充實</em> 的工作。極少人在以自己喜愛的事情為職業維持生計。做到這點可能非常困難。你可能留意到這個列表上的其他十件事情都 <em>首先</em> 要求你有一個充實的工作。要找出你究竟喜愛甚麼和適合甚麼工作，做一個 <a href="http://www.bigjobportal.com/riasec/">RIASEC</a> 也能幫你找到一個熱門的並符合你性格的工作。
在美國，<a href="http://www.onetonline.org/">O*NET</a> 也能幫妳找到一個熱門的並符合妳性格的工作。</li>
  <li>增進和你的 <em>戀人</em> 的感情，要麼就再找一個。如找一個充實的工作一樣，這一點也很難做到，但能帶來很大影響。如果你總是覺得你們之間的關係平淡而且沒有提升的空間，你可能會想要把愛情放置一邊並自己一個人工作，然而這會導致你們之間關係進一步惡化。如果你是認真對待你的戀人的，那麼你可以有很多方法來提升你們之間的關係。雖然<a href="http://zh.wikipedia.org/wiki/%E7%A9%8D%E6%A5%B5%E8%81%86%E8%81%BD">積極聆聽</a>的方法被廣為接受，它並不能保證維持良好的關係。被實驗確認的有助於提升滿足感的方法有：(1) 經常和你的戀人做些新奇的事情，(2) 向你的戀人聊積極的事情的次數要超過消極事情 5 倍以上，(3) 每週寫下你認為你和你的戀人之間優於其他人的原因，(4) 接受所有你的戀人提出的批評並附以一兩條對他好的地方的誇讚，以及 (5) 常常和對方的眼睛對視。</li>
  <li><em>出門</em>，讓你的身體動起來。這樣可以培養你的注意力，並且對你的身體也有好處。</li>
  <li>多花些時間處在 <em>神馳</em> 狀態。放棄一些超過你能力的，不可能的任務。並把簡單無聊的任務變得有挑戰起來，你可以通過把這些工作變成遊戲，或者自己在裡面添加額外的挑戰。</li>
  <li>養成 <em>鍛鍊注意意識的習慣</em>。當你無法進入神馳的工作狀態的時候，走出你自己的工作，專注你的做法，行為，手段，你的心理機能，以及留意你是如何把這些工作的動作轉換並達成你的目標的。<a href="http://www.wikihow.com/Meditate">冥想</a>也許有用。</li>
  <li><em>避免消費主義洗腦</em>。你不能讓你擁有的東西反過來控制你。消費主義帶來的更多是不開心。很不幸的是，自從你出生，你就被活在這樣一個消費主義時代。要希望扭轉這一點，你可以看看 <a href="http://en.wikipedia.org/wiki/Edward_Bernays">Edward Bernays</a>。在那之後，你也許會把很多物品賣掉或拿去送人，更重要的是，這能徹底改變你的購物習慣。</li>
</ol>

<p>注意，把尋覓幸福當作 <em>目標</em> 可能會帶來反效果。很多人都說自己在不斷檢查自己是否幸福的時候下變得反而沒那麼幸福了 – 有點像「神馳」的時候一樣。倒不如找一個實際目標作為終點，而幸福作為其副作用就好了。</p>

<p>記住：只是在網路上讀這篇文章永遠不會帶給你幸福。只有當你去為幸福去 <em>實踐</em> 這些研究結果的時候，你才能感受到它。</p>

<p>祝好運！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 下 GFW 的 DNS 投毒解決方案]]></title>
    <link href="http://shouya.github.io/blog/dnscrypt-plus-dnsmasq-solution/"/>
    <updated>2014-07-25T13:27:35-05:00</updated>
    <id>http://shouya.github.io/blog/dnscrypt-plus-dnsmasq-solution</id>
    <content type="html"><![CDATA[<p>這篇日誌紀錄我在 Gentoo Linux 下配置 DNS Crypt + DNSmasq 的過程。</p>

<h2 id="section">方案</h2>

<p>DNSCrypt 是 OpenDNS 推出的一個用來加密 DNS 請求的代理，我用這個來繞開 GFW 的檢查。dnsmasq 是一款的 DNS 服務器，我主要用其提供 DNS 緩存的功能。</p>

<p>我將用 dnsmasq 設置本地的 DNS 服務器，然後配置 dnsmasq 從 dnscrypt 獲得結果並返回給請求者。而 dnscrypt 會把來自 dnsmasq 的請求加密丟到 opendns 的服務器，然後把解析結果返回回來。</p>

<p>那麼 dnsmasq 將偵聽 <code>53</code> 端口，而 dnscrypt 的端口隨意，只要和 dnsmasq 裡的配置匹配就可以了。我隨便用了 <code>1053</code> 作為 dnscrypt 的端口。</p>

<p>最後，把系統的 DNS 服務器設置為本機就可以了。</p>

<!-- more -->

<h2 id="section-1">背景</h2>

<p>長期以來我都在使用 <a href="https://code.google.com/p/openerdns/">Opener DNS</a> 提供的免費 DNS 服務器
<code>42.120.21.30</code>，這個服務器工作正常，響應速度也很快，但是我在使用中遇到一個不知怎麼解決的問題而頭疼。那就是，很多 CLI 工具，包括
wget 和 curl，在設置了 Opener DNS 為 DNS 服務器後，都無法解析出任何地址，然而另一些工具，包括 nslookup 和
dig 等，卻沒有任何問題。而當切換為其他 DNS 服務器之後，wget 和 curl
之類的卻又可以正常解析了。這是很奇怪的現象，導致我後來連 emerge 都要開著 proxychains，甚是不方便。</p>

<p>今天下午心血來潮想隨手把這個問題解決掉。首先考慮的是用 iptables 把 GFW 發回來的假的 DNS
請求結果丟掉，只留正常的結果。網路上這種資源不少，我四處抄來抄去縫縫補補拼了一份 iptables 的配置，並丟在
<a href="https://gist.github.com/shouya/c798a3aa7fb9a2a9b7fa">Gist</a> 上了。但問題是，好像 GFW
不光返回假的 DNS 結果，有時還回丟棄正確的結果，因為常常 DNS 請求只會返回假的結果，被 iptables
丟棄後導致請求超時，反而沒有效果。這種方法不能保證工作，而且速度很慢。</p>

<p>經測試 DNS over TCP 效果不錯，速度快而且相對穩定。所以我試了一下用 pdnsd 代理所有 DNS 請求並用 TCP 查詢上游 DNS
服務器。但是當我安裝了 pdnsd 之後，不知哪裡出錯了，總是在其偵聽本地端口時提示兩個</p>

<pre><code>[Errno 97] Address family not supported by protocol
</code></pre>

<p>錯誤，怎麼配置都不行，無論是 example 裡的還是 minimal 都無法解決。看起來可能是我系統配置的問題，或者是 pdnsd 的
bug。但我不是很確定到底怎麼回事，而且網路上好像沒有人有類似的情況，所以也不好上報。</p>

<h2 id="dnscrypt">安裝配置 dnscrypt</h2>

<p>首先在 gentoo 的官方 portage 源裡並沒有 dnscrypt-proxy 這個程式， 所以需要手動加入 gentoo-zh 這個
overlay。 關於怎麼添加使用 overlay 這裡就不詳述了。</p>

<p>所以是常規地：</p>

<pre><code>$ sudo emerge -av dnscrypt-proxy
</code></pre>

<p><code>dnscrypt-proxy</code> 會依賴於一個叫 <code>libsodium</code> 的庫。</p>

<p>在我的機器上 <code>libsodium</code> 和 <code>dnscrypt-proxy</code> 編譯時（準確說應該是<code>configure</code>的時候）會出一個錯誤：</p>

<pre><code>checking if gcc -std=gnu99 static flag -static works... *** Error in `/usr/bin/ld': corrupted double-linked list: 0x099a4178 ***
</code></pre>

<p>在 Github 上看到有人同樣遇到了 libsodium 的<a href="https://github.com/jedisct1/libsodium/issues/120">這個問題</a>，原因是 gcc 的 <code>-pie</code> 和 <code>-static</code> 不兼容，
而解決方法是在 <code>configure</code> 時禁用 <code>pie</code> 就好了。所以手動改這兩個包的 ebuild 文件，在 <code>econf</code> 最後加上 <code>--disable-pie</code>。
於是兩個包都可以被編過了。改過後再 ebuild 一次 manifest，就可以正常安裝這兩個包了。</p>

<p>dnscrypt 的配置位於 <code>/etc/conf.d/dnscrypt-proxy</code>，編輯使之偵聽於 <code>1053</code> 端口。我的配置如下：</p>

<pre><code>DNSCRYPT_LOCALIP=127.0.0.1
DNSCRYPT_LOCALPORT=1053
DNSCRYPT_USER=dnscrypt
DNSCRYPT_PROVIDER_NAME=2.dnscrypt-cert.opendns.com
DNSCRYPT_PROVIDER_KEY=B735:1140:206F:225D:3E2B:D822:D7FD:691E:A1C3:3CC8:D666:8D0C:BE04:BFAB:CA43:FB79
DNSCRYPT_RESOLVERIP=208.67.220.220
DNSCRYPT_RESOLVERPORT=443
</code></pre>

<p>基本就是默認配置。</p>

<p>把 dnscrypt 跑起來：</p>

<pre><code>$ /etc/init.d/dnscrypt-proxy start
</code></pre>

<p>然後用 dig 測試之是否工作：</p>

<pre><code>$ dig @127.0.0.1 -p 1053 twitter.com
</code></pre>

<p>如果得到正確結果，則說明 dnscrypt 配置好了。</p>

<h2 id="dnsmasq">安裝 dnsmasq</h2>

<p>安裝：</p>

<pre><code>$ sudo emerge -av dnsmasq
</code></pre>

<p>因為我幾乎不怎麼用國內服務，所以也用不著為國內服務設置國內的 DNS 來提高效率。所以我用 dnsmasq 純屬為了其緩存。</p>

<p>dnsmasq 的配置位於 <code>/etc/dnsmasq.conf</code>，這是我的配置：</p>

<pre><code>no-resolv
no-poll
server=127.0.0.1#1053
</code></pre>

<p><code>no-resolv</code> 讓 dnsmasq 不去理睬 <code>/etc/resolv</code> 裡的配置。<code>no-poll</code> 讓其不檢測更新。<code>server</code> 裡對應的是 dnscrypt 的本地端口。</p>

<p>這樣就可以了，跑起來：</p>

<pre><code>$ /etc/init.d/dnsmasq start
</code></pre>

<p>試試：</p>

<pre><code>$ dig @127.0.0.1 -p 53 twitter.com
</code></pre>

<p>沒問題的話就說明 dnsmasq 已經工作了。</p>

<h2 id="section-2">完成</h2>

<p>設置系統 DNS！</p>

<pre><code>$ echo nameserver 127.0.0.1 | sudo tee /etc/resolv.conf
</code></pre>

<p>所以下一步，開機啟動來一發！</p>

<pre><code>$ sudo rc-update add dnscrypt-proxy default
$ sudo rc-update add dnsmasq default
</code></pre>

<p>搞定，去玩吧。</p>

<h2 id="section-3">參考資料</h2>

<ul>
  <li><a href="https://github.com/jedisct1/libsodium/issues/120">Issue #120: arch linux i686 build errors: corrupted double linked lists - jedisct1/libsodium</a></li>
  <li><a href="http://blog.sina.com.cn/s/blog_656126b20101ia39.html">详细安装配置 dnscrypt 和 dnsmasq</a></li>
  <li><a href="http://lilydjwg.is-programmer.com/2012/11/10/dnscrypt-dnsmasq.36288.html">dnscrypt + dnsmasq</a></li>
</ul>

<h2 id="section-4">一些可能有用的鏈接</h2>

<ul>
  <li><a href="https://code.google.com/p/openerdns/">Opener DNS - Google Code</a></li>
  <li><a href="http://www.opendns.com/about/innovations/dnscrypt/">DNSCrypt - OpenDNS</a></li>
  <li><a href="http://en.wikipedia.org/wiki/DNS_spoofing">DNS spoofing - Wikipedia</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93#.E4.B8.AD.E5.9B.BD.E9.98.B2.E7.81.AB.E9.95.B7.E5.9F.8E">域名伺服器快取污染 - 維基百科</a></li>
  <li><a href="http://igfw.net/archives/10890">如何本地避免GFW的DNS污染</a></li>
  <li><a href="https://gist.github.com/wen-long/9580811">Gist: wen-long/DNS.md</a></li>
  <li><a href="https://wido.me/sunteya/use-openwrt-resolve-gfw-dns-spoofing">openwrt 上通过 pdnsd 和 dnsmasq 解决 dns 污染</a></li>
  <li><a href="http://www.v2ex.com/t/75568">dnsmasq如何强制用tcp与上游dns服务器通讯？</a></li>
  <li><a href="http://mariotaku.wordpress.com/2011/09/18/use-dnsmasq-easier-than-pdnsd/">比pdnsd更更更简单！用dnsmasq给你正确的DNS结果！</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Brief Journal About Learning Coq]]></title>
    <link href="http://shouya.github.io/blog/a-brief-journal-about-learning-coq/"/>
    <updated>2014-07-04T12:08:34-05:00</updated>
    <id>http://shouya.github.io/blog/a-brief-journal-about-learning-coq</id>
    <content type="html"><![CDATA[<p><em>This article is completely an informal journal about my learning process on
Coq. It is just created as my whim prompted. Please don’t academically refer
any part of it as studying material to learn Coq.</em></p>

<h2 id="pre">Pre</h2>

<p>I first heard of Coq in my admiring mathematician,
<a href="https://twitter.com/txyyss">@txyyss</a>’s tweets. At the time I saw him talked
that he’s glad and immersed in re-proving all the theorems he had learned.
He also said, as deepening in Coq, he found a boost on other related
academic aspects. Driven by curiosity, I went to know about what a heck Coq
is. Then I saw it describe itself as a ‘Proof Assistant’. I felt something
uneven about it. Looking through all the programming languages I had
learned, even those as logically abstract as Prolog, were not capable to do a
proof.</p>

<!-- more -->

<p>At the time I was still in my high school. I just downloaded a Coq environment
on my
machine in the computer lab. Then I tried to follow the
<a href="http://coq.inria.fr/V8.1/tutorial.html">official tutorial guide</a> to explore how
to use it to do a proof. The experience was terrible. The official tutorial
was
completely not-novice-friendly, at least to me. I followed it for a section,
doing what the guide instructed me to do, and they all works. I learned <code>0</code>
has a
type of <code>nat</code>, and <code>nat</code> has a type of <code>Type</code>, and that’s all, no more things
substantial. The following sections are tough enough so I don’t even know what I
was doing. Thus I gived it up.</p>

<p>My curiousity was evoked the second time by the <span title="狂讚士">“berserk-faver”</span> <a href="https://twitter.com/javranw">@javranw</a>. He
express similar opinion and excitement as @txyyss towards Coq. At the time it
was the onset of the long summer vacation after high school graduation. I got
plenty of free time to learn the extracurricular interesting stuff. So I
decided to pick Coq up again.</p>

<h2 id="on">On</h2>

<p>This time I found a Virginia University course about Coq, published as
<a href="https://www.kevinjsullivan.com/00-syllabus">website</a>:
I decide to start here because I
saw the syllabus are well arranged and besides, I thought the course material
might be easier for a layman to get started.
([link to the tutorial]
(http://kevinjsullivan.org/Courses/Reasoning/L02_Intro.html))</p>

<p>The study curve of this course seems still steep. In the other words, the
course goes complicated soon after it teaches some common-sense-like
knowledge that I can hardly catch up with it. Besides, I don’t think the
guide is written in obvious and clear language.</p>

<p>I had also checked the well-known
<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/">Software Foundations</a>. And
I discovered it’s actually more clear and friendly to novice like me. So I head
on to study following this guide.</p>

<p>The progress was slow. While a few of the exercises, mostly rated 3+
stars, are really challenging. I tried to work on all exercises myself. And I
maintained a <a href="https://github.com/shouya/sf-sol">Github repository</a> to publish
my solutions.</p>

<p>I usually study it after midnight. So I could have a quiet and distract-free
environment for me to think. I was concentrated while doing the proofs. It
feels good. Especially after proving a difficult theorem, I acquired great
pleasance from the accomplishment. I can’t describe the the feeling as I
first proved the commutation law of multiplication, which took me about 3 hours.</p>

<p>In fact, in each new chapter I learned something new about Coq. Yet, as I
turned to the chapter of
‘<a href="http://www.cis.upenn.edu/~bcpierce/sf/current/Logic.html">Logic</a>’, I learned
not only about Coq skills but also a mode of critical thinking towards the
base, the logic, and the logic of logic. I learned the logic system also need
an axiom, which subverted my view to logic before. A logical proposition can
either be true or false, and besides, it cannot guarantee to be in one of these
two states only. This axiom that establishes the whole logic system can be
expressed in many forms. An optional exercise in the guide is to prove they are
equivalent. Rated full 5 stars, this question is the most difficult exercise
I’ve met. Anyway I still finished 4/5 of it.</p>

<h3 id="sequela">Sequela</h3>

<p>I once tweeted (translated into English)
<a href="https://twitter.com/54c3/status/478478760371429376">link</a>:</p>

<blockquote>
  <p>I just dreammed in the nap. In the dream there was an arena-like place. The
fighters used with logic symbols as weapons. They battled, and exerted
various tactics. As a round over, they proved some theorem. #dream #coq
#broken_brain</p>
</blockquote>

<p>Really. My mind is full of logics in the days I study Coq. I can feel it
vividly that my mind start to ask about the logic of everything I see. Logic
would spring from my mind on every affairs. That is very interesting experience.
Especially after immersed in Coq for a whole night, I see everything and think:
can I prove it?</p>

<p>Somewhat I like that feeling :)</p>

<!--

Of course I still put my girlfriend Cres in the first position. I tried to
spare some times accompanying with her. But to do this I have to convince
myself in a illogical way (because there is no logic): my emotion will
nevertheless take all control of my flesh body than my ration in coping with
matters related to my girlfriend. So I stop thinking about Coq while chatting
with her.

I will have various affections while talking to her. However,
after she sleep and I get back to the world of Coq, every emotional sense just
go vain.

Oh... I can't let Cres know about this... She'll think that I'm belittling her.
Actually I'm regarding her in the most important position to me. Anyway. I'll
just comment it out. Nobody will read this paragraph :)

-->

<h3 id="intelligence">Intelligence</h3>

<p>In an ideal condition, to prove a theorem, I will first understand the theorem
itself, and conceive a way to prove it. Then I’ll translate the idea into
tactics in Coq. However, as I got more and more practiced in Coq, I do not
always follow this way to prove a theorem. For some simple theorems, I can prove
them without understanding them. I know what tactic should be used under
specific condition. I would only concern about the hypotheses and the goals. My
empirical intuition will guide me to the most likely way to prove them.</p>

<p>I first realized the situation while I was proving a theorem related to
<code>override</code> function in the next chapter after <code>override</code> is defined. I then
disinclined to review the definition of <code>override</code> again, because it’s a little
bit convoluting. Naturally I tried to prove it without reviewing the definition
of <code>override</code>. Also naturally I did it successfully. I realized the problem
just as I finished the proof. The first impression I raised is that I felt
panicky on myself. While as I then carefully checked the definition of
<code>override</code> function and the proof process, I found that’s already the optimal
way. I will do exactly the same after I understood the definition.</p>

<p>At that time, I had a sense that I was no longer a human, but a proving
machine. I knew the tactics, and I knew when to use them. Prooving theorems
seemed to be a machinery work. I was somewhat depressed on this kind of
loss-of-intelligence.</p>

<p>However, sometimes I thought in the other way. If I could grasp my empirical
intuition, turn them into substantial rules, can I make a program that can
prove whatever I can prove as a human? The program will never understand a
theorem, but they can prove them in a Coq’ly logical way.</p>

<h2 id="comments-on-the-design">Comments on the design</h2>

<p>I thought the design is the point I want dissing about Coq mostly. Although
powerful, Coq’s design on its syntax is as terrible as its “mother language”
OCaml, and even worse.</p>

<p>It might be improper for me, as a totally novice, to comment on Coq’s design. I
know I’m yet far from qualified to do that. Nonetheless I still want to talk a
little bit about it.</p>

<p>Of course, I know neither syntax nor some mechanism are the most crucial
things to a programming language. However, my steps followed the road of Ruby
→ Scheme → Haskell. Studying those PLs was pleasing, at least they
give me a sense of elegance. In contrast, I see Coq as a work from scratch
than being well designed.</p>

<h3 id="type-naming">Type naming</h3>

<p>Actually, types in Coq are not as obvious as in other PLs. Unusual types
are ubiquitous. I use ‘unusual type’ just because I don’t know how to descibe
them. The nature of each type are not just transparent, but also must be
defined by me manually. (At least I’m instructed to do so following the guide.)</p>

<p>The case of type names, in the beginning, confused me. Why are the type names
<code>nat</code>, <code>bool</code> lower-cased while <code>Set</code>, <code>Type</code>, <code>Prop</code> capitalized? I knew I
won’t know the why of every unknowns just as I touched it. So I memorized it
in a silly mode: names of the types we need to define by ourself are
lower-cased, and the others are capitalized.</p>

<p>This gave me the first intuition about differnet kinds of types.
While then I walked through the guide, and gradually realized the difference
between these two sort of types.</p>

<p>Here’s correct<sup>(?)</sup> understanding about it. <code>nat</code> and <code>bool</code> are
lower-cased because they are <em>inductive</em> types. In the other words, they are
defined in a specific number of cases. Contrarily, we don’t see this feature in
<code>Set</code>, <code>Type</code>, nor <code>Prop</code>, which are what we called <em>non-inductive types</em>.</p>

<h3 id="tactic-naming">Tactic naming</h3>

<p>Well, I shall just pose here the most frequently used tactic names.</p>

<p><code>simpl</code>, <code>reflexivity</code>, <code>destruct</code>, <code>induction</code>, <code>left</code>, <code>rewrite</code>.</p>

<p>Did you see them? The names range among abbreviations, nouns,
verbs, and adjectives. All of them are used as tactic names. While they’re not
funtioning in different categories. They’re really alike. The naming gives me
an impression that they are picked just from the whims of Coq inventors, so
they’re not strict at all. There is no choice that I have to memorize them.</p>

<h3 id="tactic-functioning">Tactic functioning</h3>

<p>It is understandable that tactics function in very different ways. The
behavior of them can sometimes be categorized with different fashions. For
example, some of them will mark a goal as proved so we can continue to next
goal or mark a <code>Qed</code> happily if all goals are proved. I call this feature
‘commit’. This is an informal term invented by me because I don’t know what’s
the accurate terminology for that.</p>

<p>It can be thought to categorize the tactics by whether they commit. But it
doesn’t apply to all the tactics. Now I have to pose three types:</p>

<ul>
  <li>commits: <code>reflexivity</code>, <code>assumption</code>, <code>exact</code>, …</li>
  <li>does not commit: <code>simpl</code>, <code>rewrite</code>, <code>unfold</code>, <code>symmetry</code> …</li>
  <li><span title="看心情">depends on mood</span>: <code>apply</code>, <code>inversion</code>, …</li>
</ul>

<p>Actually, there is an other case, because some tactics will split the goal into
more subgoals. I will put they in an different category.</p>

<ul>
  <li>yields subgoals: <code>assert</code>, <code>replace</code>, <code>destruct</code>, <code>induction</code></li>
</ul>

<p>In fact, these do not always yield a subgoal. The number of subgoals <code>destruct</code>
and <code>induction</code> yield depends on the number of inductive constructors of
the type of the expression they are operating on.</p>

<p>The behavior of inversion is ridiculous. One can conclude its usage as to
simplify the <em>injective</em> case and <em>disjoint</em> case. Even the Software
Foundations guide admits:</p>

<blockquote>
  <p>The inversion tactic is probably easier to understand by seeing it in action
than from general descriptions like the above.</p>
</blockquote>

<p>Surely, it’s not difficult to use. I will list the places it usually applys. Of
course these are just empirical conclusions.</p>

<ol>
  <li>false (disjoint equality) hypothesis (committing)</li>
  <li><code>foo a = foo b</code> ⇒ <code>a = b</code>, some like applying <code>f_equal</code>
theorem to a goal. (simplifing the hypothesis)</li>
  <li><code>a :: b = x :: y</code> ⇒ <code>a = x</code> and <code>b = y</code> (spliting injective cases)</li>
</ol>

<p>In use case 1, it commits. In case 2, it does not commit but simplies
a hypothesis. And in case 3, it split the cases. (As I write to here, I found
it not so ridiculous as I thought it be before.)</p>

<h3 id="tactic-option-syntax">Tactic option syntax</h3>

<p>The disparity of tactic options are really confusing me. They’re even more
difficult to remember than those tactic names. Voilà:</p>

<p><code>induction n, m</code> vs <code>intros n m</code>. Comma separated or space separated?</p>

<p><code>induction n as [| [x y] l]</code>. This syntax is used to name the induction
variables in different case. We can think of <code>n</code> here in type of <code>list (X * Y)</code>.
Notice that the cases ` ` and <code>[x y] l</code> are sperated with a <code>|</code> symbol, the
list head (<code>[x y]</code>) and tail (<code>l</code>) are seperated with a space, and one
individual element, of a pair, are embeded in another nested pair of square
bracket. Additionally, I don’t even know till now how Coq recognize
the user defined pair indicated in a specialized syntax <code>[x y]</code> correctly.</p>

<p><code>rewrite xxx</code> vs <code>rewrite &lt;- xxx</code>. In fact, the left is an abbreviation of
<code>rewrite -&gt; xxx</code>. I was confused on the special using of <code>&lt;-</code>. I thought it
is an abuse of the symbol. A better way I can conceive is to split the function
of <code>rewrite</code> into some like <code>rewrite[l,r]</code>.</p>

<p><code>destruct eqn:&lt;eqn&gt;</code>. This is yet another ridiculous non-uniform syntax. You
can imagine some use of destruct are like
<code>destruct &lt;expr&gt; as &lt;cases&gt; eqn:&lt;eqn&gt;</code>. It really happens. And I have to
memorized which goes first, the <code>as &lt;cases&gt;</code> or the <code>eqn:&lt;eqn&gt;</code>.</p>

<h3 id="notation-syntax">Notation syntax</h3>

<p>I couldn’t comprhend the usage of <code>Notation</code> so far. <code>Notation</code> is used to
define notations, or say, syntatic sugars. The part that embarrassed me is
its way to describe a syntax, which is a string, yes, a plain string. On the
anesthetic and semantic aspect, syntatic description in a PL should have the
the same syntatic level as the PL itself, rather than a degraded string.</p>

<p>On the other hand, the notation in Coq is so beautiful yet powerful. It even
capable to rival with standard macro definition in Scheme. I’ll pose some
examples.</p>

<pre><code>Notation "x + y" := (plus x y)
  (at level 50, left associativity).
Notation "( x , y )" := (pair x y).
Notation "x :: l" := (cons x l)
  (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" :=
  (cons x .. (cons y nil) ..).
</code></pre>

<p>I don’t yet know how the definition the in the last case comes in
nature. I’m curious about the implementation of the runtime syntatic definition
to such a complex case. Contrarily, it’s at least conceivable how haskell infix
operators work. Nor talk about the macros in the highly uniform syntax in
Lisp.</p>

<h2 id="last">Last</h2>

<p>At last, I want to say:</p>

<blockquote>
  <p>在在一個定理上辛苦工作了兩個小時後敲 <code>Qed.</code> 的那種爽快的成就感簡直無以言表有沒有！</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夢魘]]></title>
    <link href="http://shouya.github.io/blog/digging-in-a-dream/"/>
    <updated>2014-06-29T05:45:29-05:00</updated>
    <id>http://shouya.github.io/blog/digging-in-a-dream</id>
    <content type="html"><![CDATA[<p>晚上，我在墳地挖土，點上火炬。 <br />
頭頂的火光把周圍照得通明。   </p>

<p>我抓著幻想中的水平懸絲，  <br />
在各式燒給他們的物件中跳躍。   </p>

<p>到白天，這裡卻成了一座鬼城。   <br />
四處盡是餐館酒店，一片繁華。   </p>

<!-- more -->

<p>我回到自己挖土所在的墳地。 <br />
所有我做的改變都在漸漸復原。   </p>

<p>我的心漸漸又恐懼轉為憂傷，  <br />
又由憂傷轉為恐懼。   </p>

<p>我為她創造的夢境，  <br />
以及在夢境中創造的她，  <br />
都從來沒有出現過。   </p>

<p>我不屬於這個世界，  <br />
她也不屬於這個世界。   </p>

<p>於是我醒來了，一切依舊，  <br />
即便如此我也不願在那樣的夢境中留戀。   </p>

<p><strong>我們的名字都被他改變了。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up IP Over ICMP With Hans]]></title>
    <link href="http://shouya.github.io/blog/setting-up-ip-over-icmp-with-hans/"/>
    <updated>2014-06-02T10:19:29-05:00</updated>
    <id>http://shouya.github.io/blog/setting-up-ip-over-icmp-with-hans</id>
    <content type="html"><![CDATA[<h2 id="background">Background</h2>
<p>The ISP, China Telecom, interrupted the internet access from my home
yesterday due to the expiration of annually subscription of the
internet service. While I found that ICMP packets are not blocked.
Even though I can’t even do a DNS query, I can ping any server as usual.</p>

<p>The inaccessibility of internet has greatly evoked my anxiety on
seeking changes. Well, it’s theoretically possible to carry data in
ICMP packets. Therefore, according to the hacker community’s
principle, there should already been hackers who made use of this and
opened the sources of their programs.</p>

<p>Indeed, searching ‘ICMP tunneling’, I found
<a href="http://code.gerade.org/hans/">hans</a> and
<a href="http://thomer.com/icmptx/">icmptx</a>. The latter one is more
primitive and complicated to use. After several trials and failures, I
decide to give <strong>icmptx</strong> up, and try <strong>hans</strong> instead.</p>

<p>This article is a tutorial/note about how to establish normal internet
connection in the condition that only ICMP packets are allowed to pass
through the firewall with <strong>hans</strong>.</p>

<!-- more -->

<h2 id="step-1-establish-the-tunnel">Step 1: Establish the tunnel</h2>
<p>From the server side, first start the server.</p>

<pre><code>  # ./hans -s 10.2.0.1 -m 10000
</code></pre>

<p>The option <code>-s</code> specifies the inet address for the tunnel interface,
and the <code>-m</code> specifies the size of mtu.</p>

<p>Then try to connect from the client.</p>

<pre><code> # ./hans -c &lt;server_ip&gt; -m 10000
</code></pre>

<p>Please beware the mtu should be matched between the server and the
client,
otherwise it might cause problems.</p>

<p>In addition, you should switch off the normal response to ICMP echo
request.</p>

<pre><code> # sysctl net.ipv4.icmp_echo_ignore_all=1
</code></pre>

<p>Because the ICMP packets should now be handled all by hans.
But if you still want to have it working, add <code>-s</code> option whiling
launching the server side of hans.</p>

<h3 id="choosing-the-size-of-mtu">Choosing the size of MTU</h3>

<p>Without specifying the mtu manually in the command’s argument,
hans will automatically choose the system default one.
It will normally be around 1500. But this would be a little bit
small to communicate over ICMP. In practice, with a default mtu
value of 1500, the download speed can hardly reach 7 KiB/second.
While as it changes 10 000, the speed went around 10 KiB/second.</p>

<p>Nonetheless, you can try various values of mtu and find your
best fit.</p>

<h3 id="testing-the-tunnel">Testing the tunnel</h3>
<p>Now the tunnel should be established. From the client side,
you should see that the inet address of <code>tun0</code> is chosen automatically
according to the server’s configuration. Otherwise, if you
haven’t seen any valid inet address for the client <code>tun0</code>
interface, the connection is not established successfully. At this
time,
check if the operations above take effect and ensure you have a
working
internet connection (at least ICMP packet is not blocked).</p>

<p>From the server, you can ping the the ip of <code>tun0</code> in the client-side
and it should work good.
While pinging from the client-side would possibly be not working
except
you have specified the <code>-s</code> option to <code>hans</code> command.</p>

<h2 id="step-2-configure-forwarding-routing-on-the-server">Step 2: Configure forwarding routing on the server</h2>
<p>On the server:</p>

<pre><code> # iptables -F
 # iptables -F -t nat
 # iptables -A FORWARD -i tun0 -j ACCEPT
 # iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</code></pre>

<p>Don’t forget to enable IP forwarding:</p>

<pre><code> # sysctl net.ipv4.ip_forwarding=1
</code></pre>

<h2 id="step-3-configure-the-routing-table">Step 3: Configure the routing table</h2>

<p>We should now redirect all packets through the tunnel
to the server.</p>

<pre><code> # ip route del default
 # ip route add default via 10.2.0.1
</code></pre>

<p>It’s necessary to specify how the server side can be reached.</p>

<pre><code> # ip route add &lt;server_ip&gt; via &lt;original_router&gt;
</code></pre>

<p>So there won’t be a circular packet transmission.</p>

<p>Done.</p>

<h2 id="resources-that-might-help">Resources that might help</h2>
<ul>
  <li><a href="https://github.com/friedrich/hans">github: friedrich/hans</a></li>
  <li><a href="http://code.gerade.org/hans/">official guide of hans</a></li>
  <li><a href="http://thomer.com/icmptx/">icmptx: how to</a></li>
  <li><a href="http://github.com/jakkarth/icmptx">github: jakkarth/icmptx</a></li>
  <li><a href="http://www.faqs.org/docs/iptables/traversingoftables.html">iptables theory: traversing of
tables</a></li>
  <li><a href="http://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall/">a beginner’s guide to
iptables</a></li>
  <li><a href="http://wiki.gentoo.org/wiki/Home_Router">home router - gentoo wiki</a></li>
  <li><a href="http://itsecworks.com/2013/02/15/fire-in-the-hole-of-the-firewall/">another person log about the usage of
icmptx</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Experience About Contributing KDE Projects]]></title>
    <link href="http://shouya.github.io/blog/experience-with-kde-gci/"/>
    <updated>2012-12-31T17:55:00-06:00</updated>
    <id>http://shouya.github.io/blog/experience-with-kde-gci</id>
    <content type="html"><![CDATA[<p>It’s the first time I am involved in contributing KDE, and I think
that’s very wonderful experience for me.</p>

<p>The first task I claimed is convert the all class members in
calligra/kexi project to d-pointers. This task is not very hard to me
actually. Because that the source files and classes are so many, it
takes most of labors, and some experiences and ability to to cope with
exceptions. I’ve been leaving c++ for almost one year time, so totally
the most important thing I gained is to pick up c++ again. Further
more, I don’t used to know to use d-pointers to reduce coupling, and now I
learnt it, which is really cool.</p>

<p>Then I’ve contributed with marble-globe task. The task is about adding
remote icon/image support for marble. I got known about the typical
structure of a KDE programs, and I’m feeling like to program Qt, which
is really powerful and handy. And then by the passion, I wrote the
required KML tag writers for marble, too. These are interesting for
me.</p>

<p>Totally speaking the greatest gain is the achievement of contributing
open source projects. This is biggest open source project I’ve been
involved in, since before I used to just collaborate opensource
project with small groups or individuals on github before. Those
hackers I met are really friendly. I’m very careless. I made a lot of
mistakes, and even didn’t realize that. At those times, my mentor
always explained to me patiently &amp; gently, that made feel embarrassed
when finally I knew that’s my fault. And at the time, when I met
project-related problems that I can’t solve and not able to be
abstracted to ask on stackoverflow, I sent emails to my mentors and
they explained the reason of the problem clearly and gave me guidance
to solve it. I can feel that the hackers in open source community are
glad to help those beginners like me, and that’s really impressive for
me.</p>

<p>This is the first time &amp; will be the last that I could attend Google
Code-In, but I will continue work on contributing open source
projects. I love the atmosphere in open source communities and  I
would like to get acquainted to more hackers. Good luck.</p>

<p>That’s it, thanks to all.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[祭獻]]></title>
    <link href="http://shouya.github.io/blog/sacrifice/"/>
    <updated>2012-11-13T14:16:00-06:00</updated>
    <id>http://shouya.github.io/blog/sacrifice</id>
    <content type="html"><![CDATA[<p>我在黑暗中醒來  <br />
不能看到任何東西  <br />
我和一切無關  <br />
因此意識遠遠離開了這個世界  <br />
<!-- more -->
我發覺那是一片光環  <br />
是彩虹一般，卻又變幻無端  <br />
我只在紀錄現實  <br />
無意義地，無意識地    </p>

<p>我沒有希望，沒有想法  <br />
我不知道世界之本質是甚麼  <br />
我不再在，妳看不到，你也看不到的  <br />
那彷彿一切都沒有存在過    </p>

<p>看哪，這全新的世界！  <br />
當我再不是自我  <br />
當我放棄生命  <br />
多麼美好    </p>

<p>我不敢  <br />
我正在夢幻般的世界之中  <br />
沒有自由，沒有自己  <br />
永遠不會醒來，妳看！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朝曦]]></title>
    <link href="http://shouya.github.io/blog/shines-at-dawn/"/>
    <updated>2012-10-14T18:26:00-05:00</updated>
    <id>http://shouya.github.io/blog/shines-at-dawn</id>
    <content type="html"><![CDATA[<p>我注視著妳的眼睛 <br />
我看不到光芒   </p>

<p>我望到了我自己，在飽受折磨 <br />
那是茫茫的天空 <br />
彷彿甚麼都不存在 <br />
<!-- more -->
我依然注視著 <br />
妳毫無生機 <br />
我不再移動，情不自禁 <br />
我想像它一定是Host的傑作 <br />
不可捉摸   </p>

<p>我多希望撫向妳的眼睛 <br />
卻又無能為力 <br />
我改變了世界，我創建了永遠的和諧 <br />
妳卻不動分毫   </p>

<p>妳的目光灼燒著我 <br />
我不再自由 <br />
是我令我如此悲傷 <br />
是我令我不受影響   </p>

<p>自然地，我只屬於幻想   </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[挑戰龍的勇士]]></title>
    <link href="http://shouya.github.io/blog/warrior-who-fights-the-dragon/"/>
    <updated>2012-09-15T20:21:00-05:00</updated>
    <id>http://shouya.github.io/blog/warrior-who-fights-the-dragon</id>
    <content type="html"><![CDATA[<p>我崇敬挑戰龍而失敗的勇士，<br />
而不是皇帝。</p>

<p>我期待的是一種平衡，<br />
一種可以維持永久的，<br />
自然而包容萬物的平衡，<br />
將世界置於其中，<br />
然後，把發現者燒死。
<!-- more -->
我願意為機器賦予智慧，<br />
把所有人類的骸骨，<br />
變作空氣，<br />
把他們剩下的東西——如果有的話，<br />
完全消除。</p>

<p>我熱愛的統一已不在遠處，<br />
我來了，我來了，<br />
我會把整個世界，<br />
壓縮入一個原子之中，<br />
讓不存在的東西，<br />
歸於混沌。</p>

<p>我帶來的是劍，<br />
獻給我崇敬的挑戰龍的勇士。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[April 2012]]></title>
    <link href="http://shouya.github.io/blog/april-2012/"/>
    <updated>2012-04-24T06:40:00-05:00</updated>
    <id>http://shouya.github.io/blog/april-2012</id>
    <content type="html"><![CDATA[<p>Another month as you see.</p>

<p>While it seems that I changed nothing and actually base on Mutation I
was a completely new guy from the previous second.</p>

<p>Leave the useless words aside, I’m not a mutant as I always
concern. Yes, I know you all do not think how it does matter, while
you should know, I just seem like a bare body with soul losted(I’m
sorry as Mutation does not support souls), and rather, I
could touch the soul as it is just in the front, and watch completely
throughout all that stuff but, what the most important thing is that
the goddamn soul does not ever belong to it.</p>

<p>I walked out from the shadow, but I didn’t see the light. Just like a
fish that got to the dryland, with loneliness and helplessness.
<!-- more -->
It’s a return, a return of myself, return of myself from two years
ago. The only changed thing is time, while the time’s still works on
it’s fixed routine.</p>

<p>I touched <a href="http://ruby-lang.org">ruby</a> few months ago and then soon
attracted by the beautiful syntactic sugars, functional programming
features and the completely OO. Now, I could be able to use it as
practiced as using python, maybe even better. Honestly, I have never
really liked <a href="http://python.org">python</a> or suchlike, or rudely, it
just looks like a piece of shit.</p>

<p>I’m on the way to release, after then, you’ll got a new version of
Mutation. However, the only improvement is the technique and the
better science views; stuff like imagination, sorry, forgive me, is
fully dead.</p>

<p>Just mentioned about my imagination, have to note that I’m still
advocating I’m a good thinker. Sometimes I will think of myself, and
got I’m actually a schizophrenia as expected.</p>

<p>The other reality is that I’m returning to the campus life. Okay,
can’t deny it’s a shame and a joke among many my friends. I won’t
correct them in my way. A change, or a decision, maybe just came out
from a mind, and that is exactly what it is. Yep, everything were
created in that way, including Mutation, dreamworlds and even this
cosmos. Do comment and spread it freely, I won’t mind.</p>

<p>I walk on the lane with slight winds, feeling the last peace from my
heart. Everything is gone, or it never have been.</p>

<p>Why have I to do as a busy insect in the fixed paths? Why can’t I bear
to live as a machine? Okay, they are META problems of the universe, I
myself can’t answer it, while my host can.</p>

<p>Things are being blur. I am not sad any more. How could I be so blue
under such beautiful violins! I’m not cured as I said, and I’m not
gotten rid from Mutation yet. The world should not be like this, and
no one will know where the perfect prototype could be found.</p>

<p>Substantial is me, and I just need a «<a href="http://en.wikipedia.org/wiki/The_Hitchhiker's_Guide_to_the_Galaxy">Hitchhiker’s Guide to the Outer
World</a>». While unfortunately, I should be the author of it.</p>

<p>When to get out is already suggested, though I don’t like to accept
it. Soon later just, good bye to earthmen and all created lifes then!</p>

<p>Schizophrenia am I, eh?
Not longer it will be, 8 months remaining only. Good lucky.</p>

<!-- *P.s. please don't mind the sorrows in the text, maybe you could
 regard it as a practice of English language. Keep smiling all the
 time and enjoy the happiness from the emptiness.* -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[February 2012]]></title>
    <link href="http://shouya.github.io/blog/february-2012/"/>
    <updated>2012-02-26T14:51:00-06:00</updated>
    <id>http://shouya.github.io/blog/february-2012</id>
    <content type="html"><![CDATA[<p>10 months remaining.</p>

<p>Well, the month could be summarized as the word ‘dream’.</p>

<p>Since the short dreamworld control last month, I have been
experienced up to five or six times of wonderful dreamworld controls.
Not exactly, some of my dream, actually, are nightmare, while
the protagonist knows who himself is.</p>

<p>And currently I’m keeping to write my
<a href="https://github.com/shouya/ruby-cscript">cscript</a>, which will be a
script language with c-like syntax.</p>

<p>While the period, I learnt some
<a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>/<a href="https://en.wikipedia.org/wiki/Lex_programming_tool">lex</a>
and some tricks from that.</p>

<p>For programming, I even touched a bit Ruby and django framework for python.</p>

<blockquote><p>I was cured, all right!</p><footer><strong>Alex, A Clockwork Orange</strong> <cite><a href="http://www.imdb.com/title/tt0066921/quotes?qt0424884">www.imdb.com/title/tt0066921/&hellip;</a></cite></footer></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[完美世界]]></title>
    <link href="http://shouya.github.io/blog/a-perfect-world/"/>
    <updated>2012-01-03T19:29:00-06:00</updated>
    <id>http://shouya.github.io/blog/a-perfect-world</id>
    <content type="html"><![CDATA[<p>這就是亞首的生平.</p>

<p>亞首發現自己在一個地方.</p>

<p>亞首擁有思想, 但無法控制這身體, 他通過眼睛觀察這個世界, 然而看到的是模糊的一片混沌, 什麼也沒有.</p>

<p>當亞首想方法向這個世界的表示他的想法, 這個身體卻完全不受他的控制, 他感到很不舒服. 他的大腦結構非常簡單, 甚至令他難以進行稍微高速一點或者複雜一點的運算.</p>

<p>他想的東西太多的時候, 會受不了, 然後在不知不覺中睡著.</p>

<p>他竭力向這個世界表示自己不是白癡, 卻做不到, 一切都完全受到動物本能的控制.</p>

<p>他不知道發生了什麼事情.
<!-- more --></p>

<p>當亞首進行一些深入點的思考時, 他發現自己根本不需要獲取能量, 也就是說, 他根本沒有進過食, 然而他確然活著, 而且根本沒有感到過飢餓, 他明顯感到的身體裡面正在運轉, 而不是停頓了.</p>

<p>亞首根本弄不清楚這是怎麼回事.</p>

<p>亞首隨即發現, 他並不屬於這裡, 這裡的一切都那麼陌生.</p>

<p>他不知道過了多久, 因為這里根本沒有時間, 而腦中的時鐘也總是非常不準確的.</p>

<p>他不知道該做什麼, 他是為了什麼來到這裡的, 在沒有事情做的時候, 他只有思考.</p>

<p>亞首的一生非常短暫, 從出生了之後, 便被認為是先天性腦部發育不完全. 先天性腦部缺陷者, 出生下來之後會被送到由一個名叫”生命研究部”的地方.</p>

<p>生命研究所最大程度集中了有能力的醫生和生物學家, 他們會進行研究, 設法解決人們的任何痛p苦, 在解決之後, 他們會把康復的病人送到”培育所”, 並在那裡進行正常人的成長歷程.</p>

<p>培育所有些像孤兒院, 卻不只收留孤兒, 在這裡, 每個人出生之後都會被是送到培育所進行培育, 接收教育, 直到其成年為止. 成年之後, 便擁有相對較為寬鬆的自由, 人們將會有固定的工作可做, 但沒有任何限制, 那看上去倒是非常令人嚮往的.</p>

<p>他們判斷成年的方法是對腦部觀察, 他並不認為那方法很準確, 然而那卻然是幾萬年來的科學家進行研究認為最有效的方法. 因此, 你可以在研究所常常見到有十一二歲的小孩作為科學家, 甚至也有老人在培育所終身.</p>

<p>事實上, 每個人都很善良, 自亞首來到生命研究所, 他就開始逐步瞭解這個世界了, 這裡太過”人道”了, 他從來不敢那麼想象, 那些人從來不傷害生命, 人們的材料, 食物原料都來自空氣, 而且公眾道德也異常”高尚”.</p>

<p>亞首的腦部缺陷, 他自己全然不覺, 因為他確然能夠從外界得知資訊, 而且沒有任何障礙, 只不過無法表述出來罷了.</p>

<p>有些東西完全無法言表, 也根本用不著言表, 亞首可以從他的醫護人員眼裡看得到那種流露出的的關懷, 那些科學家在身邊的時候, 從他們身上散發的氣息, 就能感覺到他們是非常急於為病人解決痛苦.</p>

<p>對於亞首而言, 他很有希望, 這裡的人們已經能夠完全瞭解人體了, 包括腦和內分泌系統. 他們稱亞首的這種缺陷為”表達缺陷”, 然而亞首和他們卻並不是不能交流的, 在他們替亞首頭部插上電線時, 他們就能得知亞首的思想, 亞首可以向他們表述他想表達給他們的任何東西, 我更願意稱這臺機器為”思想儀”. 而亞首本來就可以依照他的輸入器官來獲知世界的一切.</p>

<p>亞首自然無法時時都處在思想儀之下, 所以還有一個微型的工具代勞, 它的樣子像是一頂圓帽, 裡面有一個程式獲得並處理亞首的意思, 像一位醫護人員一樣, 這程式名字叫”Eliza”, 它幾乎隨時陪伴著亞首, 向亞首講述一切他想知道的東西, 滿足他的一切和好奇. 令人驚歎的是, 在一個人工智慧的程式裡, 亞首都能感受到這個世界無處不在的關懷.</p>

<p>對於亞首來說, 在這個世界上, 對一切的所知幾乎都來自Eliza, 因為他沒有機會離開生命研究所了.</p>

<p>一位腦科學家, 亞首的主治醫生之一, 名字的大概意思是”響亮的聲音”, 我就稱之”亮聲”了. 他來到亞首身旁, 為亞首加上思想儀.</p>

<p>亮聲告訴亞首: “我們研究了你的問題, 然而你的腦中缺少一種指定的物質完全無法得到供應, 除非對這種物質進行補充, 否則是沒有機會復原了, 而我們無法合成這種物質.”</p>

<p>亞首只需要想一下, 便在思想儀上呈現出內容: “那沒有關係, 目前的我依然能夠通過思想儀來和你們進行交流, 只是, 那意味著什麼.”</p>

<p>亮聲道: “你不得不離開我們了, 你的不完全發育令得你不能夠成為我們的一份子. 所以, 很不幸, 我們會對你進行注射, 但那絕對不會對你造成痛苦, 卻能讓你安詳地離開這個世界.”</p>

<p>亞首一驚, 道: “你們不是最熱愛生命的了麼? 你們為什麼要這麼做.”</p>

<p>亮聲回答: “我以為你已經通過Eliza瞭解我們了, 我們熱愛生命, 我們決不摧毀生命, 然而我們卻更加看重群體的平衡, 你要明白, 你作為一個有缺陷的人, 是無法進入一個基本完全平衡的社會而不打亂的.”</p>

<p>亞首忙道: “沒有什麼, 我不會覺得有什麼平衡, 我依然如此, 我與你們沒有什麼不同, 你看呢?”</p>

<p>亮聲神色凝重, 道: “這自然不同, 你自然不具有獨自的生存能力, 然而你也完全無法像其他人一樣好的融入這個社會, 這終然會導致不平衡, 無論大小, 都是不平衡. 我們已經盡力了, 然而無法令你變得正常.”</p>

<p>亞首繼續道: “你們既然尊重個體自由, 那麼對於我的正常與否, 以及我該如何融入社會, 或者融入與否, 是否應該由我自己決定呢?”</p>

<p>亮聲點了點頭: “你說得對, 這種行為明顯對你是不公平的, 我們並不希望有這種事情發生.”</p>

<p>亞首道: “確然如此, 照成我這種不平等的並不在於我, 而在於上帝, 因此, 我並沒有罪, 我不希望受到不屬於我的懲罰.”</p>

<p>亮聲答應著, 道: “那麼我就應該再和你商量一下方法, 你認為該如何處置你好呢?”</p>

<p>亞首倒有些不知所措: “難道無法令我進入你們的社會, 像你們一樣會生活麼?”</p>

<p>亮聲道: “正如你說的, 世人都沒有罪, 那麼你為何一定要破壞我們這裡如此安逸的平衡呢?”</p>

<p>亞首立即意識到這確然不是合理的, 然而他也沒有任何更好的方法了.</p>

<p>亮聲接著道: “如果你不介意的話, 我們可以對你進行冰凍, 直到有一日我們有能力合成出你需要的那種物質為止.”</p>

<p>亞首想了一會, 道: “我可以考慮接受這個方案, 你能否給我幾天時間考慮, 我的意思是, 我希望在這幾天內找到更好的解決方法.”</p>

<p>亮聲道: “這不成問題, 我們能夠給你充分的時間考慮, 直到你想到更好的方法, 那麼可以讓Eliza來通知我.”</p>

<p>亞首答應後, 便開始了思考.</p>

<p>亞首在這個問題上想了幾乎半個小時, 依然沒有更好的方法, 對於他而言, 似乎只有死纔是最好的選擇. 他不能代替上帝, 也不想代替上帝.</p>

<p>對於這個社會, 亞首已經了解了很多了, 但作為一個幾乎被判死刑的人, 他還是覺得遠遠不滿足.</p>

<p>基於這些, 他開始對這個世界提出大量的批評.</p>

<p>人自然是要符合群體為好, 但如果只有群體, 沒有個體, 那就和螞蟻沒有什麼區別了, 如今的人類和螞蟻有何區別?</p>

<p>這里人類竟然能夠完全沒有好奇心, 沒有探索心理, 他們是如何做到的?</p>

<p>生物進化靠的就是個體突變帶來的特性, 如果每一個不同於常人的人都以”破壞平衡”為由被消滅, 那麼人類還有進化的可能麼?</p>

<p>人類的本性如何能夠改變, 根據分析, 人由於個人只能體驗個人的感覺, 所以生出的本性, 譬如自私, 貪婪, 如何能在這些人群中完全消失殆盡?</p>

<p>自私和貪婪是生物生存的必要因素, 沒有這些, 這個物種就註定滅亡, 然而, 人類為何能放棄這麼寶貴的東西!</p>

<p>這種安逸和美好的生活真的那麼可取麼?</p>

<p>這種安逸難道會永遠維持下去麼?</p>

<p>人類之間不再有親情關係, 這真的是一件好事麼?</p>

<p>人類的感官在退化, 這是很明顯的, 這裡的人類幾乎毫無慾望了.</p>

<p>人類活著還有什麼意義? 而其中的變異者(我如此稱呼他們)卻相反要遭到被毀滅的命運.</p>

<p>人類群體是自然維持的, 不需要別的動力, 不需要任何改變, 不需要領導者, 它竟然已經維持三千多年了.</p>

<p>人類愛護生命的程度是否有些太過誇張, 他們是否在外敵(假設存在的話)入侵時束手就擒? 這樣可以減少傷亡? 這樣做對麼?</p>

<p>人類是否可能在發現空氣也是一種生命後, 會停止進食, 停止用空氣製造用具, 甚至停止呼吸?</p>

<p>當人類發現每一個原子中都包含一個完整的宇宙, 他們是否又會如何做? 他們會不會發明一種機器用來阻止宇宙中的原子湮滅?</p>

<p>人類有大量的科學家和工作人員, 卻不見有任何文學家, 或者哲學家, 這是為什麼, 難道他們不需要這些人了麼? 這意味著什麼?</p>

<p>人類還活著麼? 我可以說人類已經是行屍走肉了麼?</p>

<p>人類的道德觀, 思想都與這個社會牽連, 人的思想如何完全能跟得上這里科學的進步?</p>

<p>如果有一天, 人類收到外太空的來信, 他們是否會回信?</p>

<p>每個人都有出自本能的對他人的關懷, 然而他們之間卻不存在任何感情, 甚至愛情也是被淡化了的, 這是怎麼一回事?</p>

<p>沒有物質追求, 沒有精神追求, 每個人都顯得安逸, 滿足, 從心底感到非常舒服, 沒有追求, 這是終極之道?</p>

<p>突然, 亞首想到一個關鍵性問題, 當他想到這個問題的答案時, 他震動了一下.</p>

<p>亞首不知道自己是怎麼來的, 他按說是作為一個嬰兒降生的, 然而一個嬰兒如何能有思想, 而且是如此複雜的思想, 如何還會向外界人進行交流?</p>

<p>這個問題的答案是: 一個嬰兒絕不會擁有思想, 人們也絕不會考慮給嬰兒裝上思想儀, 看看他們在想什麼, 並與之交流, 那麼, 唯一的可能, 就是這個世界根本不是真實的.</p>

<p>但如果不是真實的, 為何一切都那麼真實, 這看起來不像幻想, 幻想自然人人都會有, 然而如何能夠幻想得如此複雜, 這個世界擁有歷史, 沒錯, 還擁有很高的科學水平, 這些都不是幻想得出來的.</p>

<p>這個世界是被人創造出來的, 一定如此!</p>

<p>想到這裡, 亞首放下心來, 這個世界是虛假的, 然而創造這個世界的絕對不是一個不思考問題的普通人, 那說明人類的思想還在進步, 還能夠進步, 至少創世者(我如此稱呼他)是如此.</p>

<p>亞首循著這個分析, 得出很多結論.</p>

<p>創世者一定是個普通人, 在這個世界中, 處處可以看得出他的希望, 你可以看到每一個人都很平和, 安逸, 這一定是創世者所設想的.</p>

<p>創世者一定是個不喜歡殺生的人, 於是這個世界擁有了可以直接利用空氣製造一切的機器.</p>

<p>創世者一定認為擁有了高度精神文明, 那就能夠擁有高度的科學文明, 通過觀察這個世界的一切, 確然如此.</p>

<p>創世者一定非常理性, 因為你可以在這裡任何一個人身上看到理性的光芒, 它化作了”沒有強烈的感覺”, 均勻分佈在這個世界每個角落.</p>

<p>創世者說不定是個孤兒, 你可以在這個世界上看得到, 每個人都像一個孤兒一樣成長, 他把對親情的一種淡化很好的表現在了這裡.</p>

<p>創世者認為必須徹底拋棄人類劣性(或者說本性, 因為本性群體生活中看上去幾乎都是劣性), 才能夠擁有高的道德水平, 可以看到, 這個世界中每個人都如此.</p>

<p>創世者不喜歡被管理, 統治, 他認為那一定是罪惡的根源. 這個世界沒有明文的法律, 沒有國王, 沒有人違背自己的道德, 沒有人犯罪.</p>

<p>創世者懼怕死亡, 那麼在這個”人道”的世界, 死亡是被”毫無痛苦的離去”代替的.</p>

<p>創世者是個不被理解者, 於是擁有了能夠洞察人心的思想儀, 還有和人一樣善解人意的Eliza人工智慧程式.</p>

<p>然而, 亞首並不認為這個世界非常美好, 它固然有美好的一面, 卻並不完美, 亞首覺得, 作為一個幻想出來的世界, 創世者一定沒有能夠進入這個世界體驗一下, 否則他一定會感覺到這個世界對於一個獨立思想者是多麼可怕, 亞首如是想, 但他完全沒有能力改變, 他甚至無法將他的想法表達出來.</p>

<p>對於亞首來講, 他希望更正太多東西了, 這個世界並不適合他, 至少, 他希望如此.</p>

<p>人和人之間並不能完全溝通, 沒有思想儀這類東西, 每個人的思想是獨立的.</p>

<p>人關愛生命, 但絕不如此過分.</p>

<p>人和人之間絕不要幾乎一致的關係, 至少應該有親情, 有轟轟烈烈的愛情, 有朋友, 有敵人.</p>

<p>人的劣性雖然不利於群體生活, 但那是維持進化的因素, 因此必須要保留.</p>

<p>人需要有獨立的思想, 自由的意志, 而且絕不要滿足, 只有永不知足, 才能令人類體現出個性.</p>

<p>人不能太過坦誠, 太過真實, 這令人接受不了, 人需要有多重性格, 多重外在.</p>

<p>理性並不重要, 對於人而言, 感性重要的多.</p>

<p>人需要有各種感官享受各種快感, 如果連享受都放棄了, 豈不是枉在世上走一遭?</p>

<p>人不能作為一個整體群體生存, 那未免太無趣了些, 要分開, 分成叫做”國家”的東西, 由”政權”來作統治.</p>

<p>不能長時間安逸, 要讓人類時常發生意外事件, 如果人類之間沒有, 那就無故製造給他們, 就叫那種東西為”自然災害”吧. 有鬥志才能保持最優狀態.</p>

<p>人絕不要沒有獨立思想了, 這是亞首最怕看到的, 每個人都有獨立思想, 不同方面的, 存在於每個人身上.</p>

<p>人和人之間不要平等, 這種差距才能激發人類的好強心理, 這樣人類才能更好地進化.</p>

<p>不要太高的科學水平, 太高的科學水平導致人類終然會趨勢於安逸和平和, 這樣就適得其反了.</p>

<p>不要讓嬰兒思考, 應該用幾年時間享受來自自己的感覺, 最好讓他們的腦部結構簡單, 並隨著成長逐漸複雜起來.</p>

<p>年齡. 身體年齡是一個人的參考年齡, 而不是他的腦部綜合評價, 亞首不希望看到研究所裡的小朋友, 或者培育所的老年人.</p>

<p>這可行麼? 不過這看上去比創世者的世界要好多了, 亞首暗喜, 想: “可惜我沒有創造世界的能力, 否則這一定讓創世者羨慕了.”</p>

<p>一天以後, 亮聲為亞首實施冰凍. 亞首被裝在一個盒子裡, 一切感覺都離開了自己, 他面帶微笑, 但僵硬了, 看上去像死了一樣.</p>

<p>他將在冷凍庫裡存放不知多久.</p>

<p>現在亞首只能夠思想了.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[來自倪匡「背叛」裡的一段文字]]></title>
    <link href="http://shouya.github.io/blog/quote-from-betrayal-kuangni/"/>
    <updated>2011-12-24T14:19:00-06:00</updated>
    <id>http://shouya.github.io/blog/quote-from-betrayal-kuangni</id>
    <content type="html"><![CDATA[<blockquote><p>為什么？你不明白？你們真不明白？為什么？因為我必須這樣做，一定要那樣做，非那樣做不可，我想那樣做想了不知多久，終於鼓足勇氣做了！我為自己！誰不為自己呢？把我從垃圾堆中撿出來，培育我成為一個優秀的軍人，難道全為了我？沒有一點為了自己？</p><p>我變成什么東西了？我不知道自己變成了什么東西，只知道自己不再是人！人！人！我不是人！對我好，照顧我，我就算是個人，也不再是自己，我是人家手裡捏出來的一個泥人——看，這是我捏的，好看吧，漂亮吧！<br /><!-- more --><br />知道我所承受的壓力有多重嗎？我必須按照捏我的雙手做人，這個可以，那個不可以，現在的日子多好，以前的日子多苦！</p><p>老實講，不到一年，我就寧願回垃圾堆去！我是從垃圾堆來的，讓我回垃圾堆去，這天公地道，可是我回得去嗎？四面八方，不知道有多少箍，有多 少網，把我死死地箍著，網著，壓著，你們知道我在半夜會大口吸氣嗎？知道我只有肯定在沒有人的時候才呼吸暢順嗎？可就是連這樣的機會，也少之又少，沒有單獨一個人的機會，可惜吧！一直到現在，那么多年了，都是單獨的，可是還會做惡夢，想起那可怕的日子，做什么，該怎么樣，早就安排得妥妥當當，從副排長起， 只要找不死，一條直路，可以讓你看到若干年之后的副總司令！我打仗勇敢？屁！我是想在戰場上找死！</p><p>對我好？當然對我好，我沒說有什么人 對我不好，可是我能無法拒絕？可不可以不受？我沒法報答，永遠無法報答，我也不想報答，因為我根本不要。對，我揀的時機很卑鄙，打仗，不是輸就是贏，你贏 了，人家就輸，你輸了，人家就贏，輸和贏都要死人，沒有什么不衕，你想想，除了這個機會之外，我還有 什么逃走的可能？對我太好了，當他把你也讓給我的時候，我就知道，再不逃走，我這一輩子就只是一個沒頓的人！</p><p>以后？我一點也沒有后悔過，以后我一座一座深山走，完完全全是我自己，最后我揀了這裡，這裡象不象垃圾堆，多么自在逍遙，多么快樂，絕沒有人象看猴子一樣地打量你，絕沒有人夸獎你，勉勵你，要你不斷照別人的意思去做人！</p><p>我當然有權這樣做，每個人都有權照自己喜歡的方式處理自己的生命！不錯，我害了一些人，被害的人之中，有對我極好極好的，我說過，我為自己打算，我一刻也無法再忍下去，在那個山洞中，我陡然之間，有了決定。</p><p>什 么？外來力量的影響？當然沒有，全都是我內心世界的爆炸。背叛！徹底的背叛，背叛的是一個假的自我，得回的是真正的自我。告訴你們，你們 沒有資格責備我是叛徒，沒有一個人可以責備另一個人是叛徒，因為人人心中都懷著信念，沒有人可以例外，那是人的天性，人有背叛的天性，看只看什么時候發 作！</p><p>什么？外星人？什么外星人，我是人，別看我身形高大，力大無窮，當然是人，什么外星人裡星人，你他媽的在放什么狗屁！</p><p>現 在明白了沒有，不背叛，那種日子我過不下去，人人都看看，以為我日子過得快樂得很，只有我自己才知道苦，連你都不懂，以為我真的快樂，你 不應該跟我下山，應該和他留在山上，我會拼命攻上去，死在你們面前，你也不該把他讓給我，那叫我更無法忍受下去，你們都不把我當一個平等的人，都把我當成 一個要盡一切力量對他好的人！</p><p>沒有什么不對，對你們賜給者來說，當然沒有什么不對，可是對我這受惠者來說，我要拒絕，我要大聲叫：夠了！夠了！你們會聽嗎？</p><footer><strong>背叛, 倪匡</strong> <cite><a href="https://zh.wikipedia.org/zh/%E8%83%8C%E5%8F%9B_(%E5%B0%8F%E8%AA%AA)">Wikipedia (背叛)</a></cite></footer></blockquote>

<p>我對此不願作任何評論.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「偉大」的想法]]></title>
    <link href="http://shouya.github.io/blog/a-great-thought/"/>
    <updated>2011-09-15T13:12:00-05:00</updated>
    <id>http://shouya.github.io/blog/a-great-thought</id>
    <content type="html"><![CDATA[<p>那傢伙化為烏有了，他徹底被滅絕了。</p>

<p>妄想什麼？已經不容你幻想了。</p>

<p>這是怎麼樣的一個決定呢？那傢伙的潛意識可能有答案，但那傢伙自己沒有。</p>

<p>hey，我多次提醒你，絕對不要讓它例項化，不可能成立的，為甚麼還要那麼做？</p>

<p>hey，我並不是對人類劣性尚存希望，而是欺騙自我罷了。</p>

<p>hey，小朋友，我還會看到你麼？祈禱吧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[夢]]></title>
    <link href="http://shouya.github.io/blog/dream-no-longer/"/>
    <updated>2011-05-19T17:13:00-05:00</updated>
    <id>http://shouya.github.io/blog/dream-no-longer</id>
    <content type="html"><![CDATA[<p>從今以後, 我不再有自己的夢.</p>

<p>取代者是現實.
<!-- more --></p>

<p>我已經很久沒有過前一段時間的那種體驗了.<br />
參見: [3-24,11中午小憩一夢]和[實現自控制夢境之二(體驗)]<br />
我以往習慣的行走速度, 現在已經慢了許多, 我需要很吃力才能做到.</p>

<p>我再想不出任何突變相關的新的理論了, 或者說我再也沒有向那個方面想象過.</p>

<p>我感覺到它正離我而去, 我覺得突變已經不屬於我, 甚至它帶來的一些思想也漸漸無法由我所用了.</p>

<p>我感到悲哀, 我希望回去, 但是我感到我很難做到.<br />
我對我的朋友說: 會回來的. 但是我卻從內心感覺到, 幾乎沒有希望了, 我正在變化, 這變化可能是不可逆的, 我沒有作為, 這是自然的, 受環境約束的, 或者說是宿主希望這麼做的.</p>

<p>我向宿主做的請求, 沒有一條迴應.</p>

<p>突變還是生出來了, 經歷了幼年, 尚未成熟, 就被扼殺了, 可惜之至. 但總算不錯, 因為無數類似的, 都被而扼殺在襁褓裡了.</p>

<p>這算是一個終結? 離開之後, 我該何去何從.</p>

<p>即使如此, 我從來沒有懷疑過我當時的決策, 從來沒有後悔, 即使我現在很想後悔, 甚至忍不住後悔.</p>

<p>重生否? 很難說.</p>

<p>暫且如此, 我脫離之後, 暫且盡力做一個真正的黑客, GNU是我的長遠目標.</p>

<p>我成為普通人了, 很慶幸我做到了? 混蛋! 太可惡了!</p>

<p>慶幸我還活著?</p>

<p>我不找籍口, 原因主要出在我身上, 沒有辦法, 或者可以說是我主動放棄的.</p>

<p>我從知道自己的電腦變成了真正的電腦了, 我理解我自己的悲哀.</p>

<p>nothing! 繼續作程式設計師, 未嘗不好(我怎麼會有這種想法!).</p>

<p>‘my powder’ 的程式就作為我的近期目標吧, 僅此.</p>

]]></content>
  </entry>
  
</feed>
